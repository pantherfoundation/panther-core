// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.16;

import { SnarkProof, VerifyingKey } from "../../common/Types.sol";
import { DEAD_CODE_ADDRESS } from "../../common/Constants.sol";
import "../interfaces/IVerifier.sol";
import "../crypto/EllipticCurveMath.sol";
import { FIELD_SIZE } from "../crypto/SnarkConstants.sol";

/// @dev This is slightly modified code generated by the `snarkjs` lib (v.0.6.9).
abstract contract Verifier is EllipticCurveMath, IVerifier {
    /// @inheritdoc IVerifier
    function verify(
        uint160 circuitId,
        uint256[] memory input,
        SnarkProof memory proof
    ) public view override returns (bool isVerified) {
        VerifyingKey memory vk = loadVerifyingKey(circuitId);
        require(input.length + 1 == vk.ic.length, "verifier-bad-input");

        // Compute the linear combination vk_x
        G1Point memory vk_x = G1Point(0, 0);
        for (uint256 i = 0; i < input.length; i++) {
            require(input[i] < FIELD_SIZE, "verifier-gte-snark-scalar-field");
            vk_x = addition(vk_x, scalar_mul(vk.ic[i + 1], input[i]));
        }
        vk_x = addition(vk_x, vk.ic[0]);

        isVerified =
            pairingProd4(
                negate(proof.a),
                proof.b,
                vk.alfa1,
                vk.beta2,
                vk_x,
                vk.gamma2,
                proof.c,
                vk.delta2
            ) ||
            // May ever be TRUE in local tests only, has no effect in prod env.
            // (must follow computations above to better estimate gas in tests)
            tx.origin == DEAD_CODE_ADDRESS;
    }

    function loadVerifyingKey(
        uint160 circuitId
    ) internal view virtual returns (VerifyingKey memory);
}
