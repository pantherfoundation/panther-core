// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2024 Panther Ventures Limited Gibraltar
// solhint-disable one-contract-per-file
pragma solidity 0.8.19;

import "../interfaces/IPrpVoucherController.sol";

import "../storage/AppStorage.sol";
import "../storage/PrpVoucherControllerStorageGap.sol";

import "../../diamond/utils/Ownable.sol";
import "../../diamond/utils/SelfReentrant.sol";

import "../../verifier/Verifier.sol";

import "./prpVoucherController/PrpVoucherHandler.sol";
import "../utils/TransactionNoteEmitter.sol";
import "../utils/TransactionChargesHandler.sol";

import "../libraries/UtxosInserter.sol";
import "../libraries/NullifierSpender.sol";
import "../libraries/PublicInputGuard.sol";

/// @title PrpVoucherController
/// @notice The PRPGrantor smart contract is designed to facilitate rewarding
/// users with Panther Protocol rewards (nominated in PRPs) other than rewards
/// generated by/within MASP transactions. Reward claims to be generated and
/// utilised by users. The contract maintains a mapping of claimable PRP
/// balances  associated with individual secrets. It accumulates generated
/// claims associated with the same secret. A claim “utilisation” results in
/// increasing the PRP balance inside the zAccount of a user by the amount
/// of the claim. To utilise a claim (it’s entire balance) associated with a
/// secret, a user must provide proof of zAccount ownership and knowledge of
/// the secret. The contract owner has the authority to update the terms, and
/// the smart contract is upgradable to extend the action list as needed upon
/// DAO voting.
contract PrpVoucherController is
    AppStorage,
    PrpVoucherControllerStorageGap,
    Ownable,
    Verifier,
    PrpVoucherHandler,
    TransactionNoteEmitter,
    TransactionChargesHandler,
    IPrpVoucherController,
    SelfReentrant
{
    using UtilsLib for uint256;
    using PublicInputGuard for uint256;
    using PublicInputGuard for address;
    using TransactionOptions for uint32;
    using UtxosInserter for address;
    using NullifierSpender for mapping(bytes32 => uint256);

    address internal immutable PANTHER_TREES;

    event RewardVoucherGenerated(bytes32 indexed secretHash, uint256 prpAmount);
    event RewardAccounted(bytes32 indexed secretHash);
    event RewardClaimed(bytes32 indexed secretHash);
    event VoucherTermsUpdated(
        address allowedContract,
        bytes4 voucherType,
        uint64 limit,
        uint64 amount
    );

    constructor(
        address pantherTrees,
        address feeMaster,
        address zkpToken
    ) TransactionChargesHandler(feeMaster, zkpToken) {
        require(
            pantherTrees != address(0),
            "init::PrpVoucherController:zero address"
        );
        PANTHER_TREES = pantherTrees;
    }

    modifier onlyValidVoucherTypes(bytes4 _voucherType) {
        require(
            voucherTerms[msg.sender][_voucherType].enabled,
            "PrpVoucherController: Inactive or invalid voucher type"
        );
        _;
    }

    /**
     * @notice Generates a reward voucher for a given secret hash and voucher type.
     * @param _secretHash The secret hash for the reward voucher.
     * @param _amount The amount of the reward voucher.
     * @param _voucherType The type of the reward voucher.
     * @return _prpToGrant The PRP amount that has been granted.
     * @dev Verifies if the voucher type is valid, then creates a reward voucher for
     * the secret hash with the specified amount. Emits the `RewardVoucherGenerated`
     * event upon successful creation.
     */
    function generateRewards(
        bytes32 _secretHash,
        uint64 _amount,
        bytes4 _voucherType
    )
        external
        onlyValidVoucherTypes(_voucherType)
        returns (uint256 _prpToGrant)
    {
        _prpToGrant = _generateRewards(_secretHash, _amount, _voucherType);

        emit RewardVoucherGenerated(_secretHash, _prpToGrant);
    }

    /**
     * @notice Updates the terms for generating reward vouchers.
     * @param _allowedContract The address of the contract allowed to generate reward vouchers.
     * @param _voucherType The type of the reward voucher.
     * @param _limit The limit for voucher grants.
     * @param _amount The amount of PRP to grant for the voucher.
     * @param _enabled The status of the voucher type (enabled or disabled).
     * @dev Allows the contract owner to modify the terms for reward vouchers, including the allowed
     * contract, voucher type, limit, and grant amount. Emits the `VoucherTermsUpdated` event
     * upon successful update.
     */
    function updateVoucherTerms(
        address _allowedContract,
        bytes4 _voucherType,
        uint64 _limit,
        uint64 _amount,
        bool _enabled
    ) external onlyOwner {
        _updateVoucherTerms(
            _allowedContract,
            _voucherType,
            _limit,
            _amount,
            _enabled
        );

        emit VoucherTermsUpdated(
            _allowedContract,
            _voucherType,
            _limit,
            _amount
        );
    }

    /**
     * @notice Accounts for rewards by converting PRP tokens into zZKP tokens.
     * @param inputs The public input parameters to be passed to the verifier
     * (see `PrpAccountingPublicSignals.sol`).
     * @param proof The zero knowledge proof
     * @param transactionOptions A 17-bit number where the 8 LSB defines the cachedForestRootIndex,
     * the 1 MSB enables/disables the taxi tree, and other bits are reserved.
     * @param paymasterCompensation Compensation for the paymaster.
     * @param privateMessages Private message of the user.
     * (see `TransactionNoteEmitter.sol`).
     * @return utxoBusQueuePos The position in the UTXO bus queue for the first UTXO.
     * @dev Validates and processes UTXO rewards accounting. The user chooses whether UTXOs are added
     * quickly via the taxi tree or slowly via the bus tree using `transactionOptions`.
     * Also handles validation of public inputs and spends the nullifier of the UTXO being used.
     * Emits `RewardClaimed` upon successful claim and processes associated rewards.
     */

    function accountRewards(
        uint256[] calldata inputs,
        SnarkProof calldata proof,
        uint32 transactionOptions,
        uint96 paymasterCompensation,
        bytes calldata privateMessages
    ) external selfReentrant returns (uint256 utxoBusQueuePos) {
        _validateExtraInputs(
            inputs[PRP_ACCOUNTING_EXTRA_INPUT_HASH_IND],
            transactionOptions,
            paymasterCompensation,
            privateMessages
        );

        _checkNonZeroPublicInputs(inputs);

        {
            uint256 creationTime = inputs[
                PRP_ACCOUNTING_UTXO_OUT_CREATE_TIME_IND
            ];

            creationTime.validateCreationTime(maxBlockTimeOffset);

            uint256 zNetworkChainId = inputs[
                PRP_ACCOUNTING_ZNETWORK_CHAIN_ID_IND
            ];

            zNetworkChainId.validateChainId();
        }

        _sanitizePrivateMessage(privateMessages, TT_PRP_ACCOUNTING);

        isSpent.validateAndSpendNullifier(
            inputs[PRP_ACCOUNTING_ZACCOUNT_UTXO_IN_NULLIFIER_IND]
        );

        bytes32 secretHash = _claimRewards(inputs);

        {
            uint160 circuitId = circuitIds[TT_PRP_ACCOUNTING];
            verifyOrRevert(circuitId, inputs, proof);
        }

        {
            uint96 miningReward = accountFeesAndReturnMiningReward(
                feeMasterDebt,
                inputs,
                paymasterCompensation,
                TT_PRP_ACCOUNTING
            );

            uint32 zAccountUtxoQueueId;
            uint8 zAccountUtxoIndexInQueue;
            (
                zAccountUtxoQueueId,
                zAccountUtxoIndexInQueue,
                utxoBusQueuePos
            ) = PANTHER_TREES.insertPrpClaimUtxo(
                inputs,
                transactionOptions,
                miningReward
            );

            _emitPrpAccountingNote(
                inputs,
                zAccountUtxoQueueId,
                zAccountUtxoIndexInQueue,
                privateMessages
            );

            emit RewardClaimed(secretHash);
        }
    }

    /**
     * @dev Validates non-zero public inputs to ensure correctness in the UTXO commitment process.
     * @param inputs The public input parameters.
     */

    function _checkNonZeroPublicInputs(uint256[] calldata inputs) private pure {
        inputs[PRP_ACCOUNTING_ZACCOUNT_UTXO_OUT_COMMITMENT_IND].validateNonZero(
            ERR_ZERO_ZACCOUNT_COMMIT
        );
    }

    /**
     * @notice Validates extra inputs
     * @dev Checks the provided inputs against their expected hash to ensure data integrity.
     * @param extraInputsHash The hash of the public parameters.
     * @param transactionOptions Transaction options in the form of a 17-bit number.
     * @param paymasterCompensation Compensation for the paymaster.
     * @param privateMessages Private messages containing UTXO data.
     */
    function _validateExtraInputs(
        uint256 extraInputsHash,
        uint32 transactionOptions,
        uint96 paymasterCompensation,
        bytes memory privateMessages
    ) private pure {
        bytes memory extraInp = abi.encodePacked(
            transactionOptions,
            paymasterCompensation,
            privateMessages
        );
        extraInputsHash.validateExtraInputHash(extraInp);
    }
}
