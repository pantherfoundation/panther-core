// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2024 Panther Ventures Limited Gibraltar
// solhint-disable one-contract-per-file
pragma solidity 0.8.19;

import "../interfaces/IPrpVoucherController.sol";

import "../storage/AppStorage.sol";
import "../storage/PrpVoucherControllerStorageGap.sol";

import "../../diamond/utils/Ownable.sol";
import "../../verifier/Verifier.sol";

import "./prpVoucherController/PrpVoucherHandler.sol";
import "../utils/TransactionNoteEmitter.sol";
import "../utils/TransactionChargesHandler.sol";

import "../libraries/UtxosInserter.sol";
import "../libraries/NullifierSpender.sol";
import "../libraries/PublicInputGuard.sol";

/// @title PrpVoucherGrantor
/// @notice The PRPGrantor smart contract is designed to facilitate rewarding
/// users with Panther Protocol rewards (nominated in PRPs) other than rewards
/// generated by/within MASP transactions. Reward claims to be generated and
/// utilised by users. The contract maintains a mapping of claimable PRP
/// balances  associated with individual secrets. It accumulates generated
/// claims associated with the same secret. A claim “utilisation” results in
/// increasing the PRP balance inside the zAccount of a user by the amount
/// of the claim. To utilise a claim (it’s entire balance) associated with a
/// secret, a user must provide proof of zAccount ownership and knowledge of
/// the secret. The contract owner has the authority to update the terms, and
/// the smart contract is upgradable to extend the action list as needed upon
/// DAO voting.
contract PrpVoucherController is
    AppStorage,
    PrpVoucherControllerStorageGap,
    Ownable,
    Verifier,
    PrpVoucherHandler,
    TransactionNoteEmitter,
    TransactionChargesHandler,
    IPrpVoucherController
{
    using UtilsLib for uint256;
    using PublicInputGuard for uint256;
    using PublicInputGuard for address;
    using TransactionOptions for uint32;
    using UtxosInserter for address;
    using NullifierSpender for mapping(bytes32 => uint256);

    address public immutable PANTHER_TREES;

    event RewardVoucherGenerated(bytes32 indexed secretHash, uint256 prpAmount);
    event RewardAccounted(bytes32 indexed secretHash);
    event RewardClaimed(bytes32 indexed secretHash);
    event VoucherTermsUpdated(
        address allowedContract,
        bytes4 voucherType,
        uint64 limit,
        uint64 amount
    );

    constructor(
        address pantherTrees,
        address feeMaster,
        address zkpToken
    ) TransactionChargesHandler(feeMaster, zkpToken) {
        PANTHER_TREES = pantherTrees;
    }

    modifier onlyValidVoucherTypes(bytes4 _voucherType) {
        require(
            voucherTerms[msg.sender][_voucherType].enabled,
            "PrpVoucherGrantor: Inactive or invalid voucher type"
        );
        _;
    }

    /// @notice Generates a reward voucher for a given secret hash and voucher
    /// type.
    /// @param _secretHash The secret hash for the reward voucher.
    /// @param _amount The amount of the reward voucher.
    /// @param _voucherType The type of the reward voucher.
    /// @return _prpToGrant The prp amount which has be granted.
    function generateRewards(
        bytes32 _secretHash,
        uint64 _amount,
        bytes4 _voucherType
    )
        external
        onlyValidVoucherTypes(_voucherType)
        returns (uint256 _prpToGrant)
    {
        _prpToGrant = _generateRewards(_secretHash, _amount, _voucherType);

        emit RewardVoucherGenerated(_secretHash, _prpToGrant);
    }

    /// @notice Sets the terms for action rewards for a given voucher type.
    /// @param _allowedContract The address of the contract allowed to generate
    /// reward vouchers.
    /// @param _voucherType The type of the reward voucher.
    /// @param _limit The limit for the voucher grants.
    /// @param _amount The amount of PRP to grant for the voucher.
    /// @param _enabled The status of the voucher type.
    function updateVoucherTerms(
        address _allowedContract,
        bytes4 _voucherType,
        uint64 _limit,
        uint64 _amount,
        bool _enabled
    ) external onlyOwner {
        _updateVoucherTerms(
            _allowedContract,
            _voucherType,
            _limit,
            _amount,
            _enabled
        );

        emit VoucherTermsUpdated(
            _allowedContract,
            _voucherType,
            _limit,
            _amount
        );
    }

    /// @param inputs The public input parameters to be passed to verifier
    /// (refer to MainPublicSignals.sol).
    /// @param privateMessages the private message that contains zAccount utxo data.
    /// zAccount utxo data contains bytes1 msgType, bytes32 ephemeralKey and bytes64 cypherText
    /// This data is used to spend the newly created utxo.
    /// @param proof A proof associated with the zAccount and a secret.
    /// @param transactionOptions A 17-bits number. The 8 LSB (bits at position 1 to
    /// position 8) defines the cachedForestRootIndex and the 1 MSB (bit at position 17) enables/disables
    /// the taxi tree. Other bits are reserved.
    function accountRewards(
        uint256[] calldata inputs,
        SnarkProof calldata proof,
        uint32 transactionOptions,
        uint96 paymasterCompensation,
        bytes calldata privateMessages
    ) external returns (uint256 utxoBusQueuePos) {
        _validateExtraInputs(
            inputs[PRP_ACCOUNTING_EXTRA_INPUT_HASH_IND],
            transactionOptions,
            paymasterCompensation,
            privateMessages
        );

        _checkNonZeroPublicInputs(inputs);

        {
            uint256 creationTime = inputs[
                PRP_ACCOUNTING_UTXO_OUT_CREATE_TIME_IND
            ];

            creationTime.validateCreationTime(maxBlockTimeOffset);

            uint256 zNetworkChainId = inputs[
                PRP_ACCOUNTING_ZNETWORK_CHAIN_ID_IND
            ];

            zNetworkChainId.validateChainId();
        }

        _sanitizePrivateMessage(privateMessages, TT_PRP_ACCOUNTING);

        isSpent.validateAndSpendNullifier(
            inputs[PRP_ACCOUNTING_ZACCOUNT_UTXO_IN_NULLIFIER_IND]
        );

        bytes32 secretHash = _claimRewards(inputs);

        {
            uint160 circuitId = circuitIds[TT_PRP_ACCOUNTING];
            verifyOrRevert(circuitId, inputs, proof);
        }

        {
            uint96 miningReward = accountFeesAndReturnMiningReward(
                feeMasterDebt,
                inputs,
                paymasterCompensation,
                TT_PRP_ACCOUNTING
            );

            uint32 zAccountUtxoQueueId;
            uint8 zAccountUtxoIndexInQueue;
            (
                zAccountUtxoQueueId,
                zAccountUtxoIndexInQueue,
                utxoBusQueuePos
            ) = PANTHER_TREES.insertPrpClaimUtxo(
                inputs,
                transactionOptions,
                miningReward
            );

            _emitPrpAccountingNote(
                inputs,
                zAccountUtxoQueueId,
                zAccountUtxoIndexInQueue,
                privateMessages
            );

            emit RewardClaimed(secretHash);
        }
    }

    function _checkNonZeroPublicInputs(uint256[] calldata inputs) private pure {
        inputs[PRP_ACCOUNTING_ZACCOUNT_UTXO_OUT_COMMITMENT_IND].validateNonZero(
            ERR_ZERO_ZACCOUNT_COMMIT
        );
    }

    function _validateExtraInputs(
        uint256 extraInputsHash,
        uint32 transactionOptions,
        uint96 paymasterCompensation,
        bytes memory privateMessages
    ) private pure {
        bytes memory extraInp = abi.encodePacked(
            transactionOptions,
            paymasterCompensation,
            privateMessages
        );
        extraInputsHash.validateExtraInputHash(extraInp);
    }
}
