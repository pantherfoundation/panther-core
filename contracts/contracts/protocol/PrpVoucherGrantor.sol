// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// solhint-disable one-contract-per-file
pragma solidity 0.8.16;

import "../common/ImmutableOwnable.sol";
import "../common/Utils.sol";

// TODO: Remove this interface once the pool contract is updated.
interface PoolContract {
    function increasePRPBalance(uint256 amount, bytes calldata proof) external;
}

/// @title PrpVoucherGrantor
/// @notice The PRPGrantor smart contract is designed to facilitate rewarding
/// users with Panther Protocol rewards (nominated in PRPs) other than rewards
/// generated by/within MASP transactions. Reward claims to be generated and
/// utilised by users. The contract maintains a mapping of claimable PRP
/// balances  associated with individual secrets. It accumulates generated
/// claims associated with the same secret. A claim “utilisation” results in
/// increasing the PRP balance inside the zAccount of a user by the amount
/// of the claim. To utilise a claim (it’s entire balance) associated with a
/// secret, a user must provide proof of zAccount ownership and knowledge of
/// the secret. The contract owner has the authority to update the terms, and
/// the smart contract is upgradable to extend the action list as needed upon
/// DAO voting.
contract PrpVoucherGrantor is ImmutableOwnable, Utils {
    // The contract is supposed to run behind a proxy DELEGATECALLing it.
    // On upgrades, adjust `__gap` to match changes of the storage layout.
    // slither-disable-next-line unused-state
    uint256[50] private __gap;

    // solhint-disable-next-line
    PoolContract public immutable POOL_CONTRACT;
    // solhint-disable-next-line
    uint64 private ZERO_VALUE = 1;

    mapping(bytes32 => uint256) public balance;
    mapping(address => mapping(bytes4 => VoucherTerms)) public voucherTerms;

    /// @dev Struct for storing voucher terms.

    /// @param rewardsGranted The total amount (accumulator) of rewards granted
    /// for this voucher
    /// @param limit The rewards limit of the reward voucher. rewardsGranted <=
    //limit
    /// @param amount The amount of the reward that voucher generates.
    /// @param enabled The status of the voucher terms.
    struct VoucherTerms {
        uint64 rewardsGranted;
        uint64 limit;
        uint64 amount;
        bool enabled;
        // rest of the storage slot (uint120) are available for upgrades
        uint56 _reserved;
    }

    /// @dev Emitted when a new reward voucher is generated.
    /// @param secretHash The secret hash for the reward voucher.
    event RewardVoucherGenerated(bytes32 indexed secretHash, uint256 prpAmount);

    /// @dev Emitted when a reward voucher is successfully claimed.
    /// @param secretHash The secret hash for the claimed reward voucher.
    event RewardClaimed(bytes32 indexed secretHash);

    /// @dev Emitted when the voucher terms are updated.
    /// @param allowedContract The address of the contract allowed to generate
    /// reward vouchers.
    /// @param voucherType The type of the reward voucher.
    /// @param limit The limit of the reward voucher.
    /// @param amount The amount of the reward voucher.
    event VoucherTermsUpdated(
        address allowedContract,
        bytes4 voucherType,
        uint64 limit,
        uint64 amount
    );

    /// @notice Constructor that sets the initial owner, pool contract and
    /// verifier contract.
    /// @param _owner The owner of the PrpVoucherGrantor contract.
    /// @param _poolContract The address of the pool contract.
    constructor(address _owner, address _poolContract)
        ImmutableOwnable(_owner)
    {
        revertZeroAddress(_poolContract);
        POOL_CONTRACT = PoolContract(_poolContract);
    }

    modifier onlyValidVoucherTypes(bytes4 _voucherType) {
        require(
            voucherTerms[msg.sender][_voucherType].enabled,
            "PrpVoucherGrantor: Inactive or invalid voucher type"
        );
        _;
    }

    /// @notice Generates a reward voucher for a given secret hash and voucher
    /// type.
    /// @param _secretHash The secret hash for the reward voucher.
    /// @param _amount The amount of the reward voucher.
    /// @param _voucherType The type of the reward voucher.
    /// @return The prp amount which has be granted.
    function generateRewards(
        bytes32 _secretHash,
        uint64 _amount,
        bytes4 _voucherType
    ) external onlyValidVoucherTypes(_voucherType) returns (uint256) {
        VoucherTerms memory voucherTerm = voucherTerms[msg.sender][
            _voucherType
        ];

        // If amount in the voucher is not set, then the amount is specified
        // by the calling smart contract, otherwise it is specified by the
        uint64 prpToGrant = _amount > 0 ? _amount : voucherTerm.amount;

        if (voucherTerm.rewardsGranted + prpToGrant > voucherTerm.limit)
            return 0;

        // we are setting the balance to non-zero to save gas
        if (balance[_secretHash] > ZERO_VALUE) {
            balance[_secretHash] += prpToGrant;
        } else {
            balance[_secretHash] = ZERO_VALUE + prpToGrant;
        }

        voucherTerms[msg.sender][_voucherType].rewardsGranted += prpToGrant;

        emit RewardVoucherGenerated(_secretHash, prpToGrant);

        return prpToGrant;
    }

    /// @notice Claims a rewards collected for the given secret hash.
    /// @param secretHash The secret hash for the reward voucher.
    /// @param proof A proof associated with the zAccount and a secret.
    function claimRewards(
        bytes32 secretHash,
        // solhint-disable-next-line
        bytes calldata proof
    ) external {
        uint256 rewardAmount = balance[secretHash];
        require(
            rewardAmount > ZERO_VALUE,
            "PrpVoucherGrantor: No reward to claim"
        );

        // we are setting the balance to non-zero to save gas for the next
        // rearward generation
        balance[secretHash] = ZERO_VALUE;

        // TODO: implement the rest of the logic in the Pool contract
        // POOL_CONTRACT.increasePRPBalance(
        //     rewardAmount,
        //     secretHash,
        //     _secretAndzAccountProof
        //     // zAccountTree root
        //     // commitmentHash
        //     // newZAccountUTXOCommitment
        //     // and a couple of other things
        // );
        emit RewardClaimed(secretHash);
    }

    /// @notice Sets the terms for action rewards for a given voucher type.
    /// @param _allowedContract The address of the contract allowed to generate
    /// reward vouchers.
    /// @param _voucherType The type of the reward voucher.
    /// @param _limit The limit for the voucher grants.
    /// @param _amount The amount of PRP to grant for the voucher.
    /// @param _enabled The status of the voucher type.
    function updateVoucherTerms(
        address _allowedContract,
        bytes4 _voucherType,
        uint64 _limit,
        uint64 _amount,
        bool _enabled
    ) external onlyOwner {
        revertZeroAddress(_allowedContract);
        uint64 rewardsGenerated = voucherTerms[_allowedContract][_voucherType]
            .rewardsGranted;

        require(
            _limit + _amount >= rewardsGenerated,
            "PrpVoucherGrantor: Limit cannot be less than rewards generated"
        );

        voucherTerms[_allowedContract][_voucherType] = VoucherTerms(
            rewardsGenerated,
            _limit,
            _amount,
            _enabled,
            uint56(0) // reserved
        );
        emit VoucherTermsUpdated(
            _allowedContract,
            _voucherType,
            _limit,
            _amount
        );
    }
}
