// SPDX-License-Identifier: BUSL-1.1
// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar
// solhint-disable one-contract-per-file
pragma solidity 0.8.16;

import "./interfaces/IPantherPoolV1.sol";
import { FIELD_SIZE } from "./crypto/SnarkConstants.sol";

import "../common/ImmutableOwnable.sol";
import "../common/Utils.sol";

/// @title PrpVoucherGrantor
/// @notice The PRPGrantor smart contract is designed to facilitate rewarding
/// users with Panther Protocol rewards (nominated in PRPs) other than rewards
/// generated by/within MASP transactions. Reward claims to be generated and
/// utilised by users. The contract maintains a mapping of claimable PRP
/// balances  associated with individual secrets. It accumulates generated
/// claims associated with the same secret. A claim “utilisation” results in
/// increasing the PRP balance inside the zAccount of a user by the amount
/// of the claim. To utilise a claim (it’s entire balance) associated with a
/// secret, a user must provide proof of zAccount ownership and knowledge of
/// the secret. The contract owner has the authority to update the terms, and
/// the smart contract is upgradable to extend the action list as needed upon
/// DAO voting.
contract PrpVoucherGrantor is ImmutableOwnable, Utils {
    // The contract is supposed to run behind a proxy DELEGATECALLing it.
    // On upgrades, adjust `__gap` to match changes of the storage layout.
    // slither-disable-next-line unused-state
    uint256[50] private __gap;

    // solhint-disable-next-line
    IPantherPoolV1 public immutable PANTHER_POOL_V1;
    // solhint-disable-next-line
    uint64 private ZERO_VALUE = 1;

    mapping(bytes32 => uint256) public balance;
    mapping(address => mapping(bytes4 => VoucherTerms)) public voucherTerms;

    /// @dev Struct for storing voucher terms.

    /// @param rewardsGranted The total amount (accumulator) of rewards granted
    /// for this voucher
    /// @param limit The rewards limit of the reward voucher. rewardsGranted <=
    //limit
    /// @param amount The amount of the reward that voucher generates.
    /// @param enabled The status of the voucher terms.
    struct VoucherTerms {
        uint64 rewardsGranted;
        uint64 limit;
        uint64 amount;
        bool enabled;
        // rest of the storage slot (uint120) are available for upgrades
        uint56 _reserved;
    }

    /// @dev Emitted when a new reward voucher is generated.
    /// @param secretHash The secret hash for the reward voucher.
    event RewardVoucherGenerated(bytes32 indexed secretHash, uint256 prpAmount);

    /// @dev Emitted when a reward voucher is successfully claimed.
    /// @param secretHash The secret hash for the claimed reward voucher.
    event RewardClaimed(bytes32 indexed secretHash);

    /// @dev Emitted when the voucher terms are updated.
    /// @param allowedContract The address of the contract allowed to generate
    /// reward vouchers.
    /// @param voucherType The type of the reward voucher.
    /// @param limit The limit of the reward voucher.
    /// @param amount The amount of the reward voucher.
    event VoucherTermsUpdated(
        address allowedContract,
        bytes4 voucherType,
        uint64 limit,
        uint64 amount
    );

    /// @notice Constructor that sets the initial owner, pool contract and
    /// verifier contract.
    /// @param _owner The owner of the PrpVoucherGrantor contract.
    /// @param _pantherPoolV1 The address of the pool contract.
    constructor(
        address _owner,
        address _pantherPoolV1
    ) ImmutableOwnable(_owner) {
        revertZeroAddress(_pantherPoolV1);
        PANTHER_POOL_V1 = IPantherPoolV1(_pantherPoolV1);
    }

    modifier onlyValidVoucherTypes(bytes4 _voucherType) {
        require(
            voucherTerms[msg.sender][_voucherType].enabled,
            "PrpVoucherGrantor: Inactive or invalid voucher type"
        );
        _;
    }

    /// @notice Generates a reward voucher for a given secret hash and voucher
    /// type.
    /// @param _secretHash The secret hash for the reward voucher.
    /// @param _amount The amount of the reward voucher.
    /// @param _voucherType The type of the reward voucher.
    /// @return The prp amount which has be granted.
    function generateRewards(
        bytes32 _secretHash,
        uint64 _amount,
        bytes4 _voucherType
    ) external onlyValidVoucherTypes(_voucherType) returns (uint256) {
        VoucherTerms memory voucherTerm = voucherTerms[msg.sender][
            _voucherType
        ];

        // If amount in the voucher is not set, then the amount is specified
        // by the calling smart contract, otherwise it is specified by the
        uint64 prpToGrant = _amount > 0 ? _amount : voucherTerm.amount;

        if (voucherTerm.rewardsGranted + prpToGrant > voucherTerm.limit)
            return 0;

        // we are setting the balance to non-zero to save gas
        if (balance[_secretHash] > ZERO_VALUE) {
            balance[_secretHash] += prpToGrant;
        } else {
            balance[_secretHash] = ZERO_VALUE + prpToGrant;
        }

        voucherTerms[msg.sender][_voucherType].rewardsGranted += prpToGrant;

        emit RewardVoucherGenerated(_secretHash, prpToGrant);

        return prpToGrant;
    }

    /// @notice Claims a rewards collected for the given secret hash.
    /// @param inputs The public input parameters to be passed to verifier.
    /// @param proof A proof associated with the zAccount and a secret.
    /// @param inputs[0]  - extraInputsHash;
    /// @param inputs[1]  - chargedAmountZkp;
    /// @param inputs[2]  - createTime;
    /// @param inputs[3]  - depositAmountPrp;
    /// @param inputs[4]  - withdrawAmountPrp;
    /// @param inputs[5]  - utxoCommitmentPrivatePart;
    /// @param inputs[6]  - utxoSpendPubKeyX
    /// @param inputs[7]  - utxoSpendPubKeyY
    /// @param inputs[8]  - zAssetScale;
    /// @param inputs[9]  - zAccountUtxoInNullifier;
    /// @param inputs[10] - zAccountUtxoOutCommitment;
    /// @param inputs[11] - zNetworkChainId;
    /// @param inputs[12] - forestMerkleRoot;
    /// @param inputs[13] - saltHash;
    /// @param inputs[14] - magicalConstraint;
    function claimRewards(
        uint256[] calldata inputs,
        bytes memory privateMessages,
        SnarkProof calldata proof,
        uint256 cachedForestRootIndex
    ) external returns (uint256 utxoBusQueuePos) {
        bytes32 secretHash = bytes32(inputs[13]);
        uint256 rewardAmount = balance[secretHash];
        require(
            rewardAmount > ZERO_VALUE,
            "PrpVoucherGrantor: No reward to claim"
        );

        {
            uint256 extraInputsHash = inputs[0];
            bytes memory extraInp = abi.encodePacked(
                privateMessages,
                cachedForestRootIndex
            );
            require(
                extraInputsHash == uint256(keccak256(extraInp)) % FIELD_SIZE,
                "PrpVoucherGrantor: Invalid extra input hash"
            );
        }

        // we are setting the balance to non-zero to save gas for the next
        // rearward generation
        balance[secretHash] = ZERO_VALUE;

        utxoBusQueuePos = _accountPrp(
            inputs,
            proof,
            privateMessages,
            cachedForestRootIndex
        );

        emit RewardClaimed(secretHash);
    }

    function _accountPrp(
        uint256[] calldata inputs,
        SnarkProof calldata proof,
        bytes memory privateMessages,
        uint256 cachedForestRootIndex
    ) private returns (uint256 utxoBusQueuePos) {
        utxoBusQueuePos = 0;
        // Pool is supposed to revert in case of any error
        try
            // Trusted contract - no reentrancy guard needed
            PANTHER_POOL_V1.accountPrp(
                inputs,
                proof,
                privateMessages,
                cachedForestRootIndex
            )
        returns (uint256 result) {
            utxoBusQueuePos = result;
        } catch Error(string memory reason) {
            revert(reason);
        }
    }

    /// @notice Sets the terms for action rewards for a given voucher type.
    /// @param _allowedContract The address of the contract allowed to generate
    /// reward vouchers.
    /// @param _voucherType The type of the reward voucher.
    /// @param _limit The limit for the voucher grants.
    /// @param _amount The amount of PRP to grant for the voucher.
    /// @param _enabled The status of the voucher type.
    function updateVoucherTerms(
        address _allowedContract,
        bytes4 _voucherType,
        uint64 _limit,
        uint64 _amount,
        bool _enabled
    ) external onlyOwner {
        revertZeroAddress(_allowedContract);
        uint64 rewardsGenerated = voucherTerms[_allowedContract][_voucherType]
            .rewardsGranted;

        require(
            _limit + _amount >= rewardsGenerated,
            "PrpVoucherGrantor: Limit cannot be less than rewards generated"
        );

        voucherTerms[_allowedContract][_voucherType] = VoucherTerms(
            rewardsGenerated,
            _limit,
            _amount,
            _enabled,
            uint56(0) // reserved
        );
        emit VoucherTermsUpdated(
            _allowedContract,
            _voucherType,
            _limit,
            _amount
        );
    }
}
