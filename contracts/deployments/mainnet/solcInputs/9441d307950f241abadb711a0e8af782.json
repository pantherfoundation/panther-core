{
  "language": "Solidity",
  "sources": {
    "contracts/actions/RewardAdvisersList.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IRewardAdviser.sol\";\n\n/**\n * @title ActionControllers\n * @notice It maintains a list of \"ActionOracle\" and \"RewardAdviser\" instances.\n * For a tuple of ActionOracle address and action type, an RewardAdviser\n * instance of  may be mapped.\n */\nabstract contract RewardAdvisersList {\n    /// @dev Emitted when RewardAdviser added, updated, or removed\n    event AdviserUpdated(\n        address indexed oracle,\n        bytes4 indexed action,\n        address adviser\n    );\n\n    /// @dev mapping from ActionOracle and (type of) action to ActionController\n    mapping(address => mapping(bytes4 => address)) public rewardAdvisers;\n\n    function _addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) internal {\n        require(\n            oracle != address(0) &&\n                adviser != address(0) &&\n                action != bytes4(0),\n            \"ACM:E1\"\n        );\n        require(rewardAdvisers[oracle][action] == address(0), \"ACM:E2\");\n        rewardAdvisers[oracle][action] = adviser;\n        emit AdviserUpdated(oracle, action, adviser);\n    }\n\n    function _removeRewardAdviser(address oracle, bytes4 action) internal {\n        require(rewardAdvisers[oracle][action] != address(0), \"ACM:E3\");\n        rewardAdvisers[oracle][action] = address(0);\n        emit AdviserUpdated(oracle, action, address(0));\n    }\n\n    function _getRewardAdviserOrRevert(address oracle, bytes4 action)\n        internal\n        view\n        returns (IRewardAdviser)\n    {\n        address adviser = rewardAdvisers[oracle][action];\n        require(adviser != address(0), \"ACM:E4\");\n        return IRewardAdviser(adviser);\n    }\n}\n"
    },
    "contracts/interfaces/IRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRewardAdviser {\n    struct Advice {\n        // advice on new \"shares\" (in the reward pool) to create\n        address createSharesFor;\n        uint96 sharesToCreate;\n        // advice on \"shares\" to redeem\n        address redeemSharesFrom;\n        uint96 sharesToRedeem;\n        // advice on address the reward against redeemed shares to send to\n        address sendRewardTo;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        returns (Advice memory);\n}\n"
    },
    "contracts/RewardMaster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/RewardAdvisersList.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./interfaces/IRewardPool.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/NonReentrant.sol\";\nimport \"./utils/Utils.sol\";\n\n/***\n * @title RewardMaster\n * @notice It accounts rewards and distributes reward tokens to users.\n * @dev It withdraws the reward token from (or via) the \"REWARD_POOL\" contract,\n * and keeps tokens, aka \"Treasury\", on its balance until distribution.\n * It issues to users \"shares\" in the Treasury, or redeems shares, paying out\n * tokens from the Treasury to users, or on behalf of users, as follows.\n * It receives messages (calls) on \"actions\" to be rewarded from authorized\n * \"ActionOracle\" contracts.\n * On every \"action\" message received, it calls a \"RewardAdviser\" contract,\n * assigned for that ActionOracle and action type, which advices on how many\n * shares shall be created and to whom, or whose shares must be redeemed, and\n * where reward tokens shall be sent to.\n * The owner may add or remove addresses of ActionOracle`s and RewardAdviser`s.\n */\ncontract RewardMaster is\n    ImmutableOwnable,\n    Utils,\n    Claimable,\n    NonReentrant,\n    RewardAdvisersList,\n    IActionMsgReceiver\n{\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Token rewards are given in\n    address public immutable REWARD_TOKEN;\n\n    /// @notice RewardPool instance that vests the reward token\n    address public immutable REWARD_POOL;\n\n    /// @dev Block the contract deployed in\n    uint256 public immutable START_BLOCK;\n\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * At any time, the amount of the reward token a user is entitled to is:\n     *   tokenAmountEntitled = accumRewardPerShare * user.shares - user.offset\n     *\n     * This formula works since we update parameters as follows ...\n     *\n     * - when a new reward token amount added to the Treasury:\n     *   accumRewardPerShare += tokenAmountAdded / totalShares\n     *\n     * - when new shares granted to a user:\n     *   user.offset += sharesToCreate * accumRewardPerShare\n     *   user.shares += sharesToCreate\n     *   totalShares += sharesToCreate\n     *\n     * - when shares redeemed to a user:\n     *   redemptionRate = accumRewardPerShare - user.offset/user.shares\n     *   user.offset -= user.offset/user.shares * sharesToRedeem\n     *   user.shares -= sharesToRedeem\n     *   totalShares -= sharesToRedeem\n     *   tokenAmountPayable = redemptionRate * sharesToRedeem\n     *\n     * (Scaling omitted in formulas above for clarity.)\n     */\n\n    /// @dev Block when reward tokens were last time were vested in\n    uint32 public lastVestedBlock;\n    /// @dev Reward token balance (aka Treasury) after last vesting\n    /// (token total supply is supposed to not exceed 2**96)\n    uint96 public lastBalance;\n\n    /// @notice Total number of unredeemed shares\n    /// (it is supposed to not exceed 2**128)\n    uint128 public totalShares;\n    /// @dev Min number of unredeemed shares being rewarded\n    uint256 private constant MIN_SHARES_REWARDED = 1000;\n    /// @dev Min number of blocks between vesting in the Treasury\n    uint256 private constant MIN_VESTING_BLOCKS = 300;\n\n    // see comments above for explanation\n    uint256 public accumRewardPerShare;\n    // `accumRewardPerShare` is scaled (up) with this factor\n    uint256 private constant SCALE = 1e9;\n\n    // see comments above for explanation\n    struct UserRecord {\n        // (limited to 2**96)\n        uint96 shares;\n        uint160 offset;\n    }\n\n    // Mapping from user address to UserRecord data\n    mapping(address => UserRecord) public records;\n\n    /// @dev Emitted when new shares granted to a user\n    event SharesGranted(address indexed user, uint256 amount);\n    /// @dev Emitted when shares of a user redeemed\n    event SharesRedeemed(address indexed user, uint256 amount);\n    /// @dev Emitted when new reward token amount vested to this contract\n    event RewardAdded(uint256 reward);\n    /// @dev Emitted when reward token amount paid to/for a user\n    event RewardPaid(address indexed user, uint256 reward);\n    /// @dev Emitted when the Treasury counts for \"extra\" reward tokens.\n    /// \"Extra\" tokens are ones sent to this contract directly (rather than\n    /// vested via the REWARD_POOL).\n    event BalanceAdjusted(uint256 adjustment);\n\n    constructor(\n        address _rewardToken,\n        address _rewardPool,\n        address _owner\n    ) ImmutableOwnable(_owner) {\n        require(\n            _rewardToken != address(0) && _rewardPool != address(0),\n            \"RM:C1\"\n        );\n\n        REWARD_TOKEN = _rewardToken;\n        REWARD_POOL = _rewardPool;\n        START_BLOCK = blockNow();\n    }\n\n    /// @notice Returns reward token amount entitled to the given user/account\n    // This amount the account would get if shares would be redeemed now\n    function entitled(address account) public view returns (uint256 reward) {\n        UserRecord memory rec = records[account];\n        if (rec.shares == 0) return 0;\n\n        // no reentrancy guard needed for the known contract call\n        uint256 releasable = IRewardPool(REWARD_POOL).releasableAmount();\n        uint256 _accumRewardPerShare = accumRewardPerShare;\n        uint256 _totalShares = uint256(totalShares);\n        if (releasable != 0 && _totalShares >= MIN_SHARES_REWARDED) {\n            _accumRewardPerShare += (releasable * SCALE) / _totalShares;\n        }\n\n        (reward, , ) = _computeRedemption(\n            uint256(rec.shares),\n            rec,\n            _accumRewardPerShare\n        );\n    }\n\n    function onAction(bytes4 action, bytes memory message) external override {\n        IRewardAdviser adviser = _getRewardAdviserOrRevert(msg.sender, action);\n        // no reentrancy guard needed for the known contract call\n        IRewardAdviser.Advice memory advice = adviser.getRewardAdvice(\n            action,\n            message\n        );\n        if (advice.sharesToCreate > 0) {\n            _grantShares(advice.createSharesFor, advice.sharesToCreate);\n        }\n        if (advice.sharesToRedeem > 0) {\n            _redeemShares(\n                advice.redeemSharesFrom,\n                advice.sharesToRedeem,\n                advice.sendRewardTo\n            );\n        }\n    }\n\n    function triggerVesting() external {\n        _triggerVesting(true, false);\n    }\n\n    /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    /**\n     * @notice Adds the \"RewardAdviser\" for given ActionOracle and action type\n     * @dev May be only called by the {OWNER}\n     * !!!!! Before adding a new \"adviser\", ensure \"shares\" it \"advices\" can not\n     * overflow `UserRecord.shares`, `UserRecord.offset` and `totalShares`.\n     */\n    function addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) external onlyOwner {\n        _addRewardAdviser(oracle, action, adviser);\n    }\n\n    /// @notice Remove \"RewardAdviser\" for given ActionOracle and action type\n    /// @dev May be only called by the {OWNER}\n    function removeRewardAdviser(address oracle, bytes4 action)\n        external\n        onlyOwner\n    {\n        _removeRewardAdviser(oracle, action);\n    }\n\n    /// @notice Withdraws accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function claimErc20(\n        address claimedToken,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        if (claimedToken == address(REWARD_TOKEN)) {\n            // Not allowed if unclaimed shares remain\n            require(totalShares == 0, \"RM: Failed to claim\");\n        }\n        _claimErc20(claimedToken, to, amount);\n    }\n\n    /* ========== INTERNAL & PRIVATE FUNCTIONS ========== */\n\n    function _computeRedemption(\n        uint256 sharesToRedeem,\n        UserRecord memory rec,\n        uint256 _accumRewardPerShare\n    )\n        internal\n        pure\n        returns (\n            uint256 reward,\n            uint256 newShares,\n            uint256 newOffset\n        )\n    {\n        // `rec.shares` and `sharesToRedeem` are assumed to be non-zero here,\n        // and `sharesToRedeem` does not exceed `rec.shares`\n        newShares = uint256(rec.shares) - sharesToRedeem;\n\n        uint256 offsetRedeemed = newShares == 0\n            ? uint256(rec.offset)\n            : (uint256(rec.offset) * sharesToRedeem) / uint256(rec.shares);\n        newOffset = uint256(rec.offset) - offsetRedeemed;\n\n        reward = 0;\n        if (_accumRewardPerShare != 0) {\n            reward = (sharesToRedeem * _accumRewardPerShare) / SCALE;\n            // avoid eventual overflow resulted from rounding\n            reward -= reward >= offsetRedeemed ? offsetRedeemed : reward;\n        }\n    }\n\n    function _grantShares(address to, uint256 shares)\n        internal\n        nonZeroAmount(shares)\n        nonZeroAddress(to)\n    {\n        (uint256 _accumRewardPerShare, , ) = _triggerVesting(true, true);\n\n        UserRecord memory rec = records[to];\n        uint256 newOffset = uint256(rec.offset) +\n            (shares * _accumRewardPerShare) /\n            SCALE;\n        uint256 newShares = uint256(rec.shares) + shares;\n\n        records[to] = UserRecord(safe96(newShares), safe160(newOffset));\n        totalShares = safe128(uint256(totalShares) + shares);\n\n        emit SharesGranted(to, shares);\n    }\n\n    function _redeemShares(\n        address from,\n        // `shares` assumed to be non-zero\n        uint256 shares,\n        address to\n    ) internal nonZeroAmount(shares) nonZeroAddress(from) nonZeroAddress(to) {\n        UserRecord memory rec = records[from];\n        require(rec.shares >= shares, \"RM: Not enough shares to redeem\");\n\n        (\n            uint256 _accumRewardPerShare,\n            uint256 newBalance,\n            uint256 oldBalance\n        ) = _triggerVesting(false, true);\n\n        (\n            uint256 reward,\n            uint256 newShares,\n            uint256 newOffset\n        ) = _computeRedemption(shares, rec, _accumRewardPerShare);\n\n        records[from] = UserRecord(safe96(newShares), safe160(newOffset));\n        totalShares = safe128(uint256(totalShares) - shares);\n\n        uint256 _lastBalance = newBalance - reward;\n        if (oldBalance != _lastBalance) {\n            lastBalance = safe96(_lastBalance);\n        }\n\n        if (reward != 0) {\n            // known contract - nether reentrancy guard nor safeTransfer required\n            require(\n                IErc20Min(REWARD_TOKEN).transfer(to, reward),\n                \"RM: Internal transfer failed\"\n            );\n            emit RewardPaid(to, reward);\n        }\n\n        emit SharesRedeemed(from, shares);\n    }\n\n    function _triggerVesting(\n        bool isLastBalanceToBeUpdated,\n        bool isMinVestingBlocksApplied\n    )\n        internal\n        returns (\n            uint256 newAccumRewardPerShare,\n            uint256 newBalance,\n            uint256 oldBalance\n        )\n    {\n        uint32 _blockNow = safe32BlockNow();\n        newAccumRewardPerShare = accumRewardPerShare;\n        oldBalance = uint256(lastBalance);\n        uint256 _totalShares = totalShares;\n\n        uint32 blocksPast = _blockNow - lastVestedBlock;\n        if (\n            (blocksPast == 0) ||\n            (isMinVestingBlocksApplied && blocksPast < MIN_VESTING_BLOCKS) ||\n            _totalShares < MIN_SHARES_REWARDED\n        ) {\n            // Do not request vesting from the REWARD_POOL\n            return (newAccumRewardPerShare, oldBalance, oldBalance);\n        }\n\n        // known contracts, no reentrancy guard needed\n        uint256 newlyVested = IRewardPool(REWARD_POOL).vestRewards();\n        newBalance = IErc20Min(REWARD_TOKEN).balanceOf(address(this));\n\n        uint256 expectedBalance = oldBalance + newlyVested;\n        if (newBalance > expectedBalance) {\n            // somebody transferred tokens to this contract directly\n            uint256 adjustment = newBalance - expectedBalance;\n            newlyVested += adjustment;\n            emit BalanceAdjusted(adjustment);\n        }\n        if (newlyVested != 0) {\n            newAccumRewardPerShare += (newlyVested * SCALE) / _totalShares;\n            accumRewardPerShare = newAccumRewardPerShare;\n            emit RewardAdded(newlyVested);\n        }\n        lastVestedBlock = _blockNow;\n        if (isLastBalanceToBeUpdated && (oldBalance != newBalance)) {\n            lastBalance = safe96(newBalance);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier nonZeroAmount(uint256 amount) {\n        require(amount > 0, \"RM: Zero amount provided\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"RM: Zero address provided\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IActionMsgReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IActionMsgReceiver {\n    function onAction(bytes4 action, bytes memory message) external;\n}\n"
    },
    "contracts/interfaces/IErc20Min.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IErc20Min {\n    /// @dev ERC-20 `balanceOf`\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @dev ERC-20 `transfer`\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /// @dev ERC-20 `transferFrom`\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @dev EIP-2612 `permit`\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.0;\n\ninterface IRewardPool {\n    /// @notice Returns token amount that may be released (vested) now\n    function releasableAmount() external view returns (uint256);\n\n    /// @notice Vests releasable token amount to the {recipient}\n    /// @dev {recipient} only may call\n    function vestRewards() external returns (uint256 amount);\n\n    /// @notice Emitted on vesting to the {recipient}\n    event Vested(uint256 amount);\n\n    /// @notice Emitted on parameters initialized.\n    event Initialized(uint256 _poolId, address _recipient, uint256 _endTime);\n}\n"
    },
    "contracts/utils/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/utils/Claimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/**\n * @title Claimable\n * @notice It withdraws accidentally sent tokens from this contract.\n */\ncontract Claimable {\n    bytes4 private constant SELECTOR_TRANSFER =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    function _claimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"claimErc20: TRANSFER_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/utils/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/**\n * @title NonReentrant\n * @notice It provides reentrancy guard.\n * The code borrowed from openzeppelin-contracts.\n * Unlike original, this version requires neither `constructor` no `init` call.\n */\nabstract contract NonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    modifier nonReentrant() {\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\n        // it does not revert (which is expected behaviour)\n        require(_reentrancyStatus != _ENTERED, \"claimErc20: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/utils/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nabstract contract Utils {\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IStakingTypes.sol\";\nimport \"./interfaces/IVotingPower.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title Staking\n * @notice It lets users stake $ZKP token for governance voting and rewards.\n * @dev At request of smart contracts and off-chain requesters, it computes\n * user \"voting power\" on the basis of tokens users stake.\n * It acts as the \"ActionOracle\" for the \"RewardMaster\": if stake terms presume\n * rewarding, it sends \"messages\" on stakes made and stakes claimed to the\n * \"RewardMaster\" contract which rewards stakers.\n * It supports multiple types of stakes (terms), which the owner may add or\n * remove without contract code upgrades.\n */\ncontract Staking is\n    ImmutableOwnable,\n    Utils,\n    StakingMsgProcessor,\n    IStakingTypes,\n    IVotingPower\n{\n    // solhint-disable var-name-mixedcase\n    /// @notice Staking token\n    IErc20Min public immutable TOKEN;\n\n    /// @dev Block the contract deployed in\n    uint256 public immutable START_BLOCK;\n\n    /// @notice RewardMaster contract instance\n    IActionMsgReceiver public immutable REWARD_MASTER;\n\n    // solhint-enable var-name-mixedcase\n\n    // Scale for min/max limits\n    uint256 private constant SCALE = 1e18;\n\n    /// @notice Total token amount staked\n    /// @dev Staking token is deemed to have max total supply of 1e27\n    uint96 public totalStaked = 0;\n\n    /// @dev Mapping from stake type to terms\n    mapping(bytes4 => Terms) public terms;\n\n    /// @dev Mapping from the staker address to stakes of the staker\n    mapping(address => Stake[]) public stakes;\n\n    // Special address to store global state\n    address private constant GLOBAL_ACCOUNT = address(0);\n\n    /// @dev Voting power integrants for each account\n    // special case: GLOBAL_ACCOUNT for total voting power\n    mapping(address => Power) public power;\n\n    /// @dev Snapshots of each account\n    // special case: GLOBAL_ACCOUNT for global snapshots\n    mapping(address => Snapshot[]) private snapshots;\n\n    /// @dev Emitted on a new stake made\n    event StakeCreated(\n        address indexed account,\n        uint256 indexed stakeID,\n        uint256 amount,\n        bytes4 stakeType,\n        uint256 lockedTill\n    );\n\n    /// @dev Emitted on a stake claimed (i.e. \"unstaked\")\n    event StakeClaimed(address indexed account, uint256 indexed stakeID);\n\n    /// @dev Voting power delegated\n    event Delegation(\n        address indexed owner,\n        address indexed from,\n        address indexed to,\n        uint256 stakeID,\n        uint256 amount\n    );\n\n    /// @dev New terms (for the given stake type) added\n    event TermsAdded(bytes4 stakeType);\n\n    /// @dev Terms (for the given stake type) are disabled\n    event TermsDisabled(bytes4 stakeType);\n\n    /// @dev Call to REWARD_MASTER reverted\n    event RewardMasterRevert(address staker, uint256 stakeID);\n\n    /**\n     * @notice Sets staking token, owner and\n     * @param stakingToken - Address of the {ZKPToken} contract\n     * @param rewardMaster - Address of the {RewardMaster} contract\n     * @param owner - Address of the owner account\n     */\n    constructor(\n        address stakingToken,\n        address rewardMaster,\n        address owner\n    ) ImmutableOwnable(owner) {\n        require(\n            stakingToken != address(0) && rewardMaster != address(0),\n            \"Staking:C1\"\n        );\n        TOKEN = IErc20Min(stakingToken);\n        REWARD_MASTER = IActionMsgReceiver(rewardMaster);\n        START_BLOCK = blockNow();\n    }\n\n    /**\n     * @notice Stakes tokens\n     * @dev This contract should be approve()'d for amount\n     * @param amount - Amount to stake\n     * @param stakeType - Type of the stake\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @return stake ID\n     */\n    function stake(\n        uint256 amount,\n        bytes4 stakeType,\n        bytes calldata data\n    ) public returns (uint256) {\n        return _createStake(msg.sender, amount, stakeType, data);\n    }\n\n    /**\n     * @notice Approves this contract to transfer `amount` tokens from the `msg.sender`\n     * and stakes these tokens. Only the owner of tokens (i.e. the staker) may call.\n     * @dev This contract does not need to be approve()'d in advance - see EIP-2612\n     * @param owner - The owner of tokens being staked (i.e. the `msg.sender`)\n     * @param amount - Amount to stake\n     * @param v - \"v\" param of the signature from `owner` for \"permit\"\n     * @param r - \"r\" param of the signature from `owner` for \"permit\"\n     * @param s - \"s\" param of the signature from `owner` for \"permit\"\n     * @param stakeType - Type of the stake\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @return stake ID\n     */\n    function permitAndStake(\n        address owner,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes4 stakeType,\n        bytes calldata data\n    ) external returns (uint256) {\n        require(owner == msg.sender, \"Staking: owner must be msg.sender\");\n        TOKEN.permit(owner, address(this), amount, deadline, v, r, s);\n        return _createStake(owner, amount, stakeType, data);\n    }\n\n    /**\n     * @notice Claims staked token\n     * @param stakeID - ID of the stake to claim\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @param _isForced - Do not revert if \"RewardMaster\" fails\n     */\n    function unstake(\n        uint256 stakeID,\n        bytes calldata data,\n        bool _isForced\n    ) external stakeExist(msg.sender, stakeID) {\n        Stake memory _stake = stakes[msg.sender][stakeID];\n\n        require(_stake.claimedAt == 0, \"Staking: Stake claimed\");\n        require(_stake.lockedTill < safe32TimeNow(), \"Staking: Stake locked\");\n\n        if (_stake.delegatee != address(0)) {\n            _undelegatePower(_stake.delegatee, msg.sender, _stake.amount);\n        }\n        _removePower(msg.sender, _stake.amount);\n\n        stakes[msg.sender][stakeID].claimedAt = safe32TimeNow();\n\n        totalStaked = safe96(uint256(totalStaked) - uint256(_stake.amount));\n\n        emit StakeClaimed(msg.sender, stakeID);\n\n        // known contract - reentrancy guard and `safeTransfer` unneeded\n        require(\n            TOKEN.transfer(msg.sender, _stake.amount),\n            \"Staking: transfer failed\"\n        );\n\n        Terms memory _terms = terms[_stake.stakeType];\n        if (_terms.isRewarded) {\n            _sendUnstakedMsg(msg.sender, _stake, data, _isForced);\n        }\n    }\n\n    /**\n     * @notice Updates vote delegation\n     * @param stakeID - ID of the stake to delegate votes uber\n     * @param to - address to delegate to\n     */\n    function delegate(uint256 stakeID, address to)\n        public\n        stakeExist(msg.sender, stakeID)\n    {\n        require(\n            to != GLOBAL_ACCOUNT,\n            \"Staking: Can't delegate to GLOBAL_ACCOUNT\"\n        );\n\n        Stake memory s = stakes[msg.sender][stakeID];\n        require(s.claimedAt == 0, \"Staking: Stake claimed\");\n        require(s.delegatee != to, \"Staking: Already delegated\");\n\n        if (s.delegatee == address(0)) {\n            _delegatePower(msg.sender, to, s.amount);\n        } else {\n            if (to == msg.sender) {\n                _undelegatePower(s.delegatee, msg.sender, s.amount);\n            } else {\n                _reDelegatePower(s.delegatee, to, s.amount);\n            }\n        }\n\n        emit Delegation(msg.sender, s.delegatee, to, stakeID, s.amount);\n\n        stakes[msg.sender][stakeID].delegatee = to;\n    }\n\n    /**\n     * @notice Delegates voting power of stake back to self\n     * @param stakeID - ID of the stake to delegate votes back to self\n     */\n    function undelegate(uint256 stakeID) external {\n        delegate(stakeID, msg.sender);\n    }\n\n    /// @notice Returns number of stakes of given _account\n    function stakesNum(address _account) external view returns (uint256) {\n        return stakes[_account].length;\n    }\n\n    /// @notice Returns stakes of given account\n    function accountStakes(address _account)\n        external\n        view\n        returns (Stake[] memory)\n    {\n        Stake[] memory _stakes = stakes[_account];\n        return _stakes;\n    }\n\n    /// @inheritdoc IVotingPower\n    function totalVotingPower() external view override returns (uint256) {\n        Power memory _power = power[GLOBAL_ACCOUNT];\n        return _power.own + _power.delegated;\n    }\n\n    /// @inheritdoc IVotingPower\n    function totalPower() external view override returns (Power memory) {\n        return power[GLOBAL_ACCOUNT];\n    }\n\n    /// @inheritdoc IVotingPower\n    function latestGlobalsSnapshotBlock()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return latestSnapshotBlock(GLOBAL_ACCOUNT);\n    }\n\n    /// @inheritdoc IVotingPower\n    function latestSnapshotBlock(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (snapshots[_account].length == 0) return 0;\n\n        return snapshots[_account][snapshots[_account].length - 1].beforeBlock;\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalsSnapshotLength() external view override returns (uint256) {\n        return snapshots[GLOBAL_ACCOUNT].length;\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshotLength(address _account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return snapshots[_account].length;\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return snapshots[GLOBAL_ACCOUNT][_index];\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return snapshots[_account][_index];\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return _snapshotAt(GLOBAL_ACCOUNT, blockNum, hint);\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view override returns (Snapshot memory) {\n        return _snapshotAt(_account, blockNum, hint);\n    }\n\n    /// Only for the owner functions\n\n    /// @notice Adds a new stake type with given terms\n    /// @dev May be only called by the {OWNER}\n    function addTerms(bytes4 stakeType, Terms memory _terms)\n        external\n        onlyOwner\n        nonZeroStakeType(stakeType)\n    {\n        Terms memory existingTerms = terms[stakeType];\n        require(!_isDefinedTerms(existingTerms), \"Staking:E1\");\n        require(_terms.isEnabled, \"Staking:E2\");\n\n        uint256 _now = timeNow();\n\n        if (_terms.allowedTill != 0) {\n            require(_terms.allowedTill > _now, \"Staking:E3\");\n            require(_terms.allowedTill > _terms.allowedSince, \"Staking:E4\");\n        }\n\n        if (_terms.maxAmountScaled != 0) {\n            require(\n                _terms.maxAmountScaled > _terms.minAmountScaled,\n                \"Staking:E5\"\n            );\n        }\n\n        // only one of three \"lock time\" parameters must be non-zero\n        if (_terms.lockedTill != 0) {\n            require(\n                _terms.exactLockPeriod == 0 && _terms.minLockPeriod == 0,\n                \"Staking:E6\"\n            );\n            require(\n                _terms.lockedTill > _now &&\n                    _terms.lockedTill >= _terms.allowedTill,\n                \"Staking:E7\"\n            );\n        } else {\n            require(\n                // one of two params must be non-zero\n                (_terms.exactLockPeriod == 0) != (_terms.minLockPeriod == 0),\n                \"Staking:E8\"\n            );\n        }\n\n        terms[stakeType] = _terms;\n        emit TermsAdded(stakeType);\n    }\n\n    function disableTerms(bytes4 stakeType)\n        external\n        onlyOwner\n        nonZeroStakeType(stakeType)\n    {\n        Terms memory _terms = terms[stakeType];\n        require(_isDefinedTerms(terms[stakeType]), \"Staking:E9\");\n        require(_terms.isEnabled, \"Staking:EA\");\n\n        terms[stakeType].isEnabled = false;\n        emit TermsDisabled(stakeType);\n    }\n\n    /// Internal and private functions follow\n\n    function _createStake(\n        address staker,\n        uint256 amount,\n        bytes4 stakeType,\n        bytes calldata data\n    ) internal nonZeroStakeType(stakeType) returns (uint256) {\n        Terms memory _terms = terms[stakeType];\n        require(_terms.isEnabled, \"Staking: Terms unknown or disabled\");\n\n        require(amount > 0, \"Staking: Amount not set\");\n        uint256 _totalStake = amount + uint256(totalStaked);\n        require(_totalStake < 2**96, \"Staking: Too big amount\");\n\n        require(\n            _terms.minAmountScaled == 0 ||\n                amount >= SCALE * _terms.minAmountScaled,\n            \"Staking: Too small amount\"\n        );\n        require(\n            _terms.maxAmountScaled == 0 ||\n                amount <= SCALE * _terms.maxAmountScaled,\n            \"Staking: Too large amount\"\n        );\n\n        uint32 _now = safe32TimeNow();\n        require(\n            _terms.allowedSince == 0 || _now >= _terms.allowedSince,\n            \"Staking: Not yet allowed\"\n        );\n        require(\n            _terms.allowedTill == 0 || _terms.allowedTill > _now,\n            \"Staking: Not allowed anymore\"\n        );\n\n        // known contract - reentrancy guard and `safeTransferFrom` unneeded\n        require(\n            TOKEN.transferFrom(staker, address(this), amount),\n            \"Staking: transferFrom failed\"\n        );\n\n        uint256 stakeID = stakes[staker].length;\n\n        uint32 lockedTill = _terms.lockedTill;\n        if (lockedTill == 0) {\n            uint256 period = _terms.exactLockPeriod == 0\n                ? _terms.minLockPeriod\n                : _terms.exactLockPeriod;\n            lockedTill = safe32(period + _now);\n        }\n\n        Stake memory _stake = Stake(\n            uint32(stakeID), // overflow risk ignored\n            stakeType,\n            _now, // stakedAt\n            lockedTill,\n            0, // claimedAt\n            uint96(amount),\n            address(0) // no delegatee\n        );\n        stakes[staker].push(_stake);\n\n        totalStaked = uint96(_totalStake);\n        _addPower(staker, amount);\n\n        emit StakeCreated(staker, stakeID, amount, stakeType, lockedTill);\n\n        if (_terms.isRewarded) {\n            _sendStakedMsg(staker, _stake, data);\n        }\n        return stakeID;\n    }\n\n    function _addPower(address to, uint256 amount) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(to);\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\n        power[to].own += uint96(amount);\n    }\n\n    function _removePower(address from, uint256 amount) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(from);\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\n        power[from].own -= uint96(amount);\n    }\n\n    function _delegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(to);\n        _takeSnapshot(from);\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\n        power[from].own -= uint96(amount);\n        power[GLOBAL_ACCOUNT].delegated += uint96(amount);\n        power[to].delegated += uint96(amount);\n    }\n\n    function _reDelegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        _takeSnapshot(to);\n        _takeSnapshot(from);\n        power[from].delegated -= uint96(amount);\n        power[to].delegated += uint96(amount);\n    }\n\n    function _undelegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        power[GLOBAL_ACCOUNT].delegated -= uint96(amount);\n        power[from].delegated -= uint96(amount);\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\n        power[to].own += uint96(amount);\n    }\n\n    function _takeSnapshot(address _account) internal {\n        uint32 curBlockNum = safe32BlockNow();\n        if (latestSnapshotBlock(_account) < curBlockNum) {\n            // make new snapshot as the latest one taken before current block\n            snapshots[_account].push(\n                Snapshot(\n                    curBlockNum,\n                    power[_account].own,\n                    power[_account].delegated\n                )\n            );\n        }\n    }\n\n    function _snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) internal view returns (Snapshot memory) {\n        _sanitizeBlockNum(blockNum);\n\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\n\n        if (\n            // hint is correct?\n            hint <= snapshotsInfo.length &&\n            (hint == 0 || snapshotsInfo[hint - 1].beforeBlock < blockNum) &&\n            (hint == snapshotsInfo.length ||\n                snapshotsInfo[hint].beforeBlock >= blockNum)\n        ) {\n            // yes, return the hinted snapshot\n            if (hint < snapshotsInfo.length) {\n                return snapshotsInfo[hint];\n            } else {\n                return\n                    Snapshot(\n                        uint32(blockNum),\n                        power[_account].own,\n                        power[_account].delegated\n                    );\n            }\n        }\n        // no, fall back to binary search\n        else return _snapshotAt(_account, blockNum);\n    }\n\n    function _snapshotAt(address _account, uint256 blockNum)\n        internal\n        view\n        returns (Snapshot memory)\n    {\n        _sanitizeBlockNum(blockNum);\n\n        // https://en.wikipedia.org/wiki/Binary_search_algorithm\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\n        uint256 index;\n        uint256 low = 0;\n        uint256 high = snapshotsInfo.length;\n\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n\n            if (snapshotsInfo[mid].beforeBlock > blockNum) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // `low` is the exclusive upper bound. Find the inclusive upper bounds and set to index\n        if (low > 0 && snapshotsInfo[low - 1].beforeBlock == blockNum) {\n            return snapshotsInfo[low - 1];\n        } else {\n            index = low;\n        }\n\n        // If index is equal to snapshot array length, then no update made after the requested blockNum.\n        // This means the latest value is the right one.\n        if (index == snapshotsInfo.length) {\n            return\n                Snapshot(\n                    uint32(blockNum),\n                    uint96(power[_account].own),\n                    uint96(power[_account].delegated)\n                );\n        } else {\n            return snapshotsInfo[index];\n        }\n    }\n\n    function _sanitizeBlockNum(uint256 blockNum) private view {\n        require(blockNum <= safe32BlockNow(), \"Staking: Too big block number\");\n    }\n\n    function _isDefinedTerms(Terms memory _terms) internal pure returns (bool) {\n        return\n            (_terms.minLockPeriod != 0) ||\n            (_terms.exactLockPeriod != 0) ||\n            (_terms.lockedTill != 0);\n    }\n\n    function _sendStakedMsg(\n        address staker,\n        Stake memory _stake,\n        bytes calldata data\n    ) internal {\n        bytes4 action = _encodeStakeActionType(_stake.stakeType);\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\n        // known contract - reentrancy guard unneeded\n        // solhint-disable-next-line no-empty-blocks\n        try REWARD_MASTER.onAction(action, message) {} catch {\n            revert(\"Staking: onStake msg failed\");\n        }\n    }\n\n    function _sendUnstakedMsg(\n        address staker,\n        Stake memory _stake,\n        bytes calldata data,\n        bool _isForced\n    ) internal {\n        bytes4 action = _encodeUnstakeActionType(_stake.stakeType);\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\n        // known contract - reentrancy guard unneeded\n        // solhint-disable-next-line no-empty-blocks\n        try REWARD_MASTER.onAction(action, message) {} catch {\n            emit RewardMasterRevert(staker, _stake.id);\n            // REWARD_MASTER must be unable to revert forced calls\n            require(_isForced, \"Staking: REWARD_MASTER reverts\");\n        }\n    }\n\n    modifier stakeExist(address staker, uint256 stakeID) {\n        require(\n            stakes[staker].length > stakeID,\n            \"Staking: Stake doesn't exist\"\n        );\n        _;\n    }\n\n    modifier nonZeroStakeType(bytes4 stakeType) {\n        require(stakeType != bytes4(0), \"Staking: Invalid stake type 0\");\n        _;\n    }\n}\n"
    },
    "contracts/actions/StakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IStakingTypes.sol\";\n\nabstract contract StakingMsgProcessor {\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\"stake\"));\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\"unstake\"));\n\n    function _encodeStakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\n    }\n\n    function _encodeUnstakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\n    }\n\n    function _packStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                staker, // address\n                stake.amount, // uint96\n                stake.id, // uint32\n                stake.stakedAt, // uint32\n                stake.lockedTill, // uint32\n                stake.claimedAt, // uint32\n                data // bytes\n            );\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _unpackStakingActionMsg(bytes memory message)\n        internal\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\n        // (`data` may be of zero length)\n        require(message.length >= 48, \"SMP: unexpected msg length\");\n\n        uint256 stakerAndAmount;\n        uint256 idAndStamps;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n            // .. and (16 bytes of) the 3rd word\n            idAndStamps := mload(add(message, 0x40))\n        }\n\n        staker = address(uint160(stakerAndAmount >> 96));\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\n\n        uint256 dataLength = message.length - 48;\n        data = new bytes(dataLength);\n        for (uint256 i = 0; i < dataLength; i++) {\n            data[i] = message[i + 48];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStakingTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\ninterface IStakingTypes {\n    // Stake type terms\n    struct Terms {\n        // if stakes of this kind allowed\n        bool isEnabled;\n        // if messages on stakes to be sent to the {RewardMaster}\n        bool isRewarded;\n        // limit on the minimum amount staked, no limit if zero\n        uint32 minAmountScaled;\n        // limit on the maximum amount staked, no limit if zero\n        uint32 maxAmountScaled;\n        // Stakes not accepted before this time, has no effect if zero\n        uint32 allowedSince;\n        // Stakes not accepted after this time, has no effect if zero\n        uint32 allowedTill;\n        // One (at least) of the following three params must be non-zero\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\n        uint32 lockedTill;\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\n        uint32 exactLockPeriod;\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\n        uint32 minLockPeriod;\n    }\n\n    struct Stake {\n        // index in the `Stake[]` array of `stakes`\n        uint32 id;\n        // defines Terms\n        bytes4 stakeType;\n        // time this stake was created at\n        uint32 stakedAt;\n        // time this stake can be claimed at\n        uint32 lockedTill;\n        // time this stake was claimed at (unclaimed if 0)\n        uint32 claimedAt;\n        // amount of tokens on this stake (assumed to be less 1e27)\n        uint96 amount;\n        // address stake voting power is delegated to\n        address delegatee;\n    }\n}\n"
    },
    "contracts/interfaces/IVotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IStaking\ninterface IVotingPower {\n    struct Snapshot {\n        uint32 beforeBlock;\n        uint96 ownPower;\n        uint96 delegatedPower;\n    }\n\n    /// @dev Voting power integrants\n    struct Power {\n        uint96 own; // voting power that remains after delegating to others\n        uint96 delegated; // voting power delegated by others\n    }\n\n    /// @notice Returns total voting power staked\n    /// @dev \"own\" and \"delegated\" voting power summed up\n    function totalVotingPower() external view returns (uint256);\n\n    /// @notice Returns total \"own\" and total \"delegated\" voting power separately\n    /// @dev Useful, if \"own\" and \"delegated\" voting power treated differently\n    function totalPower() external view returns (Power memory);\n\n    /// @notice Returns global snapshot for given block\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @notice Returns snapshot on given block for given account\n    /// @param _account - account to get snapshot for\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view returns (Snapshot memory);\n\n    /// @dev Returns block number of the latest global snapshot\n    function latestGlobalsSnapshotBlock() external view returns (uint256);\n\n    /// @dev Returns block number of the given account latest snapshot\n    function latestSnapshotBlock(address _account)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns number of global snapshots\n    function globalsSnapshotLength() external view returns (uint256);\n\n    /// @dev Returns number of snapshots for given account\n    function snapshotLength(address _account) external view returns (uint256);\n\n    /// @dev Returns global snapshot at given index\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @dev Returns snapshot at given index for given account\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n}\n"
    },
    "contracts/StakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/ITotalStaked.sol\";\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/NonReentrant.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title StakeRewardController\n * @notice It accounts for and sends staking rewards to stakers\n * @dev It acts as the \"RewardAdviser\" for the \"RewardMaster\". The later calls\n * this contract to process messages from the \"Staking\" contract.\n * On Polygon, it replaces the \"StakeRewardAdviser\" and, together with the\n * \"RewardTreasury\", the \"MaticRewardPool\".\n * It simulates \"advices\" of the \"StakeRewardAdviser\" to the \"RewardMaster\":\n * - for stakes created before the replacement (aka \"old\" stakes), it returns\n * modified \"advices\" with \"old\" amounts of rewards (\"shares\"), but with the\n * address of the REWARD_TREASURY as the recipient of rewards; so the latest\n * gets \"old\" rewards, which the \"RewardMaster\" pays on \"advices\";\n * - for \"new\" stakes, it returns \"advices\" with zero rewards (zero \"shares\").\n * It acts as a \"spender\" from the \"RewardTreasury\", calling `transferFrom` to\n * send \"new\" rewards to stakers, both under \"old\" and \"new\" stakes.\n */\ncontract StakeRewardController is\n    ImmutableOwnable,\n    StakingMsgProcessor,\n    Utils,\n    Claimable,\n    NonReentrant,\n    IRewardAdviser\n{\n    /**\n     * ARPT (Arpt, arpt) stands for \"Accumulated amount of Rewards Per staked Token\".\n     *\n     * Staking reward is calculated on redemption of a stake (action == UNSTAKE),\n     * when we know `stakedAt`, `claimedAt` and `amount` of the stake.\n     *\n     * The amount to reward on every stake unstaked we compute as follows.\n     *   appreciation = newArpt - arptHistory[stakedAt]      // See (2) and (3)\n     *   rewardAmount = amount * appreciation                               (1)\n     *\n     * Each time when a stake is created (on \"STAKE\") or redeemed (on \"UNSTAKE\"),\n     * we calculate and saves params as follows.\n     *   timeNow = action == STAKE ? stakedAt : claimedAt\n     *   rewardAdded = (timeNow - rewardUpdatedOn) * REWARD_PER_SECOND\n     *   rewardPerTokenAdded = rewardAdded / totalStaked;\n     *   newArpt = accumRewardPerToken + rewardPerTokenAdded                (2)\n     *   accumRewardPerToken = newArpt\n     *   storage rewardUpdatedOn = timeNow\n     *   totalStaked = totalStaked + (action == STAKE ? +amount : -amount)\n     *   if (action == STAKE) {\n     *     arptHistory[timeNow] = newArpt                                   (3)\n     *   }\n     *\n     * (Scaling omitted in formulas above for clarity)\n     */\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice The ERC20 token to pay rewards in\n    address public immutable REWARD_TOKEN;\n\n    /// @notice Staking contract instance that handles stakes\n    address public immutable STAKING;\n\n    /// @notice Account that approves this contract as a spender of {REWARD_TOKEN} it holds\n    address public immutable REWARD_TREASURY;\n\n    /// @notice RewardMaster instance authorized to call `getRewardAdvice` on this contract\n    address public immutable REWARD_MASTER;\n\n    /// @notice Account authorized to initialize initial historical data\n    address private immutable HISTORY_PROVIDER;\n\n    // Params named with \"sc\" prefix are scaled (up) with this factor\n    uint256 private constant SCALE = 1e9;\n\n    /// @notice (UNIX) Time when reward accrual starts\n    uint256 public immutable REWARDING_START;\n    /// @notice (UNIX) Time when reward accrual ends\n    uint256 public immutable REWARDING_END;\n    /// @notice Total amount of allocated rewards (with 18 decimals)\n    uint256 public constant REWARD_AMOUNT = 2e24; // 2M tokens\n\n    /// @dev Minimum amount of `totalStaked` when rewards accrued\n    uint256 private constant MIN_TOTAL_STAKE_REWARDED = 100e18;\n    /// @dev Value for zero scARPT (`0` means \"undefined\")\n    uint256 private constant ZERO_SC_ARPT = 1;\n\n    /// @dev Period when rewards are accrued\n    uint256 private constant REWARDING_DURATION = 56 days;\n    /// @dev Amount of rewards accrued to the reward pool every second (scaled)\n    uint256 private constant sc_REWARD_PER_SECOND =\n        (REWARD_AMOUNT * SCALE) / REWARDING_DURATION;\n\n    bytes4 private constant STAKE_TYPE = 0x4ab0941a; // bytes4(keccak256(\"classic\"))\n    bytes4 private immutable STAKE;\n    bytes4 private immutable UNSTAKE;\n\n    // \"shares\" for \"old\" stakes are scaled (down) with this factor\n    uint256 private constant OLD_SHARE_FACTOR = 1e6;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice (UNIX) Time when history of \"old\" stakes was generated\n    uint32 public prefilledHistoryEnd;\n    /// @notice (UNIX) Time when this contract started processing of stakes\n    uint32 public activeSince;\n\n    /// @notice Total amount of outstanding stakes this contract is aware of\n    uint96 public totalStaked;\n\n    /// @notice (UNIX) Timestamp when rewards accrued for the last time\n    uint32 public rewardUpdatedOn;\n    /// @notice Amounts of rewards accrued till the `rewardUpdatedOn`\n    uint96 public totalRewardAccrued;\n\n    /// @notice \"Accumulated amount of Rewards Per staked Token\" (scaled)\n    /// computed at the `rewardUpdatedOn` time\n    uint256 public scAccumRewardPerToken;\n\n    /// @notice Mapping from `stakedAt` to \"Accumulated Reward amount Per Token staked\" (scaled)\n    /// @dev We pre-populate \"old\" stakes data, then \"STAKE\" calls append new stakes\n    mapping(uint256 => uint256) public scArptHistory;\n\n    /// @dev Emitted when new reward amount counted in `totalRewardAccrued`\n    event RewardAdded(\n        uint256 reward,\n        uint256 _totalRewardAccrued,\n        uint256 newScArpt\n    );\n    /// @dev Emitted when reward paid to a staker\n    event RewardPaid(address indexed staker, uint256 reward);\n    /// @dev Emitted when stake history gets initialized\n    event HistoryInitialized(\n        uint256 historyEnd,\n        uint256 _totalStaked,\n        uint256 scArpt\n    );\n    /// @dev Emitted on activation of this contract\n    event Activated(uint256 _activeSince, uint256 _totalStaked, uint256 scArpt);\n\n    constructor(\n        address _owner,\n        address token,\n        address stakingContract,\n        address rewardTreasury,\n        address rewardMaster,\n        address historyProvider,\n        uint256 rewardingStart\n    ) ImmutableOwnable(_owner) {\n        STAKE = _encodeStakeActionType(STAKE_TYPE);\n        UNSTAKE = _encodeUnstakeActionType(STAKE_TYPE);\n\n        require(\n            token != address(0) &&\n                stakingContract != address(0) &&\n                rewardTreasury != address(0) &&\n                rewardMaster != address(0) &&\n                historyProvider != address(0),\n            \"SRC: E1\"\n        );\n\n        REWARD_TOKEN = token;\n        STAKING = stakingContract;\n        REWARD_TREASURY = rewardTreasury;\n        REWARD_MASTER = rewardMaster;\n        HISTORY_PROVIDER = historyProvider;\n\n        REWARDING_START = rewardingStart;\n        uint256 rewardingEnd = rewardingStart + REWARDING_DURATION;\n        require(rewardingEnd > timeNow(), \"SRC: E2\");\n\n        REWARDING_END = rewardingEnd;\n    }\n\n    /// @notice If historical data has been initialized\n    function isInitialized() public view returns (bool) {\n        return prefilledHistoryEnd != 0;\n    }\n\n    /// @notice If the contract is active (i.e. processes new stakes)\n    function isActive() public view returns (bool) {\n        return activeSince != 0;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"SRC: unauthorized\");\n        require(isActive(), \"SRC: not yet active\");\n\n        (\n            address staker,\n            uint96 stakeAmount,\n            ,\n            uint32 stakedAt,\n            ,\n            ,\n\n        ) = _unpackStakingActionMsg(message);\n\n        require(staker != address(0), \"SRC: unexpected zero staker\");\n        require(stakeAmount != 0, \"SRC: unexpected zero amount\");\n        require(stakedAt != 0, \"SRC: unexpected zero stakedAt\");\n\n        // we ignore `claimedAt` from the `message` as the deployed version of\n        // the Staking contract never sets it in messages (it's a bug)\n        uint32 claimedAt = action == UNSTAKE ? safe32TimeNow() : 0;\n\n        if (stakedAt < activeSince) {\n            require(action == UNSTAKE, \"SRC: invalid 'old' action\");\n            _countUnstakeAndPayReward(staker, stakeAmount, stakedAt, claimedAt);\n            return _getUnstakeModifiedAdvice(staker, stakeAmount);\n        }\n\n        if (action == STAKE) {\n            _countNewStake(stakeAmount, stakedAt);\n            return _getStakeVoidAdvice(staker);\n        }\n\n        if (action == UNSTAKE) {\n            _countUnstakeAndPayReward(staker, stakeAmount, stakedAt, claimedAt);\n            return _getUnstakeVoidAdvice(staker);\n        }\n\n        revert(\"SRC: unsupported action\");\n    }\n\n    /// @notice It returns \"Accumulated amount of Rewards Per staked Token\" for given time.\n    /// If zero value as the time provided, the current network time assumed.\n    function getScArptAt(uint32 timestamp)\n        external\n        view\n        returns (uint256 scArpt)\n    {\n        // first, try to use historical data\n        scArpt = _getHistoricalArpt(timestamp);\n        if (scArpt != 0) return scArpt;\n\n        {\n            // then use the latest updated value, if applicable\n            uint32 _lastUpdatedOn = rewardUpdatedOn;\n            uint256 _lastScArpt = scAccumRewardPerToken;\n            if (timestamp == _lastUpdatedOn) return _lastScArpt;\n\n            // finally use extrapolation, unless data from the past requested\n            uint32 _timeNow = safe32TimeNow();\n            bool isForNow = timestamp == 0 || timestamp == _timeNow;\n            bool isForFuture = timestamp > _timeNow;\n            if (isForNow || isForFuture) {\n                uint32 till = isForNow ? _timeNow : timestamp;\n                (scArpt, ) = _computeRewardsAddition(\n                    _lastUpdatedOn,\n                    till,\n                    _lastScArpt,\n                    totalStaked\n                );\n            }\n        }\n        require(scArpt != 0, \"SRC: no data for requested time\");\n\n        return scArpt;\n    }\n\n    /// @notice It initializes historical data (for \"old\" stakes).\n    /// Only HISTORY_PROVIDER may call, and only if the history has not been finalized.\n    /// @dev If `historyEnd` is 0, may be called again (gets finalized otherwise).\n    /// ATTN: None of the \"old\" stake MUST be repaid by the historyEnd !!!\n    function saveHistoricalData(\n        uint96[] calldata amounts,\n        uint32[] calldata stakedAtDates,\n        uint32 historyEnd\n    ) external {\n        require(!isInitialized(), \"SRC: already initialized\");\n        require(msg.sender == HISTORY_PROVIDER, \"SRC: unauthorized\");\n        require(\n            amounts.length == stakedAtDates.length,\n            \"SRC: unmatched length\"\n        );\n\n        uint32 lastDate = 0;\n        for (uint256 i = 0; i < amounts.length; i++) {\n            uint32 stakedAt = stakedAtDates[i];\n            uint96 amount = amounts[i];\n            require(\n                stakedAt != 0 && stakedAt >= lastDate,\n                \"SRC: wrong history order\"\n            );\n            require(amount != 0, \"SRC: unexpected zero amount\");\n\n            _countNewStake(amount, stakedAt);\n\n            lastDate = stakedAt;\n        }\n\n        if (historyEnd != 0) {\n            require(\n                historyEnd >= rewardUpdatedOn && historyEnd <= safe32TimeNow(),\n                \"SRC: wrong historyEnd\"\n            );\n            prefilledHistoryEnd = historyEnd;\n            emit HistoryInitialized(\n                historyEnd,\n                totalStaked,\n                scAccumRewardPerToken\n            );\n        }\n    }\n\n    /// @notice It sets this contract as \"active\"\n    /// which assumes the contract started receiving data on new stakes\n    /// @dev Owner only may calls\n    function setActive() external onlyOwner {\n        require(!isActive(), \"SRC: already active\");\n        require(isInitialized(), \"SRC: yet uninitialized\");\n\n        uint32 _timeNow = safe32TimeNow();\n        activeSince = _timeNow;\n\n        // Call to a trusted contract - no reentrancy guard needed\n        uint256 actualTotalStaked = ITotalStaked(STAKING).totalStaked();\n        uint256 savedTotalStaked = uint256(totalStaked);\n\n        if (actualTotalStaked > savedTotalStaked) {\n            // new stakes have been created since historical data finalization\n            uint256 increase = actualTotalStaked - savedTotalStaked;\n            // it roughly adjusts totals by counting an equivalent \"stake\"\n            _countNewStake(safe96(increase), _timeNow);\n        } else if (savedTotalStaked > actualTotalStaked) {\n            // some \"old\" stakes was repaid after historical data finalization.\n            // it results in inaccurate rewarding and shall be avoided.\n            // the next line can decrease (but not exclude) inaccuracies.\n            totalStaked = safe96(actualTotalStaked);\n        }\n\n        emit Activated(_timeNow, actualTotalStaked, scAccumRewardPerToken);\n    }\n\n    /// @notice Withdraws accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function claimErc20(\n        address claimedToken,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        _claimErc20(claimedToken, to, amount);\n    }\n\n    /// Private and internal functions follow\n\n    function _countNewStake(uint96 stakeAmount, uint32 stakedAt) internal {\n        uint256 scArpt = _updateRewardPoolParams(stakedAt);\n        if (scArptHistory[stakedAt] == 0) {\n            // if not registered yet for this time (i.e. block)\n            scArptHistory[stakedAt] = scArpt != 0 ? scArpt : ZERO_SC_ARPT;\n        }\n        totalStaked = safe96(uint256(totalStaked) + uint256(stakeAmount));\n    }\n\n    function _countUnstakeAndPayReward(\n        address staker,\n        uint96 stakeAmount,\n        uint32 stakedAt,\n        uint32 claimedAt\n    ) internal {\n        uint256 startScArpt = _getHistoricalArpt(stakedAt);\n        require(startScArpt != 0, \"SRC: unknown ARPT for stakedAt\");\n\n        uint256 endScArpt = _updateRewardPoolParams(claimedAt);\n        uint256 reward = _countReward(stakeAmount, startScArpt, endScArpt);\n\n        totalStaked = safe96(uint256(totalStaked) - uint256(stakeAmount));\n\n        if (reward != 0) {\n            // trusted contract - nether reentrancy guard nor safeTransfer required\n            require(\n                IErc20Min(REWARD_TOKEN).transferFrom(\n                    REWARD_TREASURY,\n                    staker,\n                    reward\n                ),\n                \"SRC: Internal transfer failed\"\n            );\n            emit RewardPaid(staker, reward);\n        }\n    }\n\n    function _updateRewardPoolParams(uint32 actionTime)\n        internal\n        returns (uint256 newScArpt)\n    {\n        uint96 _totalStaked = totalStaked;\n        newScArpt = scAccumRewardPerToken;\n\n        if (_totalStaked < MIN_TOTAL_STAKE_REWARDED) {\n            // Too small amount is staked for reward accruals\n            return newScArpt;\n        }\n\n        uint32 prevActionTime = rewardUpdatedOn;\n        if (prevActionTime >= actionTime) return newScArpt;\n\n        uint256 rewardAdded;\n        (newScArpt, rewardAdded) = _computeRewardsAddition(\n            prevActionTime,\n            actionTime,\n            newScArpt,\n            totalStaked\n        );\n        scAccumRewardPerToken = newScArpt;\n        uint96 _totalRewardAccrued = safe96(\n            uint256(totalRewardAccrued) + rewardAdded\n        );\n        totalRewardAccrued = _totalRewardAccrued;\n        rewardUpdatedOn = actionTime;\n\n        emit RewardAdded(rewardAdded, _totalRewardAccrued, newScArpt);\n    }\n\n    function _computeRewardsAddition(\n        uint32 fromTime,\n        uint32 tillTime,\n        uint256 fromScArpt,\n        uint256 _totalStaked\n    ) internal view returns (uint256 newScArpt, uint256 rewardAdded) {\n        if (fromTime >= REWARDING_END || tillTime <= REWARDING_START)\n            return (fromScArpt, 0);\n\n        uint256 from = fromTime >= REWARDING_START ? fromTime : REWARDING_START;\n        uint256 till = tillTime <= REWARDING_END ? tillTime : REWARDING_END;\n        uint256 scRewardAdded = (till - from) * sc_REWARD_PER_SECOND;\n\n        rewardAdded = scRewardAdded / SCALE;\n        newScArpt = fromScArpt + scRewardAdded / _totalStaked;\n    }\n\n    function _getHistoricalArpt(uint32 stakedAt)\n        internal\n        view\n        returns (uint256 scArpt)\n    {\n        scArpt = scArptHistory[stakedAt];\n        if (scArpt > 0) return scArpt;\n\n        // Stake created within a period this contract has no stake data for ?\n        bool isBlindPeriodStake = stakedAt > prefilledHistoryEnd &&\n            stakedAt < activeSince;\n        if (isBlindPeriodStake) {\n            // approximate\n            scArpt = scArptHistory[activeSince];\n        }\n    }\n\n    function _countReward(\n        uint96 stakeAmount,\n        uint256 startScArpt,\n        uint256 endScArpt\n    ) internal pure returns (uint256 reward) {\n        reward = ((endScArpt - startScArpt) * uint256(stakeAmount)) / SCALE;\n    }\n\n    function _getStakeVoidAdvice(address staker)\n        internal\n        view\n        returns (Advice memory advice)\n    {\n        advice = _getEmptyAdvice();\n        advice.createSharesFor = staker;\n    }\n\n    function _getUnstakeVoidAdvice(address staker)\n        internal\n        view\n        returns (Advice memory advice)\n    {\n        advice = _getEmptyAdvice();\n        advice.redeemSharesFrom = staker;\n    }\n\n    function _getUnstakeModifiedAdvice(address staker, uint96 amount)\n        internal\n        view\n        returns (Advice memory advice)\n    {\n        advice = _getEmptyAdvice();\n        advice.redeemSharesFrom = staker;\n        advice.sharesToRedeem = safe96(uint256(amount) / OLD_SHARE_FACTOR);\n    }\n\n    function _getEmptyAdvice() internal view returns (Advice memory advice) {\n        advice = Advice(\n            address(0), // createSharesFor\n            0, // sharesToCreate\n            address(0), // redeemSharesFrom\n            0, // sharesToRedeem\n            REWARD_TREASURY // sendRewardTo\n        );\n    }\n}\n"
    },
    "contracts/interfaces/ITotalStaked.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev Interface to call `totalStaked` on the Staking contract\ninterface ITotalStaked {\n    function totalStaked() external returns (uint96);\n}\n"
    },
    "contracts/RewardTreasury.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IErc20Approve.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/NonReentrant.sol\";\n\n/**\n * @title RewardTreasury\n * @notice It keeps tokens of the \"Reward Pool\" and let authorized contracts spend them.\n * @dev The Owner may alter ERC20 allowances and withdraw accidentally sent tokens.\n */\ncontract RewardTreasury is ImmutableOwnable, NonReentrant, Claimable {\n    /// @notice Address of the Reward Pool token\n    address public immutable token;\n\n    constructor(address _owner, address _token) ImmutableOwnable(_owner) {\n        require(_token != address(0), \"RT: E1\");\n        token = _token;\n    }\n\n    /// @notice It sets amount as ERC20 allowance over the {token} to the given spender\n    /// @dev May be only called by the {OWNER}\n    function approveSpender(address spender, uint256 amount)\n        external\n        onlyOwner\n    {\n        // call to the trusted contract - no reentrancy guard needed\n        IErc20Approve(token).approve(spender, amount);\n    }\n\n    /// @notice Withdraws accidentally sent tokens from this contract\n    /// @dev May be only called by the {OWNER}\n    function claimErc20(\n        address claimedToken,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        require(claimedToken != token, \"RT: prohibited\");\n        _claimErc20(claimedToken, to, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IErc20Approve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @dev Interface to call ERC-20 `approve` function\ninterface IErc20Approve {\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    // Beware of risk: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/mocks/MockClaimable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../utils/Claimable.sol\";\n\ncontract MockClaimable is Claimable {\n    function internalClaimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        _claimErc20(token, to, amount);\n    }\n}\n"
    },
    "contracts/MaticRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IRewardPool.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Utils.sol\";\nimport \"./utils/NonReentrant.sol\";\n\n/**\n * @title MaticRewardPool\n * @notice It vests $ZKP token from its balance gradually over time.\n * @dev This contract is supposed to release $ZKP to the `RewardMaster` on Matic.\n * Tokens to vest will be bridged from the mainnet to Matic (maybe, a few times).\n */\ncontract MaticRewardPool is\n    ImmutableOwnable,\n    NonReentrant,\n    Claimable,\n    IRewardPool,\n    Utils\n{\n    /// @notice Address of the token vested ($ZKP)\n    IErc20Min public immutable token;\n\n    /// @notice Address to vest tokens to\n    address public recipient;\n\n    /// @notice (UNIX) Timestamp when vesting starts\n    uint32 public startTime;\n    /// @notice (UNIX) Timestamp when vesting ends\n    uint32 public endTime;\n\n    constructor(address _token, address _owner)\n        ImmutableOwnable(_owner)\n        nonZeroAddress(_token)\n    {\n        token = IErc20Min(_token);\n    }\n\n    /// @inheritdoc IRewardPool\n    function releasableAmount() external view override returns (uint256) {\n        if (recipient == address(0)) return 0;\n\n        return _releasableAmount();\n    }\n\n    /// @inheritdoc IRewardPool\n    function vestRewards() external override returns (uint256 amount) {\n        // revert if unauthorized or recipient not yet set\n        require(msg.sender == recipient, \"RP: unauthorized\");\n\n        amount = _releasableAmount();\n\n        if (amount != 0) {\n            // trusted contract - no reentrancy guard needed\n            token.transfer(recipient, amount);\n            emit Vested(amount);\n        }\n    }\n\n    /// @notice Sets the {recipient}, {startTime} and {endTime} to given values\n    /// @dev Owner only may call, once only\n    function initialize(\n        address _recipient,\n        uint32 _startTime,\n        uint32 _endTime\n    ) external onlyOwner nonZeroAddress(_recipient) {\n        // once only\n        require(recipient == address(0), \"RP: initialized\");\n        // _endTime can't be in the past\n        require(_endTime > timeNow(), \"RP: I2\");\n        require(_endTime > _startTime, \"RP: I3\");\n\n        recipient = _recipient;\n        startTime = _startTime;\n        endTime = _endTime;\n\n        emit Initialized(0, _recipient, _endTime);\n    }\n\n    /// @notice Withdraws accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function claimErc20(\n        address claimedToken,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        if (claimedToken == address(token)) {\n            require(timeNow() > endTime, \"RP: prohibited\");\n        }\n        _claimErc20(claimedToken, to, amount);\n    }\n\n    function _releasableAmount() internal view returns (uint256) {\n        uint256 _timeNow = timeNow();\n\n        if (startTime > _timeNow) return 0;\n\n        // trusted contract - no reentrancy guard needed\n        uint256 balance = token.balanceOf(address(this));\n        if (_timeNow >= endTime) return balance;\n\n        return (balance * (_timeNow - startTime)) / (endTime - startTime);\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"RP: zero address\");\n        _;\n    }\n}\n"
    },
    "contracts/RewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IVestingPools.sol\";\nimport \"./interfaces/IRewardPool.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title RewardPool\n * @notice It vests $ZKP token from the Panther Protocol \"Reward Pool\".\n * @dev One of the vesting pools (maybe, the major one) which the VestingPools\n * contract vests $ZKP tokens to is the \"Reward Pool\" (aka \"Protocol Pool\").\n * This contract assumed to have a \"pool wallet\" role with the VestingPools,\n * and therefore has a privilege to request vesting $ZKPs from the Reward Pool\n * to the \"recipient\".\n * The \"RewardMaster\" contract, that distributes tokens to users as rewards,\n * is assumed to be the \"recipient\".\n *\n * This contract is expected to be replaced. Therefore it allows the owner\n * to transfer the \"pool wallet\" role to another account.\n */\ncontract RewardPool is ImmutableOwnable, Utils, IRewardPool {\n    /// @notice Address of the VestingPools instance\n    address public immutable VESTING_POOLS;\n\n    /// @notice ID of the pool (in the VestingPools) to vest from\n    uint8 public poolId;\n\n    /// @dev (UNIX) Time when vesting gets disabled\n    uint32 public endTime;\n\n    /// @notice Address to vest tokens to\n    address public recipient;\n\n    constructor(address _vestingPools, address _owner)\n        ImmutableOwnable(_owner)\n        nonZeroAddress(_vestingPools)\n    {\n        VESTING_POOLS = _vestingPools;\n    }\n\n    /// @inheritdoc IRewardPool\n    function releasableAmount() external view override returns (uint256) {\n        if (recipient == address(0)) return 0;\n        if (timeNow() >= endTime) return 0;\n\n        return _releasableAmount();\n    }\n\n    /// @inheritdoc IRewardPool\n    function vestRewards() external override returns (uint256 amount) {\n        // revert if unauthorized or recipient not yet set\n        require(msg.sender == recipient, \"RP: unauthorized\");\n        require(timeNow() < endTime, \"RP: expired\");\n\n        amount = _releasableAmount();\n\n        if (amount != 0) {\n            // here and after, no reentrancy guard needed for calls to VESTING_POOLS\n            IVestingPools(VESTING_POOLS).releaseTo(poolId, recipient, amount);\n            emit Vested(amount);\n        }\n    }\n\n    /// @notice Sets the {poolId} and the {recipient} to given values\n    /// @dev Owner only may call, once only\n    /// This contract address must be set in the VestingPools as the wallet for the pool\n    function initialize(\n        uint8 _poolId,\n        address _recipient,\n        uint32 _endTime\n    ) external onlyOwner nonZeroAddress(_recipient) {\n        // once only\n        require(recipient == address(0), \"RP: initialized\");\n        // _endTime can't be in the past\n        require(_endTime > timeNow(), \"RP: expired\");\n        // this contract must be registered with the VestingPools\n        require(\n            IVestingPools(VESTING_POOLS).getWallet(_poolId) == address(this),\n            \"RP:E7\"\n        );\n\n        poolId = _poolId;\n        recipient = _recipient;\n        endTime = _endTime;\n\n        emit Initialized(_poolId, _recipient, _endTime);\n    }\n\n    /// @notice Calls VestingPools to transfer 'pool wallet' role to given address\n    /// @dev Owner only may call, once only\n    function transferPoolWalletRole(address newWallet)\n        external\n        onlyOwner\n        nonZeroAddress(newWallet)\n    {\n        IVestingPools(VESTING_POOLS).updatePoolWallet(poolId, newWallet);\n    }\n\n    function _releasableAmount() internal view returns (uint256) {\n        return IVestingPools(VESTING_POOLS).releasableAmount(poolId);\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"RP: zero address\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IVestingPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVestingPools {\n    /**\n     * @notice Returns Token address.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Returns the wallet address of the specified pool.\n     */\n    function getWallet(uint256 poolId) external view returns (address);\n\n    /**\n     * @notice Returns the amount that may be vested now from the given pool.\n     */\n    function releasableAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount that has been vested from the given pool\n     */\n    function vestedAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the pool wallet.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function release(uint256 poolId, uint256 amount)\n        external\n        returns (uint256 released);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the given address.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function releaseTo(\n        uint256 poolId,\n        address account,\n        uint256 amount\n    ) external returns (uint256 released);\n\n    /**\n     * @notice Updates the wallet for the given pool.\n     * @dev Only address with the 'wallet' role may call.\n     */\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\n\n    /// @notice Emitted on an amount vesting.\n    event Released(uint256 indexed poolId, address to, uint256 amount);\n}\n"
    },
    "contracts/StakeRewardController2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IRewardAdviser.sol\";\n\ninterface IEntitled {\n    function entitled(address) external view returns (uint256);\n}\n\n/**\n * @title StakeRewardController2\n * @notice A bug in RewardPool contract at eth:0xcF463713521Af5cE31AD18F6914f3706493F10e5, after\n * the `endTime`, prevents the RewardMaster (eth:0x347a58878D04951588741d4d16d54B742c7f60fC) from\n * sending staking reward tokens to stakers. This contract implements a work-around.\n * @dev On `unstake` method call on the Staking (eth:0xf4d06d72dACdD8393FA4eA72FdcC10049711F899),\n * the later calls the RewardMaster, which then calls `getRewardAdvice` method on this contract\n * to process the `UNSTAKED` messages.\n * This contract returns the \"advice\" for the RewardMaster with zero `sharesToRedeem`. On the zero\n * advice received, the RewardMaster skips sending reward tokens to the staker, so the buggy code\n * `require(timeNow() < endTime` in the `RewardPool::vestRewards` method does not get called.\n * Furthermore, this contract transfers reward tokens to a staker instead of the RewardMaster as\n * follows. As a part of the `getRewardAdvice` call, this contract:\n * - requests the RewardMaster on the amount of rewards that the staker is already entitled to\n * (there are no mare rewards expected, as the rewarded period ended)\n * - sends the reward amount from this its balance to the staker\n * As a prerequisite, this contract:\n * - shall be authorized as the \"RewardAdviser\" with the RewardMaster for \"classic\" stakes\n * - shall hold reward tokens on its balance\n */\ncontract StakeRewardController2 is IRewardAdviser {\n    // solhint-disable var-name-mixedcase\n\n    /// @notice The owner who has privileged rights\n    address public immutable OWNER;\n\n    /// @notice The ERC20 token to pay rewards in\n    address public immutable REWARD_TOKEN;\n\n    /// @notice Staking contract instance that handles stakes\n    address public immutable STAKING;\n\n    /// @notice RewardMaster instance authorized to call `getRewardAdvice` on this contract\n    address public immutable REWARD_MASTER;\n\n    // bytes4(keccak256(\"classic\"))\n    bytes4 private constant STAKE_TYPE = 0x4ab0941a;\n    // bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), STAKE_TYPE)))\n    bytes4 private constant UNSTAKE = 0x493bdf45;\n\n    // 2022-08-15T00:00:00.000Z\n    uint256 private constant ZKP_RESCUE_ALLOWED_SINCE = 1660521600;\n\n    // solhint-enable var-name-mixedcase\n\n    uint256 public unclaimedRewards;\n    /// @notice Mapping from staker to claimed reward amount\n    mapping(address => uint256) public rewardsClaimed;\n\n    uint256 private _reentrancyStatus;\n\n    /// @dev Emitted when reward paid to a staker\n    event RewardPaid(address indexed staker, uint256 reward);\n\n    /// @dev Emitted on activation of this contract\n    event Activated(uint256 _activeSince, uint256 _totalStaked, uint256 scArpt);\n\n    constructor(\n        address _owner,\n        address token,\n        address stakingContract,\n        address rewardMaster,\n        uint256 _unclaimedRewards\n    ) {\n        require(\n            _unclaimedRewards != 0 &&\n                _owner != address(0) &&\n                token != address(0) &&\n                stakingContract != address(0) &&\n                rewardMaster != address(0),\n            \"SRC: E1\"\n        );\n\n        OWNER = _owner;\n        REWARD_TOKEN = token;\n        STAKING = stakingContract;\n        REWARD_MASTER = rewardMaster;\n        unclaimedRewards = _unclaimedRewards;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"SRC: unauthorized\");\n        require(action == UNSTAKE, \"SRC: unexpected action\");\n\n        address staker = _decodeStakerFromMsg(message);\n        require(staker != address(0), \"SRC: unexpected zero staker\");\n\n        _payRewardIfNotYetPaid(staker);\n\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(this) // sendRewardTo\n            );\n    }\n\n    /// @notice Returns reward token amount entitled to the given user/account\n    function entitled(address staker) external view returns (uint256 rewards) {\n        rewards = (rewardsClaimed[staker] == 0)\n            ? _getEntitledReward(staker)\n            : 0;\n    }\n\n    /// @notice Withdraws unclaimed rewards or accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function rescueErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        require(_reentrancyStatus != 1, \"SRC: can't be re-entered\");\n        _reentrancyStatus = 1;\n\n        require(OWNER == msg.sender, \"SRC: unauthorized\");\n        require(\n            (token != REWARD_TOKEN) ||\n                (block.timestamp >= ZKP_RESCUE_ALLOWED_SINCE),\n            \"SRC: too early withdrawal\"\n        );\n\n        _transferErc20(token, to, amount);\n        _reentrancyStatus = 2;\n    }\n\n    function _payRewardIfNotYetPaid(address staker) internal {\n        // Do nothing if already paid\n        if (rewardsClaimed[staker] != 0) return;\n\n        uint256 reward = _getEntitledReward(staker);\n        if (reward == 0) return;\n\n        uint256 _unclaimedRewards = unclaimedRewards;\n\n        // Precaution against imprecise calculations/roundings\n        if (reward > _unclaimedRewards) reward = _unclaimedRewards;\n\n        rewardsClaimed[staker] = reward;\n        unclaimedRewards = _unclaimedRewards - reward;\n\n        // trusted contract - reentrancy guard unneeded\n        _transferErc20(REWARD_TOKEN, staker, reward);\n        emit RewardPaid(staker, reward);\n    }\n\n    function _decodeStakerFromMsg(bytes memory message)\n        internal\n        pure\n        returns (address staker)\n    {\n        uint256 stakerAndAmount;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n        }\n        staker = address(uint160(stakerAndAmount >> 96));\n    }\n\n    // Declared as `internal` to ease testing\n    function _getEntitledReward(address staker)\n        internal\n        view\n        returns (uint256 reward)\n    {\n        // trusted contract - reentrancy guard unneeded\n        reward = IEntitled(REWARD_MASTER).entitled(staker);\n    }\n\n    function _transferErc20(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(bytes('transfer(address,uint256)')));\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SRC: transferErc20 failed\"\n        );\n    }\n}\n"
    },
    "contracts/StakeRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title StakeRewardAdviser\n * @notice It \"advises\" the \"RewardMaster\" on staking rewards (\"shares\").\n * @dev It acts as the \"RewardAdviser\" for the \"RewardMaster\": the latter calls\n * this contract to process messages from the \"Staking\" contract.\n */\ncontract StakeRewardAdviser is StakingMsgProcessor, Utils, IRewardAdviser {\n    // solhint-disable var-name-mixedcase\n    bytes4 private immutable STAKED;\n    bytes4 private immutable UNSTAKED;\n    uint256 public immutable FACTOR;\n    // solhint-enable var-name-mixedcase\n\n    uint256 private constant SCALE = 1e9;\n\n    constructor(bytes4 stakeType, uint256 stakeAmountToSharesScaledFactor) {\n        require(\n            stakeType != bytes4(0) && stakeAmountToSharesScaledFactor != 0,\n            \"PSA:E1\"\n        );\n        STAKED = _encodeStakeActionType(stakeType);\n        UNSTAKED = _encodeUnstakeActionType(stakeType);\n        FACTOR = stakeAmountToSharesScaledFactor;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        view\n        override\n        returns (Advice memory)\n    {\n        (address staker, uint96 amount, , , , , ) = _unpackStakingActionMsg(\n            message\n        );\n        require(staker != address(0), \"PSA: unexpected zero staker\");\n        require(amount != 0, \"PSA: unexpected zero amount\");\n\n        uint256 shares = (uint256(amount) * FACTOR) / SCALE;\n\n        if (action == STAKED) {\n            return\n                Advice(\n                    staker, // createSharesFor\n                    safe96(shares), // sharesToCreate\n                    address(0), // redeemSharesFrom\n                    0, // sharesToRedeem\n                    address(0) // sendRewardTo\n                );\n        }\n        if (action == UNSTAKED) {\n            return\n                Advice(\n                    address(0), // createSharesFor\n                    0, // sharesToCreate\n                    staker, // redeemSharesFrom\n                    safe96(shares), // sharesToRedeem\n                    staker // sendRewardTo\n                );\n        }\n\n        revert(\"PSA: unsupported action\");\n    }\n}\n"
    },
    "contracts/mocks/MockStakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../actions/StakingMsgProcessor.sol\";\nimport \"../interfaces/IStakingTypes.sol\";\n\ncontract MockStakingMsgProcessor is StakingMsgProcessor {\n    function internalEncodeStakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeStakeActionType(stakeType);\n    }\n\n    function internalEncodeUnstakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeUnstakeActionType(stakeType);\n    }\n\n    function internalPackStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) external pure returns (bytes memory) {\n        return _packStakingActionMsg(staker, stake, data);\n    }\n\n    function internalUnpackStakingActionMsg(bytes memory message)\n        external\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        return _unpackStakingActionMsg(message);\n    }\n}\n"
    },
    "contracts/mocks/MockRewardMaster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../RewardMaster.sol\";\n\ncontract MockRewardMaster is RewardMaster {\n    constructor(\n        address _rewardToken,\n        address _rewardPool,\n        address _owner\n    )\n        RewardMaster(_rewardToken, _rewardPool, _owner)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function internalComputeRedemption(\n        uint256 sharesToRedeem,\n        UserRecord memory rec,\n        uint256 _accumRewardPerShare\n    )\n        external\n        pure\n        returns (\n            uint256 reward,\n            uint256 newShares,\n            uint256 newOffset\n        )\n    {\n        return _computeRedemption(sharesToRedeem, rec, _accumRewardPerShare);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}