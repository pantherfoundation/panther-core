{
  "address": "0x0Ab02321Fc701C3C539F92b563B9cD4a2c0f75A4",
  "abi": [
    {
      "inputs": [],
      "name": "A",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "BASE8_X",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "BASE8_Y",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "D",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PM1D2",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "Q",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf2141ea9181ae7785786fc59c5b8abcc0acc68731d82e0dcd3726a3ac398139c",
  "receipt": {
    "to": null,
    "from": "0xfB474a7FeCDaFBD412ebF0d60A0C32794F82d3dD",
    "contractAddress": "0x0Ab02321Fc701C3C539F92b563B9cD4a2c0f75A4",
    "transactionIndex": 10,
    "gasUsed": "126058",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000020000000000000002000000000000000000000000008004000000020000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000002000000000000000000000000100000000000000000000000000080000000000000000000000000000000000000000000100000",
    "blockHash": "0xdd201dc7dd968529de697ea47d335db882f194c5e7bb5e261e52795ba7d92a5c",
    "transactionHash": "0xf2141ea9181ae7785786fc59c5b8abcc0acc68731d82e0dcd3726a3ac398139c",
    "logs": [
      {
        "transactionIndex": 10,
        "blockNumber": 38977250,
        "transactionHash": "0xf2141ea9181ae7785786fc59c5b8abcc0acc68731d82e0dcd3726a3ac398139c",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000fb474a7fecdafbd412ebf0d60a0c32794f82d3dd",
          "0x0000000000000000000000005082f249cdb2f2c1ee035e4f423c46ea2dab3ab1"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000abf93f77760000000000000000000000000000000000000000000000000019411d131af920a900000000000000000000000000000000000000000000001516ca7ffb521de3b200000000000000000000000000000000000000000000000019407119db81aaa900000000000000000000000000000000000000000000001516cb2bf4919559b2",
        "logIndex": 30,
        "blockHash": "0xdd201dc7dd968529de697ea47d335db882f194c5e7bb5e261e52795ba7d92a5c"
      }
    ],
    "blockNumber": 38977250,
    "cumulativeGasUsed": "1532307",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8ced4b4e64f70b0ab3e17932cf8fd4ee",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"A\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE8_X\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BASE8_Y\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"D\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PM1D2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Q\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/crypto/BabyJubJub.sol\":\"BabyJubJub\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"contracts/common/Types.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// SPDX-FileCopyrightText: Copyright 2021-25 Panther Protocol Foundation\\n// slither-disable-next-line solc-version\\npragma solidity ^0.8.4;\\n\\nstruct G1Point {\\n    uint256 x;\\n    uint256 y;\\n}\\n\\n// Encoding of field elements is: X[0] * z + X[1]\\nstruct G2Point {\\n    uint256[2] x;\\n    uint256[2] y;\\n}\\n\\n// Verification key for SNARK\\nstruct VerifyingKey {\\n    G1Point alfa1;\\n    G2Point beta2;\\n    G2Point gamma2;\\n    G2Point delta2;\\n    G1Point[] ic;\\n}\\n\\nstruct SnarkProof {\\n    G1Point a;\\n    G2Point b;\\n    G1Point c;\\n}\\n\\nstruct PluginData {\\n    address contractAddress;\\n    bytes callData;\\n}\\n\\nstruct ElGamalCiphertext {\\n    G1Point c1;\\n    G1Point c2;\\n}\\n\\n// For MASP V0 and V1\\nstruct ZAsset {\\n    // reserved (for networkId, tokenIdPolicy. etc..)\\n    uint64 _unused;\\n    // 0x00 by default\\n    uint8 version;\\n    // Refer to Constants.sol\\n    uint8 status;\\n    // Refer to Constants.sol\\n    uint8 tokenType;\\n    // 0x00 - no scaling\\n    uint8 scale;\\n    // token contract address\\n    address token;\\n}\\n\\nstruct LockData {\\n    // Refer to Constants.sol\\n    uint8 tokenType;\\n    // Token contract address\\n    address token;\\n    // For ERC-721, ERC-1155 tokens\\n    uint256 tokenId;\\n    // The account to transfer the token from/to (on `lock`/`unlock`)\\n    address extAccount;\\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\\n    uint96 extAmount;\\n}\\n\",\"keccak256\":\"0xbe5feb34f2f9eb101f2f6b01290b97b0a8696bf64bed4822bbffc65b12b07aff\",\"license\":\"MIT\"},\"contracts/protocol/crypto/BabyJubJub.sol\":{\"content\":\"// SPDX-License-Identifier: GPL\\n// SPDX-FileCopyrightText: Copyright 2021-25 Panther Protocol Foundation\\n// Implementer name - yondonfu\\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\\npragma solidity ^0.8.16;\\nimport \\\"../../common/Types.sol\\\";\\nimport { FIELD_SIZE } from \\\"./SnarkConstants.sol\\\";\\n\\nlibrary BabyJubJub {\\n    // Curve parameters\\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\\n    // A = 168700\\n    uint256 public constant A = 0x292FC;\\n    // D = 168696\\n    uint256 public constant D = 0x292F8;\\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\\n    // slither-disable-next-line too-many-digits\\n    uint256 public constant Q =\\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\\n\\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\\n    // That is, it generates the set of points of order l and origin O.\\n    // slither-disable-next-line too-many-digits\\n    uint256 public constant BASE8_X =\\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\\n    // slither-disable-next-line too-many-digits\\n    uint256 public constant BASE8_Y =\\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\\n\\n    // pm1d2 = (SNARK_FIELD - 1) >> 1 // same as `negative_one / 2\\n    // slither-disable-next-line too-many-digits\\n    uint256 public constant PM1D2 =\\n        10944121435919637611123202872628637544274182200208017171849102093287904247808;\\n\\n    // TODO: remove dependency on BabyJubJub as a standalone contract\\n    function pointPack(G1Point memory point)\\n        internal\\n        pure\\n        returns (bytes32 _packed)\\n    {\\n        _packed = bytes32(point.y);\\n\\n        if (point.x > PM1D2) {\\n            _packed = bytes32(\\n                point.y |\\n                    0x8000000000000000000000000000000000000000000000000000000000000000\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Add 2 points on baby jubjub curve\\n     * Formulae for adding 2 points on a twisted Edwards curve:\\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\\n     */\\n    function pointAdd(G1Point memory g1, G1Point memory g2)\\n        internal\\n        view\\n        returns (G1Point memory)\\n    {\\n        uint256 x3 = 0;\\n        uint256 y3 = 0;\\n        if (g1.x == 0 && g1.y == 0) {\\n            return G1Point(x3, y3);\\n        }\\n\\n        if (g2.x == 0 && g1.y == 0) {\\n            return G1Point(x3, y3);\\n        }\\n\\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\\n\\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\\n        return G1Point(x3, y3);\\n    }\\n\\n    /**\\n     * @dev Perform modular subtraction\\n     */\\n    function submod(\\n        uint256 _a,\\n        uint256 _b,\\n        uint256 _mod\\n    ) internal pure returns (uint256) {\\n        uint256 aNN = _a;\\n\\n        if (_a <= _b) {\\n            aNN += _mod;\\n        }\\n\\n        return addmod(aNN - _b, 0, _mod);\\n    }\\n\\n    /**\\n     * @dev Compute modular inverse of a number\\n     */\\n    function inverse(uint256 _a) internal view returns (uint256) {\\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\\n        return expmod(_a, Q - 2, Q);\\n    }\\n\\n    /**\\n     * @dev Helper function to call the bigModExp precompile\\n     */\\n    function expmod(\\n        uint256 _b,\\n        uint256 _e,\\n        uint256 _m\\n    ) internal view returns (uint256 o) {\\n        // solhint-disable no-inline-assembly\\n        // slither-disable-next-line assembly\\n        assembly {\\n            let memPtr := mload(0x40)\\n            mstore(memPtr, 0x20) // Length of base _b\\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\\n            mstore(add(memPtr, 0x60), _b) // Base _b\\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\\n\\n            // The bigModExp precompile is at 0x05\\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\\n            switch success\\n            case 0 {\\n                revert(0x0, 0x0)\\n            }\\n            default {\\n                o := mload(memPtr)\\n            }\\n        }\\n        // solhint-enable no-inline-assembly\\n    }\\n\\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\\n        internal\\n        view\\n        returns (G1Point memory r)\\n    {\\n        r.x = 0;\\n        r.y = 1;\\n\\n        uint256 rem = scalar;\\n        G1Point memory exp = point;\\n\\n        while (rem != uint256(0)) {\\n            if ((rem & 1) == 1) {\\n                r = pointAdd(r, exp);\\n            }\\n            exp = pointAdd(exp, exp);\\n            rem = rem >> 1;\\n        }\\n        r.x = r.x % Q;\\n        r.y = r.y % Q;\\n\\n        return r;\\n    }\\n\\n    function isG1PointLowerThanFieldSize(uint256[2] memory point)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return point[0] <= FIELD_SIZE && point[1] <= FIELD_SIZE;\\n    }\\n}\\n\",\"keccak256\":\"0x97405a0dad4e7cbc9dd13227c9e832793e065120a034719d3cfb6c15dd4693fb\",\"license\":\"GPL\"},\"contracts/protocol/crypto/SnarkConstants.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\n// SPDX-FileCopyrightText: Copyright 2021-25 Panther Protocol Foundation\\n// solhint-disable var-name-mixedcase\\npragma solidity ^0.8.16;\\n\\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n// @dev Field prime of alt_bn128\\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n\\n// FIXME: make MAGICAL_CONSTRAINT the public input (var, not const) - it MUST have random value on every invocation\\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\\n\",\"keccak256\":\"0xc5545b99ebafdce4488581390f9466e1baf2ab9bb2107cb6614b34c101183de5\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x61015061003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061007c5760003560e01c8063a8a573e31161005a578063a8a573e3146100eb578063e493ef8c14610112578063f446c1d01461013957600080fd5b80630f529ba214610081578063278c61fc1461009d57806368d551ce146100c4575b600080fd5b61008b620292f881565b60405190815260200160405180910390f35b61008b7f183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f800000081565b61008b7f0bb77a6ad63e739b4eacb2e09d6277c12ab8d8010534e0b62893f3f6bb95705181565b61008b7f25797203f7a0b24925572e1cd16bf9edfce0051fb9e133774b3c257a872d7d8b81565b61008b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000181565b61008b620292fc8156fea164736f6c6343000810000a",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061007c5760003560e01c8063a8a573e31161005a578063a8a573e3146100eb578063e493ef8c14610112578063f446c1d01461013957600080fd5b80630f529ba214610081578063278c61fc1461009d57806368d551ce146100c4575b600080fd5b61008b620292f881565b60405190815260200160405180910390f35b61008b7f183227397098d014dc2822db40c0ac2e9419f4243cdcb848a1f0fac9f800000081565b61008b7f0bb77a6ad63e739b4eacb2e09d6277c12ab8d8010534e0b62893f3f6bb95705181565b61008b7f25797203f7a0b24925572e1cd16bf9edfce0051fb9e133774b3c257a872d7d8b81565b61008b7f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f000000181565b61008b620292fc8156fea164736f6c6343000810000a",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}