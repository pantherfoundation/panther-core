{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/binaryTree/BinaryIncrementalUpdatableMerkleTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./BinaryMerkleZeros.sol\";\nimport \"../../protocol/triadTree/Hasher.sol\";\n\n/**\n * @title BinaryIncrementalUpdatableMerkleTree\n * @notice\n * @dev\n */\nabstract contract BinaryIncrementalUpdatableMerkleTree is\n    BinaryMerkleZeros,\n    Hasher\n{\n    // `index` of the next leaf to insert\n    // !!! NEVER access it directly from child contracts: `internal` to ease testing only\n    uint256 internal _nextLeafIndex;\n\n    // The nodes of the subtrees used in the last addition of a leaf (level -> [left node, right node])\n    mapping(uint256 => bytes32[2]) internal _filledSubtrees;\n\n    uint256 public constant LEAVES_NUM = 2**TREE_DEPTH;\n\n    bytes32 public currentRoot;\n\n    /**\n     * @dev Inserts a leaf into the tree if it's not yet full\n     * @param leaf The leaf to be inserted\n     * @return insertedLeafIndex The leaf index which has been inserted\n     */\n    function insert(bytes32 leaf) internal returns (uint256 insertedLeafIndex) {\n        uint256 index = _nextLeafIndex;\n        require(index < LEAVES_NUM, \"BIUT: Tree is full\");\n\n        // here the variable is intentionally declared only ...\n        // slither-disable-next-line uninitialized-local\n        bytes32[TREE_DEPTH] memory zeros;\n        // ... and initialized in this call\n        populateZeros(zeros);\n\n        bytes32 left;\n        bytes32 right;\n        bytes32 _hash = leaf;\n\n        for (uint8 level = 0; level < TREE_DEPTH; ) {\n            if (index % 2 == 0) {\n                left = _hash;\n                right = zeros[level];\n\n                _filledSubtrees[level] = [left, right];\n            } else {\n                left = _filledSubtrees[level][0];\n                right = _hash;\n\n                _filledSubtrees[level][1] = right;\n            }\n\n            _hash = hash(left, right);\n            index >>= 1;\n\n            unchecked {\n                ++level;\n            }\n        }\n\n        currentRoot = _hash;\n        insertedLeafIndex = _nextLeafIndex;\n        _nextLeafIndex++;\n    }\n\n    /**\n     * @dev Update an existing leaf\n     * @param leaf Leaf to be updated.\n     * @param newLeaf New leaf.\n     * @param proofSiblings Array of the sibling nodes of the proof of membership.\n     * @param proofPathIndices Path of the proof of membership.\n     * @return _hash The new root after updating the tree\n     */\n    function update(\n        bytes32 leaf,\n        bytes32 newLeaf,\n        bytes32[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) internal returns (bytes32 _hash) {\n        require(newLeaf != leaf, \"BIUT: New leaf cannot be equal the old one\");\n        require(\n            verify(leaf, proofSiblings, proofPathIndices),\n            \"BIUT: Leaf is not part of the tree\"\n        );\n\n        _hash = newLeaf;\n        uint256 updateIndex;\n\n        for (uint256 i = 0; i < TREE_DEPTH; ) {\n            updateIndex |= uint256(proofPathIndices[i]) << uint256(i);\n\n            if (proofPathIndices[i] == 0) {\n                if (proofSiblings[i] == _filledSubtrees[i][1]) {\n                    _filledSubtrees[i][0] = _hash;\n                }\n\n                _hash = hash(_hash, proofSiblings[i]);\n            } else {\n                if (proofSiblings[i] == _filledSubtrees[i][0]) {\n                    _filledSubtrees[i][1] = _hash;\n                }\n\n                _hash = hash(proofSiblings[i], _hash);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        require(updateIndex < LEAVES_NUM, \"BIUT: Leaf index out of range\");\n\n        currentRoot = _hash;\n    }\n\n    /**\n     * @dev Verify if the path is correct and the leaf is part of the tree.\n     * @param leaf Leaf to be updated.\n     * @param proofSiblings Array of the sibling nodes of the proof of membership.\n     * @param proofPathIndices Path of the proof of membership.\n     * @return True or false.\n     */\n    function verify(\n        bytes32 leaf,\n        bytes32[] calldata proofSiblings,\n        uint8[] calldata proofPathIndices\n    ) internal view returns (bool) {\n        require(\n            proofPathIndices.length == TREE_DEPTH &&\n                proofSiblings.length == TREE_DEPTH,\n            \"BIUT: length of path is not correct\"\n        );\n\n        bytes32 _hash = leaf;\n\n        for (uint256 i = 0; i < TREE_DEPTH; ) {\n            require(\n                proofPathIndices[i] == 1 || proofPathIndices[i] == 0,\n                \"IncrementalBinaryTree: path index is neither 0 nor 1\"\n            );\n\n            if (proofPathIndices[i] == 0) {\n                _hash = hash(_hash, proofSiblings[i]);\n            } else {\n                _hash = hash(proofSiblings[i], _hash);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return _hash == currentRoot;\n    }\n\n    /**\n     * @dev Gettign the next leaf index\n     * @return the leaf index\n     */\n    function getNextLeafIndex() external view returns (uint256) {\n        return uint256(_nextLeafIndex);\n    }\n}\n"
    },
    "contracts/common/binaryTree/BinaryMerkleZeros.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"../../protocol/crypto/SnarkConstants.sol\";\n\n// Content is autogenerated by `lib/binaryMerkleZerosContractGenerator.ts`\n\n/**\n * Example:\n * [4]                                       0\n *                                           |\n * [3]                        0--------------------------------1\n *                            |                                |\n * [2]                0---------------1                 2--------------3\n *                    |               |                 |              |\n * [1]            0-------1       2-------3        4-------5       6-------7\n *               / \\     / \\     / \\     / \\      / \\     / \\     / \\     / \\\n * [0] index:   0   1   2   3   4   5   6   7    8   9   10 11   12 13   14 15\n *\n *   leaf ID:   0...1   2...3   4...5   6...7    8...8   10..11  12..13  14..15\n *\n * - Number in [] is the \"level index\" that starts from 0 for the leaves level.\n * - Numbers in node/leaf positions are \"node/leaf indices\" which starts from 0\n *   for the leftmost node/leaf of every level.\n * - Numbers bellow leaves are IDs of leaves.\n */\n\n// @notice The \"binary binary tree\" populated with zero leaf values\nabstract contract BinaryMerkleZeros {\n    // solhint-disable var-name-mixedcase\n\n    // @dev Number of levels in a tree excluding the root level\n    uint256 internal constant TREE_DEPTH = 16;\n\n    // Number of leaves in a branch with the root on the level 1\n    uint256 internal constant TRIAD_SIZE = 2;\n\n    // @dev Leaf zero value\n    bytes32 internal constant ZERO_VALUE = 0x00;\n\n    // Merkle root of a tree that contains zeros only\n    bytes32 internal constant ZERO_ROOT =\n        bytes32(\n            uint256(\n                0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323\n            )\n        );\n\n    // solhint-enable var-name-mixedcase\n\n    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {\n        zeros[0] = bytes32(uint256(0x0));\n        zeros[1] = bytes32(\n            uint256(\n                0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864\n            )\n        );\n        zeros[2] = bytes32(\n            uint256(\n                0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1\n            )\n        );\n        zeros[3] = bytes32(\n            uint256(\n                0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238\n            )\n        );\n        zeros[4] = bytes32(\n            uint256(\n                0x7f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a\n            )\n        );\n        zeros[5] = bytes32(\n            uint256(\n                0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55\n            )\n        );\n        zeros[6] = bytes32(\n            uint256(\n                0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78\n            )\n        );\n        zeros[7] = bytes32(\n            uint256(\n                0x78295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d\n            )\n        );\n        zeros[8] = bytes32(\n            uint256(\n                0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61\n            )\n        );\n        zeros[9] = bytes32(\n            uint256(\n                0xe884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747\n            )\n        );\n        zeros[10] = bytes32(\n            uint256(\n                0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2\n            )\n        );\n        zeros[11] = bytes32(\n            uint256(\n                0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636\n            )\n        );\n        zeros[12] = bytes32(\n            uint256(\n                0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a\n            )\n        );\n        zeros[13] = bytes32(\n            uint256(\n                0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0\n            )\n        );\n        zeros[14] = bytes32(\n            uint256(\n                0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c\n            )\n        );\n        zeros[15] = bytes32(\n            uint256(\n                0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92\n            )\n        );\n    }\n}\n"
    },
    "contracts/common/Bytecode.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// SPDX-FileCopyrightText: Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\npragma solidity ^0.8.16;\n\n/**\n * @notice Read bytecode at given address from given position.\n */\nlibrary Bytecode {\n    function read(address pointer, uint256 offset)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        uint256 size = pointer.code.length;\n        require(size >= offset, \"OUT_OF_BOUNDS\");\n\n        unchecked {\n            size -= offset;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            data := mload(0x40)\n\n            // Update the free memory pointer to prevent overriding our data.\n            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).\n            // Adding 31 to size and running the result through the logic above ensures\n            // the memory pointer remains word-aligned, following the Solidity convention.\n            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))\n\n            // Store the size of the data in the first 32 byte chunk of free memory.\n            mstore(data, size)\n\n            // Copy the code into memory right after the 32 bytes we used to store the size.\n            extcodecopy(pointer, add(data, 32), offset, size)\n        }\n    }\n}\n"
    },
    "contracts/common/Claimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./TransferHelper.sol\";\n\n/**\n * @title Claimable\n * @notice It withdraws accidentally sent tokens or ETH from this contract.\n */\nabstract contract Claimable {\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    function _claimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // withdraw ERC20\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (token == address(0)) {\n            // withdraw ETH\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            // withdraw ERC20\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n    }\n}\n"
    },
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/EIP712SignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nabstract contract EIP712SignatureVerifier {\n    bytes private constant EIP191_VERSION = \"\\x19\\x01\";\n\n    string public constant EIP712_NAME = \"Panther Protocol\";\n    string public constant EIP712_VERSION = \"1\";\n\n    // keccak256(bytes(\"PANTHER_EIP712_DOMAIN_SALT\"));\n    bytes32 public constant EIP712_SALT =\n        0x44b818e3e3a12ecf805989195d8f38e75517386006719e2dbb1443987a34db7b;\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n            )\n        );\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(bytes(EIP712_NAME)),\n                    keccak256(bytes(EIP712_VERSION)),\n                    block.chainid,\n                    address(this),\n                    EIP712_SALT\n                )\n            );\n    }\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address signer) {\n        signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA invalid signature\");\n    }\n\n    function toTypedDataHash(bytes32 structHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    EIP191_VERSION,\n                    getDomainSeperator(),\n                    structHash\n                )\n            );\n    }\n}\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/mocks/FakePrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\n/// @dev It simulates (but not precisely!!!) `IPrpGrantor`.\ncontract FakePrpGrantor {\n    // mapping from \"grantee\" to the PRP amount that may be \"used\"\n    mapping(address => uint256) private _unusedPrpGrants;\n\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        returns (uint256 prpAmount)\n    {\n        return _unusedPrpGrants[grantee];\n    }\n\n    function issueOwnerGrant(address grantee, uint256 prpAmount) external {\n        unchecked {\n            if (prpAmount != 0) {\n                uint256 newBalance = _unusedPrpGrants[grantee] + prpAmount;\n                _unusedPrpGrants[grantee] = newBalance;\n            }\n        }\n    }\n\n    event DebugRedeem(address grantee, uint256 prpAmount);\n\n    function redeemGrant(address grantee, uint256 prpAmount) external {\n        emit DebugRedeem(grantee, prpAmount);\n    }\n}\n"
    },
    "contracts/common/mocks/MockBinaryIncrementalUpdatableMerkleTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../binaryTree/BinaryIncrementalUpdatableMerkleTree.sol\";\n\ncontract MockBinaryIncrementalUpdatableMerkleTree is\n    BinaryIncrementalUpdatableMerkleTree\n{\n    function internalFilledSubtrees(uint256 level)\n        external\n        view\n        returns (bytes32[2] memory)\n    {\n        return _filledSubtrees[level];\n    }\n\n    function internalInsert(bytes32 leaf) external returns (uint256) {\n        return insert(leaf);\n    }\n}\n"
    },
    "contracts/common/mocks/MockFxPortal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../TransferHelper.sol\";\nimport \"../ImmutableOwnable.sol\";\n\nimport \"../../staking/interfaces/IFxStateSender.sol\";\nimport \"../../staking/interfaces/IFxMessageProcessor.sol\";\n\ninterface IPZkp {\n    function deposit(address user, bytes calldata depositData) external;\n}\n\ninterface IRootChainManager {\n    function depositFor(\n        address receiver,\n        address token,\n        bytes calldata depositData\n    ) external;\n}\n\ncontract MockFxPortal is ImmutableOwnable, IRootChainManager, IFxStateSender {\n    using TransferHelper for address;\n\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n    address public immutable PZKP_TOKEN;\n    address public immutable ZKP_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    event DepositForLog(address receiver, address token, bytes depositData);\n    event SendMessageToChildLog(address _receiver, bytes _data);\n    event ProcessMessageFromRootLog(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes data\n    );\n\n    constructor(\n        address _owner,\n        address _zkpToken,\n        address _pZkpToken\n    ) ImmutableOwnable(_owner) {\n        require(\n            _zkpToken != address(0) && _pZkpToken != address(0),\n            \"init: zero address\"\n        );\n\n        ZKP_TOKEN = _zkpToken;\n        PZKP_TOKEN = _pZkpToken;\n    }\n\n    // simulate message bridging\n    function sendMessageToChild(address receiver, bytes calldata data)\n        external\n    {\n        IFxMessageProcessor(receiver).processMessageFromRoot(\n            uint256(0), // stateId\n            msg.sender, // rootMessageSender\n            data // content\n        );\n\n        emit SendMessageToChildLog(receiver, data);\n    }\n\n    // simulate token bridging\n    function depositFor(\n        address receiver,\n        address token,\n        bytes calldata depositData\n    ) external {\n        require(token == ZKP_TOKEN, \"MOCKFX::depositFor: invalid token\");\n\n        uint256 amount = abi.decode(depositData, (uint256));\n        require(amount > 0, \"MOCKFX::depositFor: zero amount\");\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        IPZkp(PZKP_TOKEN).deposit(receiver, depositData);\n\n        emit DepositForLog(receiver, token, depositData);\n    }\n}\n"
    },
    "contracts/common/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title NonReentrant\n * @notice It provides reentrancy guard.\n * The code borrowed from openzeppelin-contracts.\n * Unlike original, this version requires neither `constructor` no `init` call.\n */\nabstract contract NonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    modifier nonReentrant() {\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\n        // it does not revert (which is expected behaviour)\n        require(_reentrancyStatus != _ENTERED, \"claimErc20: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/common/proxy/EIP173Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./Proxy.sol\";\n\ninterface ERC165 {\n    function supportsInterface(bytes4 id) external view returns (bool);\n}\n\n///@notice Proxy implementing EIP173 for ownership management\ncontract EIP173Proxy is Proxy {\n    // ////////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    // /////////////////////// CONSTRUCTOR //////////////////////////////////////////////////////////////////////\n\n    constructor(\n        address implementationAddress,\n        address ownerAddress,\n        bytes memory data\n    ) payable {\n        _setImplementation(implementationAddress, data);\n        _setOwner(ownerAddress);\n    }\n\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n    function owner() external view returns (address) {\n        return _owner();\n    }\n\n    function supportsInterface(bytes4 id) external view returns (bool) {\n        if (id == 0x01ffc9a7 || id == 0x7f5828d0) {\n            return true;\n        }\n        if (id == 0xFFFFFFFF) {\n            return false;\n        }\n\n        ERC165 implementation;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            implementation := sload(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n            )\n        }\n\n        // Technically this is not standard compliant as ERC-165 require 30,000 gas which that call cannot ensure\n        // because it is itself inside `supportsInterface` that might only get 30,000 gas.\n        // In practise this is unlikely to be an issue.\n        try implementation.supportsInterface(id) returns (bool support) {\n            return support;\n        } catch {\n            return false;\n        }\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    function upgradeTo(address newImplementation) external onlyOwner {\n        _setImplementation(newImplementation, \"\");\n    }\n\n    function upgradeToAndCall(address newImplementation, bytes calldata data)\n        external\n        payable\n        onlyOwner\n    {\n        _setImplementation(newImplementation, data);\n    }\n\n    // /////////////////////// MODIFIERS ////////////////////////////////////////////////////////////////////////\n\n    modifier onlyOwner() {\n        require(msg.sender == _owner(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\n\n    function _owner() internal view returns (address adminAddress) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            adminAddress := sload(\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\n            )\n        }\n    }\n\n    function _setOwner(address newOwner) internal {\n        address previousOwner = _owner();\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(\n                0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                newOwner\n            )\n        }\n        emit OwnershipTransferred(previousOwner, newOwner);\n    }\n}\n"
    },
    "contracts/common/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-inline-assembly, avoid-low-level-calls\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// EIP-1967\nabstract contract Proxy {\n    // /////////////////////// EVENTS ///////////////////////////////////////////////////////////////////////////\n\n    event ProxyImplementationUpdated(\n        address indexed previousImplementation,\n        address indexed newImplementation\n    );\n\n    // ///////////////////// EXTERNAL ///////////////////////////////////////////////////////////////////////////\n\n    receive() external payable virtual {\n        revert(\"ETHER_REJECTED\"); // explicit reject by default\n    }\n\n    fallback() external payable {\n        _fallback();\n    }\n\n    // ///////////////////////// INTERNAL //////////////////////////////////////////////////////////////////////\n\n    function _fallback() internal {\n        assembly {\n            let implementationAddress := sload(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n            )\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                gas(),\n                implementationAddress,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n            case 0 {\n                revert(0, retSz)\n            }\n            default {\n                return(0, retSz)\n            }\n        }\n    }\n\n    function _setImplementation(address newImplementation, bytes memory data)\n        internal\n    {\n        address previousImplementation;\n        assembly {\n            previousImplementation := sload(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n            )\n        }\n\n        assembly {\n            sstore(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                newImplementation\n            )\n        }\n\n        emit ProxyImplementationUpdated(\n            previousImplementation,\n            newImplementation\n        );\n\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            if (!success) {\n                assembly {\n                    // This assembly ensure the revert contains the exact string data\n                    let returnDataSize := returndatasize()\n                    returndatacopy(0, 0, returnDataSize)\n                    revert(0, returnDataSize)\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/common/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title TransferHelper library\n/// @dev Helper methods for interacting with ERC20, ERC721, ERC1155 tokens and sending ETH\n/// Based on the Uniswap/solidity-lib/contracts/libraries/TransferHelper.sol\nlibrary TransferHelper {\n    /// @dev Throws if the deployed code of the `token` is empty.\n    // Low-level CALL to a non-existing contract returns `success` of 1 and empty `data`.\n    // It may be misinterpreted as a successful call to a deployed token contract.\n    // So, the code calling a token contract must insure the contract code exists.\n    modifier onlyDeployedToken(address token) {\n        uint256 codeSize;\n        // slither-disable-next-line assembly\n        assembly {\n            codeSize := extcodesize(token)\n        }\n        require(codeSize > 0, \"TransferHelper: zero codesize\");\n        _;\n    }\n\n    /// @dev Approve the `operator` to spend all of ERC720 tokens on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeSetApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('setApprovalForAll(address,bool)'));\n            abi.encodeWithSelector(0xa22cb465, operator, approved)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Get the ERC20 balance of `account`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeBalanceOf(address token, address account)\n        internal\n        returns (uint256 balance)\n    {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(bytes('balanceOf(address)')));\n            abi.encodeWithSelector(0x70a08231, account)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: balanceOf call failed\"\n        );\n\n        balance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Get the ERC20 allowance of `spender`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeAllowance(\n        address token,\n        address owner,\n        address spender\n    ) internal onlyDeployedToken(token) returns (uint256 allowance) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(\"allowance(address,address)\"));\n            abi.encodeWithSelector(0xdd62ed3e, owner, spender)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: allowance call failed\"\n        );\n\n        allowance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Approve the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('approve(address,uint256)'));\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Increase approval of the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeIncreaseAllowance(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(\"increaseAllowance(address,uint256)\"));\n            abi.encodeWithSelector(0x39509351, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transfer(address,uint256)'));\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer an ERC721 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc721SafeTransferFrom(\n        address token,\n        uint256 tokenId,\n        address from,\n        address to\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x42842e0e, from, to, tokenId)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `amount` ERC1155 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc1155SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory _data\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'));\n            abi.encodeWithSelector(0xf242432a, from, to, tokenId, amount, _data)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` Ether from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferETH(address to, uint256 value) internal {\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"TransferHelper: ETH transfer failed\");\n    }\n\n    function _requireSuccess(bool success, bytes memory res) private pure {\n        require(\n            success && (res.length == 0 || abi.decode(res, (bool))),\n            \"TransferHelper: token contract call failed\"\n        );\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nabstract contract Utils {\n    // false positive\n    // slither-disable-next-line timestamp\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/common/UtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.16;\n\nlibrary UtilsLib {\n    function safe24(uint256 n) internal pure returns (uint24) {\n        require(n < 2**24, \"UNSAFE24\");\n        return uint24(n);\n    }\n\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        uint256 t = block.timestamp;\n        require(t < 2**32, \"UNSAFE32TIME\");\n        return uint32(t);\n    }\n\n    function safe32BlockNow() internal view returns (uint32) {\n        uint256 b = block.number;\n        require(b < 2**32, \"UNSAFE32BLOCK\");\n        return uint32(b);\n    }\n\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/protocol/crypto/BabyJubJub.sol": {
      "content": "// SPDX-License-Identifier: GPL\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// Implementer name - yondonfu\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\npragma solidity ^0.8.16;\nimport \"../../common/Types.sol\";\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\n\nlibrary BabyJubJub {\n    // Curve parameters\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\n    // A = 168700\n    uint256 public constant A = 0x292FC;\n    // D = 168696\n    uint256 public constant D = 0x292F8;\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    // slither-disable-next-line too-many-digits\n    uint256 public constant Q =\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\n\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\n    // That is, it generates the set of points of order l and origin O.\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_X =\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_Y =\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n    // pm1d2 = (SNARK_FIELD - 1) >> 1 // same as `negative_one / 2\n    // slither-disable-next-line too-many-digits\n    uint256 public constant PM1D2 =\n        10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n    // TODO: remove dependency on BabyJubJub as a standalone contract\n    function pointPack(G1Point memory point)\n        internal\n        pure\n        returns (bytes32 _packed)\n    {\n        _packed = bytes32(point.y);\n\n        if (point.x > PM1D2) {\n            _packed = bytes32(\n                point.y |\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n            );\n        }\n    }\n\n    /**\n     * @dev Add 2 points on baby jubjub curve\n     * Formulae for adding 2 points on a twisted Edwards curve:\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\n     */\n    function pointAdd(G1Point memory g1, G1Point memory g2)\n        internal\n        view\n        returns (G1Point memory)\n    {\n        uint256 x3 = 0;\n        uint256 y3 = 0;\n        if (g1.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        if (g2.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\n\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\n        return G1Point(x3, y3);\n    }\n\n    /**\n     * @dev Perform modular subtraction\n     */\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        uint256 aNN = _a;\n\n        if (_a <= _b) {\n            aNN += _mod;\n        }\n\n        return addmod(aNN - _b, 0, _mod);\n    }\n\n    /**\n     * @dev Compute modular inverse of a number\n     */\n    function inverse(uint256 _a) internal view returns (uint256) {\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\n        return expmod(_a, Q - 2, Q);\n    }\n\n    /**\n     * @dev Helper function to call the bigModExp precompile\n     */\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20) // Length of base _b\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\n            mstore(add(memPtr, 0x60), _b) // Base _b\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\n\n            // The bigModExp precompile is at 0x05\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n        // solhint-enable no-inline-assembly\n    }\n\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        r.x = 0;\n        r.y = 1;\n\n        uint256 rem = scalar;\n        G1Point memory exp = point;\n\n        while (rem != uint256(0)) {\n            if ((rem & 1) == 1) {\n                r = pointAdd(r, exp);\n            }\n            exp = pointAdd(exp, exp);\n            rem = rem >> 1;\n        }\n        r.x = r.x % Q;\n        r.y = r.y % Q;\n\n        return r;\n    }\n\n    function isG1PointLowerThanFieldSize(uint256[2] memory point)\n        internal\n        pure\n        returns (bool)\n    {\n        return point[0] <= FIELD_SIZE && point[1] <= FIELD_SIZE;\n    }\n}\n"
    },
    "contracts/protocol/crypto/ElGamal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BabyJubJub.sol\";\nimport \"../../common/Types.sol\";\n\ncontract ElGamalEncryption {\n    function add(ElGamalCiphertext memory ct1, ElGamalCiphertext memory ct2)\n        external\n        view\n        returns (ElGamalCiphertext memory ct3)\n    {\n        ct3.c1 = BabyJubJub.pointAdd(ct1.c1, ct2.c1);\n        ct3.c2 = BabyJubJub.pointAdd(ct1.c2, ct2.c2);\n    }\n}\n"
    },
    "contracts/protocol/crypto/EllipticCurveMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport { G1Point, G2Point } from \"../../common/Types.sol\";\nimport { PRIME_Q } from \"./SnarkConstants.sol\";\n\n/// @dev This is slightly modified `library Paring` generated by the `snarkjs` lib (v.0.6.9).\nabstract contract EllipticCurveMath {\n    /// @return the generator of G1\n    function P1() internal pure returns (G1Point memory) {\n        return G1Point(1, 2);\n    }\n\n    /// @return the generator of G2\n    function P2() internal pure returns (G2Point memory) {\n        return\n            G2Point(\n                [\n                    11559732032986387107991004021392285783925812861821192530917403151452391805634,\n                    10857046999023057135944570762232829481370756359578518086990519993285655852781\n                ],\n                [\n                    4082367875863433681332203403145435568316851327593401208105741076214120093531,\n                    8495653923123431417604973247489272438418190587263600148770280649306958101930\n                ]\n            );\n    }\n\n    /// @return r the negation of p, i.e. p.addition(p.negate()) should be zero.\n    function negate(G1Point memory p) internal pure returns (G1Point memory r) {\n        if (p.x == 0 && p.y == 0) return G1Point(0, 0);\n        return G1Point(p.x, PRIME_Q - (p.y % PRIME_Q));\n    }\n\n    /// @return r the sum of two points of G1\n    function addition(G1Point memory p1, G1Point memory p2)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        uint256[4] memory input;\n        input[0] = p1.x;\n        input[1] = p1.y;\n        input[2] = p2.x;\n        input[3] = p2.y;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, input, 0xc0, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-add-failed\");\n    }\n\n    /// @return r the product of a point on G1 and a scalar, i.e.\n    /// p == p.scalar_mul(1) and p.addition(p) == p.scalar_mul(2) for all points p.\n    function scalar_mul(G1Point memory p, uint256 s)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        uint256[3] memory input;\n        input[0] = p.x;\n        input[1] = p.y;\n        input[2] = s;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 7, input, 0x80, r, 0x60)\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-mul-failed\");\n    }\n\n    /// @return the result of computing the pairing check\n    /// e(p1[0], p2[0]) *  .... * e(p1[n], p2[n]) == 1\n    /// For example pairing([P1(), P1().negate()], [P2(), P2()]) should\n    /// return true.\n    function pairing(G1Point[] memory p1, G2Point[] memory p2)\n        internal\n        view\n        returns (bool)\n    {\n        require(p1.length == p2.length, \"pairing-lengths-failed\");\n        uint256 elements = p1.length;\n        uint256 inputSize = elements * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        for (uint256 i = 0; i < elements; i++) {\n            input[i * 6 + 0] = p1[i].x;\n            input[i * 6 + 1] = p1[i].y;\n            input[i * 6 + 2] = p2[i].x[0];\n            input[i * 6 + 3] = p2[i].x[1];\n            input[i * 6 + 4] = p2[i].y[0];\n            input[i * 6 + 5] = p2[i].y[1];\n        }\n        uint256[1] memory out;\n        bool success;\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            success := staticcall(\n                sub(gas(), 2000),\n                8,\n                add(input, 0x20),\n                mul(inputSize, 0x20),\n                out,\n                0x20\n            )\n            // Use \"invalid\" to make gas estimation work\n            switch success\n            case 0 {\n                invalid()\n            }\n        }\n        require(success, \"pairing-opcode-failed\");\n        return out[0] != 0;\n    }\n\n    /// Convenience method for a pairing check for four pairs.\n    function pairingProd4(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2,\n        G1Point memory c1,\n        G2Point memory c2,\n        G1Point memory d1,\n        G2Point memory d2\n    ) internal view returns (bool) {\n        G1Point[] memory p1 = new G1Point[](4);\n        G2Point[] memory p2 = new G2Point[](4);\n        p1[0] = a1;\n        p1[1] = b1;\n        p1[2] = c1;\n        p1[3] = d1;\n        p2[0] = a2;\n        p2[1] = b2;\n        p2[2] = c2;\n        p2[3] = d2;\n        return pairing(p1, p2);\n    }\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/PoseidonHashers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\nimport \"./Poseidon.sol\";\n\nlibrary PoseidonHashers {\n    string private constant ERR_INPUT_NOT_IN_FIELD =\n        \"PoseidonHasher: input not in field\";\n\n    function poseidonT3(bytes32[2] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE && uint256(input[1]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT3.poseidon(input);\n    }\n\n    function poseidonT4(bytes32[3] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT4.poseidon(input);\n    }\n\n    function poseidonT5(bytes32[4] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT5.poseidon(input);\n    }\n\n    function poseidonT6(bytes32[5] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE &&\n                uint256(input[4]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT6.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// FIXME: make MAGICAL_CONSTRAINT the public input (var, not const) - it MUST have random value on every invocation\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/errMsgs/CachedRootsErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_EMPTY_CACHE = \"CR:E1\";\nstring constant ERR_INDEX_NOT_IN_RANGE = \"CR:E2\";\n"
    },
    "contracts/protocol/errMsgs/PantherBusTreeErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"PBT:E1\";\nstring constant ERR_UNAUTHORIZED = \"PBT:E2\";\nstring constant ERR_ZERO_REWARD_PARAMS = \"PBT:E3\";\n"
    },
    "contracts/protocol/errMsgs/PantherPoolErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// CommitmentGenerator contract\nstring constant ERR_TOO_LARGE_PUBKEY = \"CG:E1\";\n\n// CommitmentsTrees contract\nstring constant ERR_TOO_LARGE_COMMITMENTS = \"CT:E1\"; // commitment exceeds maximum scalar field size\n\n// MerkleProofVerifier\nstring constant ERR_MERKLE_PROOF_VERIFICATION_FAILED = \"MP:E1\";\nstring constant ERR_TRIAD_INDEX_MIN_VALUE = \"MP:E2\";\nstring constant ERR_TRIAD_INDEX_MAX_VALUE = \"MP:E3\";\n\n// TriadIncrementalMerkleTrees contract\nstring constant ERR_ZERO_ROOT = \"TT:E1\"; // merkle tree root can not be zero\n\n// PantherPool contract\nstring constant ERR_DEPOSIT_OVER_LIMIT = \"PP:E1\";\nstring constant ERR_DEPOSIT_FROM_ZERO_ADDRESS = \"PP:E2\";\nstring constant ERR_EXITCOMMIT_EXISTS = \"PP:E32\";\nstring constant ERR_EXITCOMMIT_LOCKED = \"PP:E33\";\nstring constant ERR_EXITCOMMIT_MISSING = \"PP:E34\";\nstring constant ERR_EXPIRED_TX_TIME = \"PP:E3\";\nstring constant ERR_INVALID_JOIN_INPUT = \"PP:E4\";\nstring constant ERR_INVALID_PROOF = \"PP:E5\";\nstring constant ERR_MISMATCHED_ARR_LENGTH = \"PP:E6\";\nstring constant ERR_PLUGIN_FAILURE = \"PP:E7\";\nstring constant ERR_SPENT_NULLIFIER = \"PP:E8\";\nstring constant ERR_TOO_EARLY_CREATED_AT = \"PP:E9\";\nstring constant ERR_TOO_EARLY_EXIT = \"PP:E30\";\nstring constant ERR_TOO_LARGE_AMOUNT = \"PP:E10\";\nstring constant ERR_TOO_LARGE_COMMITMENT = \"PP:E11\";\nstring constant ERR_TOO_LARGE_NULLIFIER = \"PP:E12\";\nstring constant ERR_TOO_LARGE_LEAFID = \"PP:E27\";\nstring constant ERR_TOO_LARGE_PRIVKEY = \"PP:E28\";\nstring constant ERR_TOO_LARGE_ROOT = \"PP:E13\";\nstring constant ERR_TOO_LARGE_SCALED_AMOUNT = \"PP:E26\";\nstring constant ERR_TOO_LARGE_TIME = \"PP:E14\";\nstring constant ERR_UNCONFIGURED_EXIT_TIME = \"PP:E31\";\nstring constant ERR_UNKNOWN_MERKLE_ROOT = \"PP:E16\";\nstring constant ERR_WITHDRAW_OVER_LIMIT = \"PP:E17\";\nstring constant ERR_WITHDRAW_TO_ZERO_ADDRESS = \"PP:E18\";\nstring constant ERR_WRONG_ASSET = \"PP:E19\";\nstring constant ERR_WRONG_DEPOSIT = \"PP:E29\";\nstring constant ERR_WRONG_PRP_SUBID = \"PP:E25\";\nstring constant ERR_ZERO_DEPOSIT = \"PP:E21\";\nstring constant ERR_ZERO_FEE_PAYER = \"PP:E22\";\nstring constant ERR_ZERO_TOKEN_EXPECTED = \"PP:E23\";\nstring constant ERR_ZERO_TOKEN_UNEXPECTED = \"PP:E24\";\n"
    },
    "contracts/protocol/errMsgs/PantherPoolV1ErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"PP:E1\";\nstring constant ERR_UNAUTHORIZED = \"PP:E2\";\nstring constant ERR_UNDEFINED_CIRCUIT = \"PP:E3\";\nstring constant ERR_INVALID_FOREST_ROOT = \"PP:E4\";\nstring constant ERR_FAILED_ZK_PROOF = \"PP:E5\";\nstring constant ERR_INVALID_CREATE_TIME = \"PP:E6\";\nstring constant ERR_ZERO_ZACCOUNT_NULLIFIER = \"PP:E7\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"PP:E8\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"PP:E9\";\nstring constant ERR_ZERO_SALT_HASH = \"PP:E10\";\nstring constant ERR_ZERO_MAGIC_CONSTR = \"PP:E11\";\nstring constant ERR_NOT_WELLFORMED_SECRETS = \"PP:E12\";\n"
    },
    "contracts/protocol/errMsgs/ProvidersKeysErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT_CONTRACT = \"PK:init\";\n\nstring constant ERR_NOT_IN_FIELD = \"PK:E01\";\nstring constant ERR_INCORRECT_SIBLINGS_SIZE = \"PK:E02\";\n\nstring constant ERR_TREE_LOCK_ALREADY_UPDATED = \"ZAR:E05\";\nstring constant ERR_TREE_IS_LOCKED = \"PK:E06\";\n\nstring constant ERR_INSUFFICIENT_ALLOCATION = \"PK:E10\";\nstring constant ERR_TOO_HIGH_ALLOCATION = \"PK:E11\";\n\nstring constant ERR_KEYRING_ALREADY_ACTIVATED = \"PK:15\";\nstring constant ERR_KEYRING_NOT_EXISTS = \"PK:E16\";\nstring constant ERR_KEYRING_NOT_ACTIVATED = \"PK:E17\";\n\nstring constant ERR_UNAUTHORIZED_OPERATOR = \"PK:E20\";\nstring constant ERR_ZERO_OPERATOR_ADDRESS = \"PK:E21\";\nstring constant ERR_SAME_OPERATOR = \"PK:E22\";\n\nstring constant ERR_REVOKED_KEY = \"PK:E25\";\nstring constant ERR_INVALID_KEY_EXPIRY = \"PK:E26\";\nstring constant ERR_KEY_IS_NOT_IN_KEYRING = \"PK:E27\";\n"
    },
    "contracts/protocol/errMsgs/PrpGrantorErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_ZERO_PROCESSOR_ADDR = \"GR:E0\";\nstring constant ERR_ZERO_CURATOR_ADDR = \"GR:E1\";\nstring constant ERR_ZERO_GRANTEE_ADDR = \"GR:E2\";\nstring constant ERR_GRANT_TYPE_EXISTS = \"GR:E3\";\nstring constant ERR_UNEXPECTED_GRANT_RECEIPIENT = \"GR:E4\";\nstring constant ERR_LOW_GRANT_BALANCE = \"GR:E5\";\nstring constant ERR_UKNOWN_GRANT_TYPE = \"GR:E6\";\nstring constant ERR_TOO_LARGE_GRANT_AMOUNT = \"GR:E7\";\nstring constant ERR_UNDEF_GRANT = \"GR:E8\";\nstring constant ERR_UNAUTHORIZED_CALL = \"GR:Unauthorized\";\n"
    },
    "contracts/protocol/errMsgs/VaultErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INVALID_TOKEN_TYPE = \"VA:E1\";\nstring constant ERR_ZERO_LOCK_TOKEN_ADDR = \"VA:E2\";\nstring constant ERR_ZERO_EXT_ACCOUNT_ADDR = \"VA:E3\";\nstring constant ERR_ZERO_EXT_AMOUNT = \"VA:E4\";\n"
    },
    "contracts/protocol/errMsgs/ZAccountsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT_CONTRACT = \"ZAR:init\";\n\nstring constant ERR_BLACKLIST_ZACCOUNT_ID = \"ZAR:E1\";\nstring constant ERR_BLACKLIST_MASTER_EOA = \"ZAR:E2\";\nstring constant ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY = \"ZAR:E3\";\n\nstring constant ERR_DUPLICATED_MASTER_EOA = \"ZAR:E4\";\nstring constant ERR_DUPLICATED_NULLIFIER = \"ZAR:E5\";\n\nstring constant ERR_UNKNOWN_ZACCOUNT = \"ZAR:E6\";\n\nstring constant ERR_MISMATCH_ARRAYS_LENGTH = \"ZAR:E7\";\nstring constant ERR_REPETITIVE_STATUS = \"ZAR:E8\";\n\nstring constant ERR_INVALID_ZACCOUNT_FLAG_POSITION = \"ZAR:E9\";\nstring constant ERR_TOO_LARGE_LEAF_INPUTS = \"ZAR:E10\";\n\nstring constant ERR_INVALID_EXTRA_INPUT_HASH = \"ZAR:E11\";\nstring constant ERR_UNEXPECTED_ZKP_AMOUNT = \"ZAR:E12\";\nstring constant ERR_UNEXPECTED_PRP_AMOUNT = \"ZAR:E13\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"ZAR:E14\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"ZAR:E15\";\n"
    },
    "contracts/protocol/errMsgs/ZAssetsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_ASSET_ALREADY_REGISTERED = \"AR:E1\";\nstring constant ERR_UNKNOWN_ASSET = \"AR:E2\";\nstring constant ERR_WRONG_ASSET_STATUS = \"AR:E3\";\nstring constant ERR_WRONG_ASSET_SCALE = \"AR:E4\";\nstring constant ERR_WRONG_ASSET_VER = \"AR:E5\";\nstring constant ERR_ZERO_SUBID_EXPECTED = \"AR:E6\";\nstring constant ERR_ZERO_TOKEN_ADDRESS = \"AR:E7\";\n"
    },
    "contracts/protocol/interfaces/IBusTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IBusTree {\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue);\n}\n"
    },
    "contracts/protocol/interfaces/IOnboardingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\n\ninterface IOnboardingController {\n    function grantRewards(\n        address _user,\n        uint8 prevStatus,\n        uint8 newStatus,\n        bytes memory _data\n    ) external returns (uint256 _userZkpRewardAlloc);\n}\n"
    },
    "contracts/protocol/interfaces/IPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IPantherPoolV1 {\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256);\n\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IPlugin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IPlugin {\n    function callPlugin(\n        address plugin,\n        uint256 value,\n        bytes calldata callData\n    ) external returns (bool success);\n}\n"
    },
    "contracts/protocol/interfaces/IPrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @title IPrpGrantor\n * @notice Interface for the `PrpGrantor` contract\n * @dev Excluding `onlyOwner` functions\n */\ninterface IPrpGrantor {\n    /// @notice Return the address of the \"grant processor\"\n    /// @dev This account only is authorized to call `redeemGrant`\n    function grantProcessor() external view returns (address);\n\n    /// @notice Returns the total amount (in PRPs) of grants issued so far\n    /// (excluding burnt grants)\n    function totalGrantsIssued() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of grants redeemed so far\n    function totalGrantsRedeemed() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of unused grants for the given grantee\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Returns the PRP amount of the grant specified by a given curator and type\n    function getGrantAmount(address curator, bytes4 grantType)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// defined for the given \"grant type\"\n    /// @return prpAmount The amount (in PRPs) of the grant\n    /// @dev An authorized \"curator\" may call with the enabled (added) \"grant type\" only\n    function issueGrant(address grantee, bytes4 grantType)\n        external\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// specified.\n    /// @dev Only the owner may call.\n    function issueOwnerGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice Burn unused grants for the msg.sender in the specified PRP amount\n    function burnGrant(uint256 prpAmount) external;\n\n    /// @notice Account for redemption of grants in the given amount for the given grantee\n    /// @dev Only the account returned by `grantProcessor()` may call\n    function redeemGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice PRP grant issued\n    event PrpGrantIssued(\n        bytes4 indexed grantType,\n        address grantee,\n        uint256 prpAmount\n    );\n\n    /// @notice PRP grant redeemed (used)\n    event PrpGrantRedeemed(address grantee, uint256 prpAmount);\n\n    /// @notice PRP grant burnt\n    event PrpGrantBurnt(address grantee, uint256 prpAmount);\n\n    /// @notice New grant type added\n    event PrpGrantEnabled(address curator, bytes4 grantType, uint256 prpAmount);\n\n    /// @notice Existing grant type disabled\n    event PrpGrantDisabled(address curator, bytes4 grantType);\n}\n"
    },
    "contracts/protocol/interfaces/IPureFiIssuerRequestResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IPureFiIssuerRequestResolver {\n    function resolveRequest(\n        uint8 _type,\n        uint256 _ruleID,\n        address _signer,\n        address _from,\n        address _to\n    ) external view returns (bool);\n}\n"
    },
    "contracts/protocol/interfaces/IRootsHistory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IRootsHistory {\n    /// @notice Returns `true` if the given root of the given tree is known\n    /// @param cacheIndexHint Index of the root in the cache, ignored if 0\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) external view returns (bool);\n}\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/interfaces/IZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IZAccountsRegistry {\n    function isZAccountWhitelisted(address _masterEOA)\n        external\n        view\n        returns (bool isWhitelisted);\n}\n"
    },
    "contracts/protocol/interfaces/IZAssetsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZAsset } from \"../../common/Types.sol\";\n\ninterface IZAssetsRegistry {\n    /// @dev declared as view rather than pure to allow for protocol changes\n    function getZAssetId(address token, uint256 subId)\n        external\n        view\n        returns (uint160);\n\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        );\n\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        returns (ZAsset memory asset);\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        returns (bool);\n\n    event AssetAdded(uint160 indexed zAssetRecId, ZAsset asset);\n    event AssetStatusChanged(\n        uint160 indexed zAssetRecId,\n        uint8 newStatus,\n        uint8 oldStatus\n    );\n}\n"
    },
    "contracts/protocol/mocks/EllipticCurveMathTester.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../crypto/EllipticCurveMath.sol\";\n\n// On built-in EC math contacts calls costs refer to https://eips.ethereum.org/EIPS/eip-1108\n// (150 gas for ECADD, 6000 for ECMUL, 45000+34000*k for pairing check)\ncontract EllipticCurveMathTester is EllipticCurveMath {\n    function testP1() external pure returns (G1Point memory) {\n        return P1();\n    }\n\n    function testP2() external pure returns (G2Point memory) {\n        return P2();\n    }\n\n    function testNegate(G1Point memory p)\n        external\n        pure\n        returns (G1Point memory r)\n    {\n        return negate(p);\n    }\n\n    function testAddition(G1Point memory p1, G1Point memory p2)\n        external\n        view\n        returns (G1Point memory r)\n    {\n        return addition(p1, p2);\n    }\n\n    function testScalar_mul(G1Point memory p, uint256 s)\n        external\n        view\n        returns (G1Point memory r)\n    {\n        return scalar_mul(p, s);\n    }\n\n    function testPairing(G1Point[] memory p1, G2Point[] memory p2)\n        external\n        view\n        returns (bool)\n    {\n        return pairing(p1, p2);\n    }\n}\n"
    },
    "contracts/protocol/mocks/FakeVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\nimport \"../interfaces/IVault.sol\";\n\ncontract FakeVault is IVault {\n    event DebugData(LockData data);\n\n    function lockAsset(LockData calldata data) external override {\n        emit DebugData(data);\n    }\n\n    function unlockAsset(LockData memory data) external override {\n        emit DebugData(data);\n    }\n}\n"
    },
    "contracts/protocol/mocks/IMockTokens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable no-empty-blocks\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\n// Used with `@defi-wonderland/smock` package to mock token contracts\n\ninterface IMockErc20 is IERC20 {\n\n}\n\ninterface IMockErc721 is IERC721 {}\n\ninterface IMockErc1155 is IERC1155 {}\n"
    },
    "contracts/protocol/mocks/LocalDevEnv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { DEAD_CODE_ADDRESS } from \"../../common/Constants.sol\";\n\ncontract LocalDevEnv {\n    modifier onlyLocalDevEnv() {\n        // DEAD_CODE_ADDRESS is supposed (and must) be and unusable address,\n        // which eliminate risks of using tx.origin here.\n        // solhint-disable-next-line avoid-tx-origin\n        require(tx.origin == DEAD_CODE_ADDRESS, \"Only allowed in forked env\");\n        _;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MerkleProofVerifierTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\nimport \"../pantherPool/MerkleProofVerifier.sol\";\nimport \"../pantherPool/PubKeyGenerator.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\n// solhint-disable state-visibility\ncontract MerkleProofVerifierTester is\n    MerkleProofVerifier,\n    TriadIncrementalMerkleTrees,\n    PubKeyGenerator\n{\n    bool _verifiedProof;\n\n    function testMerkleProof(\n        uint256 leafId,\n        bytes32 merkleRoot,\n        bytes32 commitment,\n        bytes32[TREE_DEPTH + 1] calldata pathElementss\n    ) external {\n        _verifiedProof = false;\n        verifyMerkleProof(\n            merkleRoot,\n            _getTriadIndex(leafId),\n            _getTriadNodeIndex(leafId),\n            commitment,\n            pathElementss\n        );\n        _verifiedProof = true;\n    }\n\n    function isProofVerified() external view returns (bool) {\n        return _verifiedProof;\n    }\n\n    function generatePublicSpendingKey(uint256 privKey)\n        external\n        view\n        returns (uint256[2] memory xy)\n    {\n        G1Point memory p;\n        p = generatePubSpendingKey(privKey);\n        xy[0] = p.x;\n        xy[1] = p.y;\n    }\n\n    uint256 leftLeafId;\n\n    function LeafId() external view returns (uint256) {\n        return leftLeafId;\n    }\n\n    function internalInsertBatch(bytes32[TRIAD_SIZE] memory leaves) external {\n        leftLeafId = insertBatch(leaves);\n    }\n\n    // DONT remove - it can be used to do internal testing of path-elements\n    /*\n    function internalInsertBatchZkp(bytes32[TRIAD_SIZE] memory leaves)\n        external\n    {\n        (leftLeafId, pathElements) = insertBatchZkp(leaves);\n    }\n\n     // DONT remove - can be used in tests - PUT IT INSIDE TriadIncrementalMerkleTree.sol to\n     // accept internal testing of path elements\n    function insertBatchZkp(bytes32[TRIAD_SIZE] memory leaves)\n        internal\n        returns (uint256 leftLeafId, bytes32[TREE_DEPTH] memory pathElements)\n    {\n        leftLeafId = _nextLeafId;\n\n        bytes32[TREE_DEPTH] memory zeros;\n        populateZeros(zeros);\n\n        // index of a \"current\" node (0 for the leftmost node/leaf of a level)\n        uint256 nodeIndex;\n        // hash (value) of a \"current\" node\n        bytes32 nodeHash;\n        // index of a \"current\" level (0 for leaves, increments toward root)\n        uint256 level;\n\n        // subtree from 3 leaves being inserted on `level = 0`\n        nodeHash = hash(leaves[0], leaves[1], leaves[2]);\n        // ... to be placed under this index on `level = 1`\n        // (equivalent to `(leftLeafId % iLEAVES_NUM) / iTRIAD_SIZE`)\n        nodeIndex = (leftLeafId & iLEAVES_NUM_MASK) >> iTRIAD_SIZE_BITS;\n\n        bytes32 left;\n        bytes32 right;\n        for (level = 1; level < TREE_DEPTH; level++) {\n            // if `nodeIndex` is, say, 25, over the iterations it will be:\n            // 25, 12, 6, 3, 1, 0, 0 ...\n\n            if (nodeIndex % 2 == 0) {\n                left = nodeHash;\n                right = zeros[level];\n                _filledSubtrees[level] = nodeHash;\n                pathElements[level - 1] = right;\n            } else {\n                // for a new tree, \"than\" block always run before \"else\" block\n                // so `_filledSubtrees[level]` gets updated before its use\n                left = _filledSubtrees[level];\n                right = nodeHash;\n                pathElements[level - 1] = left;\n            }\n\n            nodeHash = hash(left, right);\n\n            // equivalent to `nodeIndex /= 2`\n            nodeIndex >>= 1;\n        }\n\n        pathElements[TREE_DEPTH - 1] = nodeHash; // root\n\n        uint256 nextLeafId = leftLeafId + iTRIAD_SIZE;\n        _nextLeafId = nextLeafId;\n\n        uint256 treeId = getTreeId(leftLeafId);\n        if (_isFullTree(leftLeafId)) {\n            // Switch to a new tree\n            // Ignore `_filledSubtrees` old values as they are never re-used\n            finalRoots[treeId] = nodeHash;\n            emit AnchoredRoot(treeId, nodeHash);\n        } else {\n            uint256 cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n            _cachedRoots[cacheIndex] = uint256(nodeHash) ^ treeId;\n            emit CachedRoot(treeId, nodeHash);\n        }\n    }\n    // In use only when zkp part is activated\n    bytes32[TREE_DEPTH] pathElements;\n    function PathElements() external view returns (bytes32[TREE_DEPTH] memory) {\n        return pathElements;\n    }\n    */\n}\n"
    },
    "contracts/protocol/mocks/MockAmountConvertor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../pantherPool/AmountConvertor.sol\";\n\ncontract MockAmountConvertor is AmountConvertor {\n    function internalScaleAmount(uint256 amount, uint8 scale)\n        external\n        pure\n        returns (uint96 scaledAmount, uint256 change)\n    {\n        return _scaleAmount(amount, scale);\n    }\n\n    function internalUnscaleAmount(uint64 scaledAmount, uint8 scale)\n        external\n        pure\n        returns (uint96)\n    {\n        return _unscaleAmount(scaledAmount, scale);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockCachedRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../pantherForest/cachedRoots/CachedRoots.sol\";\n\ncontract MockCachedRoots is CachedRoots {\n    function internalCacheNewRoot(bytes32 root)\n        external\n        returns (uint256 cacheIndex)\n    {\n        return cacheNewRoot(root);\n    }\n\n    function internalResetThenCacheNewRoot(bytes32 root)\n        external\n        returns (uint256 cacheIndex)\n    {\n        return resetThenCacheNewRoot(root);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockCommitmentGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../pantherPool/CommitmentGenerator.sol\";\n\ncontract MockCommitmentGenerator is CommitmentGenerator {\n    function internalGenerateCommitment(\n        uint256 pubSpendingKeyX,\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) external pure returns (bytes32 commitment) {\n        return\n            generateCommitment(\n                pubSpendingKeyX,\n                pubSpendingKeyY,\n                scaledAmount,\n                zAssetId,\n                creationTime\n            );\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\n// solhint-disable event-name-camelcase\ncontract MockPantherPoolV0 is PantherPoolV0 {\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) PantherPoolV0(_owner, assetRegistry, vault) {}\n\n    event RESULT_processDepositedAsset(uint160 zAssetId, uint96 scaledAmount);\n\n    function internalProcessDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 extAmount\n    ) external {\n        (uint160 zAssetId, uint96 scaledAmount) = _processDepositedAsset(\n            token,\n            subId,\n            extAmount\n        );\n        emit RESULT_processDepositedAsset(zAssetId, scaledAmount);\n    }\n\n    function testGeneratePublicSpendingKey(uint256 privKey)\n        external\n        view\n        returns (uint256[2] memory xy)\n    {\n        G1Point memory p;\n        p = generatePubSpendingKey(privKey);\n        xy[0] = p.x;\n        xy[1] = p.y;\n    }\n\n    function testUpdateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n    {\n        this.updateExitTimes(newExitTime, newExitDelay);\n    }\n\n    function testExit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external {\n        this.exit(\n            token,\n            subId,\n            scaledAmount,\n            creationTime,\n            privSpendingKey,\n            leafId,\n            pathElements,\n            merkleRoot,\n            cacheIndexHint\n        );\n    }\n\n    function testGenerateCommitments(\n        uint256 pubSpendingKeyX,\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) external pure returns (uint256) {\n        return\n            uint256(\n                generateCommitment(\n                    pubSpendingKeyX,\n                    pubSpendingKeyY,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPubKeyGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport \"../pantherPool/PubKeyGenerator.sol\";\n\ncontract MockPubKeyGenerator is PubKeyGenerator {\n    function internalGeneratePubSpendingKey(uint256 privKey)\n        external\n        view\n        returns (G1Point memory pubKey)\n    {\n        return generatePubSpendingKey(privKey);\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockTriadIncrementalMerkleTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\ncontract MockTriadIncrementalMerkleTrees is TriadIncrementalMerkleTrees {\n    event InternalInsertBatch(uint256 leftLeafId);\n\n    function internal_TREE_DEPTH() external pure returns (uint256) {\n        return TREE_DEPTH;\n    }\n\n    function internal_ZERO_VALUE() external pure returns (bytes32) {\n        return ZERO_VALUE;\n    }\n\n    function internalInsertBatch(bytes32[TRIAD_SIZE] memory leaves) external {\n        uint256 leftLeafId = insertBatch(leaves);\n        emit InternalInsertBatch(leftLeafId);\n    }\n\n    function internalIsFullTree(uint256 nextLeafId)\n        external\n        pure\n        returns (bool)\n    {\n        return _isFullTree(nextLeafId);\n    }\n\n    function internalNextLeafId2LeavesNum(uint256 nextId)\n        external\n        pure\n        returns (uint256)\n    {\n        return _nextLeafId2LeavesNum(nextId);\n    }\n\n    // This function fakes just the '_nextLeafId', but it does not update the history of roots.\n    // If applied to the empty tree, equivalent to inserting ZERO leaves (but the history is empty).\n    // !!! If applied to a non-empty tree, or leaves \"really\" inserted after a \"fake\" insertion,\n    // the tree root will be incorrect.\n    function fakeNextLeafId(uint256 fakeId) external {\n        require((fakeId % 4) == 0, \"fakeId must be a multiple of 4\");\n        _nextLeafId = fakeId;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../ZAccountsRegistry.sol\";\n\ncontract MockZAccountsRegistry is ZAccountsRegistry {\n    uint256 public nextId;\n\n    constructor(\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingRewardController\n    )\n        ZAccountsRegistry(\n            msg.sender,\n            _zAccountVersion,\n            pantherPool,\n            pantherStaticTree,\n            onboardingRewardController\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    function mockZAccountIdTracker(uint256 _zAccountIdTracker) external {\n        zAccountIdTracker = _zAccountIdTracker;\n    }\n\n    function internalGetNextZAccountId() external {\n        nextId = _getNextZAccountId();\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryAndVaultTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"../Vault.sol\";\nimport \"../../common/Types.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistryV0.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MyERC20 is ERC20 {\n    constructor(uint256 index, address owner)\n        ERC20(Strings.toString(index), Strings.toString(index))\n    {\n        uint256 totalSupply = 1024;\n        _mint(owner, totalSupply);\n    }\n    /*\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        console.logString(\" --- TOKEN --- \");\n        console.logString(\"msg.sender\");\n        console.log(msg.sender);\n        console.logString(\"Spender\");\n        console.log(spender);\n        console.logString(\"To\");\n        console.log(to);\n        console.logString(\"From\");\n        console.log(from);\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, scaledAmount);\n        return true;\n    }\n    */\n}\n\n// solhint-disable var-name-mixedcase\ncontract PantherPoolV0AndZAssetRegistryAndVaultTester is MockPantherPoolV0 {\n    address private registry;\n    MyERC20[OUT_UTXOs] private Tokens;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry and Vault\n            registry = address(new ZAssetsRegistryV0(address(this))),\n            address(new Vault(address(this)))\n        )\n    {\n        for (uint256 i = 0; i < OUT_UTXOs; ++i) {\n            Tokens[i] = new MyERC20(i, address(this)); // This mock is an owner of MyERC20\n            ZAsset memory z;\n            z.tokenType = ERC20_TOKEN_TYPE;\n            z.version = 0;\n            z.scale = 0;\n            z.token = address(Tokens[i]);\n            z.status = zASSET_ENABLED;\n            ZAssetsRegistryV0(registry).addZAsset(z);\n        }\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testGetZAssetId(uint256 token, uint256 tokenId)\n        external\n        view\n        returns (uint160)\n    {\n        return\n            ZAssetsRegistryV0(registry).getZAssetId(\n                address(uint160(token)),\n                tokenId\n            );\n    }\n\n    function getTokenAddress(uint256 index) external view returns (address) {\n        return address(Tokens[index]);\n    }\n\n    function approveVault(uint256 amount, uint256 index) external {\n        Tokens[index].approve(VAULT, amount);\n    }\n\n    function generateDepositsExtended(\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        uint256[OUT_UTXOs] memory tokenIds;\n        tokenIds[0] = 0;\n        tokenIds[1] = 0;\n        tokenIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        for (uint256 i = 0; i < OUT_UTXOs; i++) {\n            this.approveVault(extAmounts[i], i);\n        }\n\n        this.generateDeposits(\n            [address(Tokens[0]), address(Tokens[1]), address(Tokens[2])],\n            tokenIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"./FakeVault.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistryV0.sol\";\n\ncontract PantherPoolV0AndZAssetRegistryTester is MockPantherPoolV0 {\n    address private registry;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry\n            registry = address(new ZAssetsRegistryV0(address(this))),\n            address(new FakeVault())\n        )\n    {\n        ZAsset memory z1;\n        z1.tokenType = ERC20_TOKEN_TYPE;\n        z1.version = 0;\n        z1.scale = 0;\n        z1.token = address(uint160(111));\n        z1.status = zASSET_ENABLED;\n        ZAssetsRegistryV0(registry).addZAsset(z1);\n\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testConvert(uint256 n) external pure returns (bytes32) {\n        return bytes32(n);\n    }\n\n    function testGenerateDepositsExtended(\n        address[OUT_UTXOs] calldata tokens,\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        address[OUT_UTXOs] memory tokenss;\n        tokenss[0] = tokens[0];\n        tokenss[1] = tokens[1];\n        tokenss[2] = tokens[2];\n\n        uint256[OUT_UTXOs] memory subIds;\n        subIds[0] = 0;\n        subIds[1] = 0;\n        subIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        this.generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "contracts/protocol/OnboardingController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/TransferHelper.sol\";\nimport { HUNDRED_PERCENT } from \"../common/Constants.sol\";\n\ncontract OnboardingController is ImmutableOwnable {\n    using TransferHelper for address;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant ZERO_REWARD = 0;\n\n    address public immutable ZACCOUNT_REGISTRY;\n    address public immutable ZKP_TOKEN;\n    address public immutable VAULT;\n    address public immutable RESERVE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    struct RewardParams {\n        // reserved bytes\n        uint128 _unused;\n        // kyc provider ratio from zkpRewardsPerActivation\n        uint16 zkpRate;\n        // user ratio from zkpRewardsPerActivation\n        uint16 zZkpRate;\n        // zkp reward to be grant on each call.\n        uint96 rewardsPerGrant;\n    }\n\n    RewardParams public rewardParams;\n\n    uint128 public rewardsGranted;\n    uint128 public rewardsLimit;\n\n    mapping(address => bool) public isUserRewarded;\n\n    event RewardParamsUpdated(\n        uint96 rewardsPerGrant,\n        uint16 zkpRate,\n        uint16 zZkpRate\n    );\n    event RewardsLimtUpdated(uint256 rewardsLimit);\n    event ZzkpAllocated(address user, uint256 amount);\n    event ReserveControllerApproved(uint256 amount);\n\n    constructor(\n        address _owner,\n        address _zkpToken,\n        address _zAccountRegistry,\n        address _vault,\n        address _reserveController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _zAccountRegistry != address(0) &&\n                _zkpToken != address(0) &&\n                _vault != address(0),\n            \"init: zero address\"\n        );\n\n        ZACCOUNT_REGISTRY = _zAccountRegistry;\n        ZKP_TOKEN = _zkpToken;\n        VAULT = _vault;\n        RESERVE_CONTROLLER = _reserveController;\n    }\n\n    function updateRewardParams(\n        uint96 _rewardsPerGrant,\n        uint16 _zkpRate,\n        uint16 _zZkpRate\n    ) external onlyOwner {\n        // if _rewardsPerGrant is defined, then sum of ratios should be 10000\n        // setting _rewardsPerGrant to 0 disables the program\n        require(\n            _rewardsPerGrant == 0 || (_zkpRate + _zZkpRate == HUNDRED_PERCENT),\n            \"invalid zkp ratio\"\n        );\n\n        rewardParams = RewardParams({\n            _unused: uint128(0),\n            zkpRate: _zkpRate,\n            zZkpRate: _zZkpRate,\n            rewardsPerGrant: _rewardsPerGrant\n        });\n\n        emit RewardParamsUpdated(_rewardsPerGrant, _zkpRate, _zZkpRate);\n    }\n\n    function updateRewardsLimitAndVaultAllowance() external {\n        // Getting the current allowance of ReserveController\n        uint256 reserveControllerAllowance = ZKP_TOKEN.safeAllowance(\n            address(this),\n            RESERVE_CONTROLLER\n        );\n        uint256 _rewardsLimit = rewardsLimit;\n\n        // Getting the unused rewards limit\n        uint256 unusedLimit = _rewardsLimit - rewardsGranted;\n\n        // The availabe balance (part of the balance is reserved and will be withdrawn from ReserveController)\n        uint256 available = ZKP_TOKEN.safeBalanceOf(address(this)) -\n            reserveControllerAllowance;\n\n        if (available == unusedLimit) return;\n\n        if (available > unusedLimit) {\n            uint256 newAllocation = available - unusedLimit;\n\n            _rewardsLimit += uint128(newAllocation);\n\n            // Approve the vault to transfer its zZkp portion\n            ZKP_TOKEN.safeIncreaseAllowance(VAULT, newAllocation);\n        } else {\n            // gracefully handle this unexpected situation\n            uint256 shortage = unusedLimit - available;\n\n            _rewardsLimit = _rewardsLimit > shortage\n                ? _rewardsLimit - shortage\n                : 0;\n        }\n\n        rewardsLimit = uint128(_rewardsLimit);\n\n        emit RewardsLimtUpdated(_rewardsLimit);\n    }\n\n    // TODO: review/update OnboardingController.grantRewards\n    // solhint-disable no-unused-vars\n    function grantRewards(\n        address _user,\n        uint8 _prevStatus,\n        uint8 _newStatus,\n        bytes memory _data\n    ) external returns (uint256 _zZkpRewardAlloc) {\n        _zZkpRewardAlloc = 100e18;\n\n        // require(msg.sender == ZACCOUNT_REGISTRY, \"unauthorized\");\n\n        // RewardParams memory _rewardParams = rewardParams;\n\n        // uint256 _rewardsGranted = rewardsGranted +\n        //     (_rewardParams.rewardsPerGrant);\n\n        // if (rewardsLimit >= _rewardsGranted) {\n        //     _zZkpRewardAlloc = _getZzkpRewardsAllocation(_rewardParams, _user);\n\n        //     _increaseReserveControllerAllowance(_rewardParams);\n\n        //     rewardsGranted = uint128(_rewardsGranted);\n        // }\n    }\n\n    // solhint-enable no-unused-vars\n\n    function _getZzkpRewardsAllocation(\n        RewardParams memory _rewardParams,\n        address _user\n    ) private returns (uint256 _zZkpRewardAlloc) {\n        // return 0 if has already got rewarded\n        if (isUserRewarded[_user]) return (_zZkpRewardAlloc);\n\n        // Calculate ZKP rewards allocation\n        _zZkpRewardAlloc =\n            ((_rewardParams.rewardsPerGrant) * _rewardParams.zZkpRate) /\n            HUNDRED_PERCENT;\n\n        if (_zZkpRewardAlloc > ZERO_REWARD) {\n            isUserRewarded[_user] = true;\n\n            emit ZzkpAllocated(_user, _zZkpRewardAlloc);\n        }\n    }\n\n    function _increaseReserveControllerAllowance(\n        RewardParams memory _rewardParams\n    ) private {\n        uint256 _zkpRewardAlloc = ((_rewardParams.rewardsPerGrant) *\n            _rewardParams.zkpRate) / HUNDRED_PERCENT;\n\n        if (_zkpRewardAlloc > ZERO_REWARD) {\n            ZKP_TOKEN.safeIncreaseAllowance(\n                RESERVE_CONTROLLER,\n                _zkpRewardAlloc\n            );\n\n            emit ReserveControllerApproved(_zkpRewardAlloc);\n        }\n    }\n\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/PantherBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IPantherPoolV1.sol\";\n\nimport \"./pantherForest/busTree/BusTree.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\nimport { ERC20_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\nimport \"./errMsgs/PantherBusTreeErrMsgs.sol\";\n\ncontract PantherBusTree is BusTree, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address _pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId, _pantherPool) {\n        require(rewardToken != address(0), ERR_INIT);\n\n        START_TIME = block.timestamp;\n\n        REWARD_TOKEN = rewardToken;\n    }\n\n    // TODO: Remove _perMinuteUtxosLimit after Testnet (required for Stage #0..2 only)\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate, minEmptyQueueAge);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            ERR_ZERO_REWARD_PARAMS\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3([left, right]);\n    }\n\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue)\n    {\n        require(msg.sender == PANTHER_POOL, ERR_UNAUTHORIZED);\n\n        bytes32[] memory utxos = new bytes32[](1);\n        utxos[0] = utxo;\n\n        queueId = _nextQueueId == 0 ? 0 : _nextQueueId - 1;\n        BusQueue memory busQueue = _busQueues[queueId];\n        indexInQueue = busQueue.nUtxos;\n\n        addUtxosToBusQueue(utxos, uint96(basePerUtxoReward));\n    }\n\n    // TODO: Remove simulateAddUtxosToBusQueue after Testnet (required for Stage #0..2 only)\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxosToBusQueue(utxos, uint96(reward));\n    }\n}\n"
    },
    "contracts/protocol/PantherFerryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport { PoseidonT3 } from \"./crypto/Poseidon.sol\";\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\n\n// It's supposed to run on the mainnet only.\n// It keeps roots of the \"Bus\" trees on supported networks.\n// Bridges keepers are expected to:\n// - synchronize \"Bus\" trees roots (which are leafs of this tree)\n// - propagate this tree root to other networks (that results in updating the\n// state of the `PantherForest` contracts on supported network).\ncontract PantherFerryTree is ITreeRootGetter {\n    // Root of root with ZERO trees with depth 32\n    function getRoot() external pure returns (bytes32) {\n        return\n            0x24ab16594d418ca2e66ca284f56a4cb7039c6d8f8e0c3c8f362cf18b5afa19d0;\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint40 remainingBlocks;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) internal _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 internal _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Minimum number of blocks an empty queue must pend processing.\n    uint16 private _minEmptyQueueAge;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate,\n        uint256 minEmptyQueueAge\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums or queue age limit, the `updateParams` call needed.\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    // @return minEmptyQueueAge Min number of blocks an empty queue must pend\n    // processing. For a partially filled queue, it declines linearly with the\n    // number of queue's UTXOs. Full queues are immediately processable.\n    function getParams()\n        external\n        view\n        returns (\n            uint16 reservationRate,\n            uint16 premiumRate,\n            uint16 minEmptyQueueAge\n        )\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n        minEmptyQueueAge = _minEmptyQueueAge;\n    }\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _getQueueRemainingBlocks(q),\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // @param maxLength Maximum number of queues to return\n    // @return queues Queues pending processing, starting from the oldest one\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].remainingBlocks = _getQueueRemainingBlocks(queue);\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    // @dev Refer to return values of the `getParam` function\n    function updateParams(\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        _minEmptyQueueAge = minEmptyQueueAge;\n        emit BusQueueRewardParamsUpdated(\n            reservationRate,\n            premiumRate,\n            minEmptyQueueAge\n        );\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        internal\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        require(_getQueueRemainingBlocks(queue) == 0, \"BQT:IMMATURE_QUEUE\");\n\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    // Returns the number of blocks to wait until a queue may be processed.\n    // Always returns 0 for a fully populated queue (immediately processable).\n    // For an empty queue it returns a meaningless value.\n    function _getQueueRemainingBlocks(BusQueue memory queue)\n        private\n        view\n        returns (uint40)\n    {\n        if (queue.nUtxos >= QUEUE_MAX_SIZE) return 0;\n\n        // Minimum \"age\" declines linearly to the number of UTXOs in the queue\n        uint256 nEmptySeats = uint256(QUEUE_MAX_SIZE - queue.nUtxos);\n        uint256 minAge = (nEmptySeats * _minEmptyQueueAge) / QUEUE_MAX_SIZE;\n\n        uint256 maturityBlock = minAge + queue.firstUtxoBlock;\n        return\n            block.number >= maturityBlock\n                ? 0 // Overflow risk ignored\n                : uint40(maturityBlock - block.number);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\n// TODO: remove MAGICAL_CONSTRAINT as a constant and make it a pub input var\nimport { BUS_TREE_FOREST_LEAF_INDEX } from \"../Constants.sol\";\nimport { MAGICAL_CONSTRAINT } from \"../../crypto/SnarkConstants.sol\";\nimport \"../interfaces/ITreeRootUpdater.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n */\nabstract contract BusTree is BusQueues, ITreeRootGetter {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    bytes32 internal constant EMPTY_BUS_TREE_ROOT =\n        TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT;\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(\n        address _verifier,\n        uint160 _circuitId,\n        address _pantherPool\n    ) {\n        require(_pantherPool != address(0), \"init: zero address\");\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            \"BT:INVALID_VK\"\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function getRoot` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n\n        PANTHER_POOL = _pantherPool;\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return _busTreeRoot == bytes32(0) ? EMPTY_BUS_TREE_ROOT : _busTreeRoot;\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        bytes32 busTreeNewRoot,\n        bytes32 batchRoot,\n        bytes32 busBranchNewRoot,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        uint32 nBatches = _numBatchesInBusTree;\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n\n        // Circuit public input signals\n        uint256[] memory input = new uint256[](9);\n        // `oldRoot` signal\n        input[0] = uint256(getRoot());\n        // `newRoot` signal\n        input[1] = uint256(busTreeNewRoot);\n        // `replacedNodeIndex` signal\n        input[2] = nBatches;\n        // `newLeafsCommitment` signal\n        input[3] = uint256(commitment);\n        // `nNonEmptyNewLeafs` signal\n        input[4] = uint256(nUtxos);\n        // `batchRoot` signal\n        input[5] = uint256(batchRoot);\n        // `branchRoot` signal\n        input[6] = uint256(busBranchNewRoot);\n        // `extraInput` signal (front-run protection)\n        input[7] = uint256(uint160(miner));\n        // magicalConstraint\n        input[8] = MAGICAL_CONSTRAINT;\n\n        // Verify the proof\n        require(VERIFIER.verify(CIRCUIT_ID, input, proof), \"BT:FAILED_PROOF\");\n\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        ITreeRootUpdater(PANTHER_POOL).updateRoot(\n            busTreeNewRoot,\n            BUS_TREE_FOREST_LEAF_INDEX\n        );\n\n        // Store updated Bus Tree params\n        _busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/cachedRoots/CachedRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../../errMsgs/CachedRootsErrMsgs.sol\";\n\n/// @dev It caches roots in a ring buffer and checks if a root is in the cache\nabstract contract CachedRoots {\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // Must be a power of 2\n    uint256 private constant CACHE_SIZE = 2**8;\n    uint256 private constant CACHE_INDEX_MASK = CACHE_SIZE - 1;\n\n    uint256 public constant UNDEFINED_CACHE_INDEX = 0xFFFF;\n    // solhint-enable var-name-mixedcase\n\n    // Initial value of all storage params is 0.\n    // So, no initialization in `constructor` required.\n\n    /// @dev Mapping from cache \"index\" to cached root value\n    mapping(uint256 => bytes32) private _cachedRoots;\n    // Total number of roots cached so far\n    uint64 private _cachedRootsCounter;\n    // Value of _cachedRootsCounter after the latest cache reset\n    uint64 private _cacheStartPos;\n\n    function getCacheStats()\n        external\n        view\n        returns (uint256 numRootsCached, uint256 latestCacheIndex)\n    {\n        uint256 nextInd = _getCacheNextIndex(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n        require(nextInd != 0, ERR_EMPTY_CACHE);\n\n        latestCacheIndex = --nextInd;\n        numRootsCached = _getCachedRootsNum(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n    }\n\n    function isCachedRoot(bytes32 root, uint256 cacheIndex)\n        public\n        view\n        returns (bool isCached)\n    {\n        uint256 nextPos = _cachedRootsCounter;\n        // Definitely NOT in the cache, if no roots have been cached yet\n        if (nextPos == 0) return false;\n\n        isCached = false;\n        uint256 startPos = _cacheStartPos;\n        uint256 rootsNum = _getCachedRootsNum(nextPos, startPos);\n\n        if (cacheIndex == UNDEFINED_CACHE_INDEX) {\n            // Iterate through cached roots, starting from the newest one\n            uint256 endPos = nextPos - rootsNum;\n            while (!isCached && nextPos > endPos) {\n                unchecked {\n                    nextPos--;\n                }\n                if (\n                    _cachedRoots[_getCacheNextIndex(nextPos, startPos)] == root\n                ) {\n                    isCached = true;\n                }\n            }\n        } else {\n            // Check against the value cached at the given index\n            require(cacheIndex < rootsNum, ERR_INDEX_NOT_IN_RANGE);\n            isCached = _cachedRoots[cacheIndex] == root;\n        }\n    }\n\n    function cacheNewRoot(bytes32 root) internal returns (uint256 cacheIndex) {\n        cacheIndex = _addRootToCache(root);\n    }\n\n    function resetThenCacheNewRoot(bytes32 root)\n        internal\n        returns (uint256 cacheIndex)\n    {\n        _cacheStartPos = _cachedRootsCounter;\n        cacheIndex = _addRootToCache(root);\n    }\n\n    /// Private functions follow\n\n    function _addRootToCache(bytes32 root)\n        private\n        returns (uint256 cacheIndex)\n    {\n        uint64 counter = _cachedRootsCounter;\n        uint64 startPos = _cacheStartPos;\n\n        cacheIndex = _getCacheNextIndex(counter, startPos);\n        _cachedRoots[cacheIndex] = root;\n\n        _cachedRootsCounter = ++counter;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCachedRootsNum(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 nSinceStart = counter - startPos;\n        return (nSinceStart > CACHE_SIZE) ? CACHE_SIZE : nSinceStart;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCacheNextIndex(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        return (counter - startPos) & CACHE_INDEX_MASK;\n    }\n\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private _trailingGap;\n}\n"
    },
    "contracts/protocol/pantherForest/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// `PantherForest` tree leafs indices (leafs store specific merkle trees roots)\nuint256 constant TAXI_TREE_FOREST_LEAF_INDEX = 0;\nuint256 constant BUS_TREE_FOREST_LEAF_INDEX = 1;\nuint256 constant FERRY_TREE_FOREST_LEAF_INDEX = 2;\nuint256 constant STATIC_TREE_FOREST_LEAF_INDEX = 3;\n\n// `PantherStaticTree` leafs indices (leafs store specific merkle trees roots)\nuint256 constant ZASSET_STATIC_LEAF_INDEX = 0;\nuint256 constant ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX = 1;\nuint256 constant ZNETWORK_STATIC_LEAF_INDEX = 2;\nuint256 constant ZZONE_STATIC_LEAF_INDEX = 3;\nuint256 constant PROVIDERS_KEYS_STATIC_LEAF_INDEX = 4;\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootGetter {\n    function getRoot() external view returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootUpdater {\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryIncrementalTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstruct BinaryTree {\n    uint8 depth;\n    uint32 nLeafs;\n    bytes32 root;\n}\n\nabstract contract BinaryIncrementalTree {\n    function insertLeafs(BinaryTree storage tree, bytes32[] memory leafs)\n        internal\n        returns (uint256 firstLeafIndex, bytes32 newRoot)\n    {\n        // TODO: implement BinaryIncrementalTree::insertLeafs\n        return (0, 0);\n    }\n\n    function insertLeaf(BinaryTree storage tree, bytes32 leaf)\n        internal\n        returns (uint256 leafIndex, bytes32 newRoot)\n    {\n        // TODO: implement BinaryIncrementalTree::insertLeaf\n        return (0, 0);\n    }\n\n    function hash(bytes32[2] memory) internal view virtual returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryUpdatableTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n// @notice The \"binary binary tree\" populated with zero leaf values\n\n/**\n * @title BinaryIncrementalUpdatableMerkleTree\n * @notice\n * @dev\n */\nabstract contract BinaryUpdatableTree {\n    /**\n     * @dev Update an existing leaf\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param newLeaf New leaf.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return _newRoot The new root after updating the tree\n     */\n    function update(\n        bytes32 curRoot,\n        bytes32 leaf,\n        bytes32 newLeaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bytes32 _newRoot) {\n        require(newLeaf != leaf, \"BIUT: New leaf cannot be equal the old one\");\n        require(\n            verify(curRoot, leaf, leafIndex, proofSiblings),\n            \"BIUT: Leaf is not part of the tree\"\n        );\n\n        _newRoot = newLeaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _newRoot = hash([_newRoot, proofSiblings[i]]);\n            } else {\n                _newRoot = hash([proofSiblings[i], _newRoot]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Verify if the path is correct and the leaf is part of the tree.\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return True or false.\n     */\n    function verify(\n        bytes32 curRoot,\n        bytes32 leaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bool) {\n        // equal to 2**proofSiblings.length\n        uint256 leavesNum = 1 << proofSiblings.length;\n        require(leafIndex < leavesNum, \"BIUT: invalid leaf index\");\n\n        bytes32 _hash = leaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _hash = hash([_hash, proofSiblings[i]]);\n            } else {\n                _hash = hash([proofSiblings[i], _hash]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return curRoot == 0 ? _hash == zeroRoot() : _hash == curRoot;\n    }\n\n    function zeroRoot() internal pure virtual returns (bytes32);\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/Types.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n"
    },
    "contracts/protocol/pantherForest/mocks/MockTaxiTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../taxiTree/PantherTaxiTree.sol\";\nimport \"../../crypto/PoseidonHashers.sol\";\nimport { FIELD_SIZE } from \"../../crypto/SnarkConstants.sol\";\n\ncontract MockTaxiTree is PantherTaxiTree {\n    // function simulateUpdateLeaf(\n    //     BinaryUpdatableTree calldata tree,\n    //     bytes32 newLeaf,\n    //     bytes32 oldLeaf,\n    //     uint256 leafInd,\n    //     bytes32[] calldata siblings\n    // ) public returns (bytes32 newRoot) {\n    //     updateLeaf(tree, newLeaf, oldLeaf, leafInd, siblings);\n    // }\n\n    function hash(bytes32[2] memory input) internal pure returns (bytes32) {\n        return PoseidonHashers.poseidonT3(input);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/PantherForest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITreeRootGetter.sol\";\nimport \"./interfaces/ITreeRootUpdater.sol\";\n\nimport \"./cachedRoots/CachedRoots.sol\";\n\nimport \"../../common/ImmutableOwnable.sol\";\nimport \"../crypto/PoseidonHashers.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title PantherForest\n * @notice It stores and updates leafs and the root of the Panther Forest Tree.\n * @dev \"Panther Forest Tree\" is a merkle tree with a single level (leafs) under\n * the root. It has 4 leafs, which are roots of 4 other merkle trees -\n * the \"Taxi Tree\", the \"Bus Tree\", the \"Ferry Tree\" and the \"Static Tree\"\n * (essentially, these 4 trees are subtree of the Panther Forest tree):\n *\n *          Forest Root\n *               |\n *     +------+--+---+------+\n *     |      |      |      |\n *     0      1      2      3\n *   Taxi   Bus    Ferry  Static\n *   Tree   Tree   Tree   Tree\n *   root   root   root   root\n *\n * Every of 4 trees are controlled by \"tree\" smart contracts. A \"tree\" contract\n * must call this contract to update the value of the leaf and the root of the\n * Forest Tree every time the \"controlled\" tree is updated.\n * It supports a \"history\" of recent roots, so that users may refer not only to\n * the latest root, but on former roots cached in the history.\n */\nabstract contract PantherForest is\n    CachedRoots,\n    ImmutableOwnable,\n    ITreeRootGetter,\n    ITreeRootUpdater\n{\n    bytes32[10] private _startGap;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant NUM_LEAFS = 4;\n    uint256 private constant STATIC_TREE_LEAF = 3;\n\n    address public immutable TAXI_TREE_CONTROLLER;\n    address public immutable BUS_TREE_CONTROLLER;\n    address public immutable FERRY_TREE_CONTROLLER;\n    address public immutable STATIC_TREE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _forestRoot;\n\n    bytes32[NUM_LEAFS] public leafs;\n\n    event RootUpdated(\n        uint256 indexed leafIndex,\n        bytes32 updatedLeaf,\n        bytes32 updatedRoot,\n        uint256 cacheIndex\n    );\n\n    bytes32[10] private _endGap;\n\n    constructor(\n        address _owner,\n        address _taxiTreeController,\n        address _busTreeController,\n        address _ferryTreeController,\n        address _staticTreeController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _taxiTreeController != address(0) &&\n                _busTreeController != address(0) &&\n                _ferryTreeController != address(0) &&\n                _staticTreeController != address(0),\n            \"init: zero address\"\n        );\n\n        TAXI_TREE_CONTROLLER = _taxiTreeController;\n        BUS_TREE_CONTROLLER = _busTreeController;\n        FERRY_TREE_CONTROLLER = _ferryTreeController;\n        STATIC_TREE_CONTROLLER = _staticTreeController;\n    }\n\n    function initialize() external onlyOwner {\n        require(_forestRoot == bytes32(0), \"PF: Already initialized\");\n\n        for (uint8 i; i < NUM_LEAFS; ) {\n            leafs[i] = ITreeRootGetter(_getLeafController(i)).getRoot();\n            unchecked {\n                ++i;\n            }\n        }\n\n        _forestRoot = hash(leafs);\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _forestRoot;\n    }\n\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external {\n        require(msg.sender == _getLeafController(leafIndex), \"unauthorized\");\n\n        leafs[leafIndex] = updatedLeaf;\n        bytes32 forestRoot = hash(leafs);\n        uint256 cacheIndex;\n        if (leafIndex == STATIC_TREE_LEAF) {\n            cacheIndex = resetThenCacheNewRoot(forestRoot);\n        } else {\n            cacheIndex = cacheNewRoot(forestRoot);\n        }\n\n        _forestRoot = forestRoot;\n        emit RootUpdated(leafIndex, updatedLeaf, forestRoot, cacheIndex);\n    }\n\n    function _getLeafController(uint256 leafIndex)\n        internal\n        view\n        returns (address leafController)\n    {\n        require(leafIndex < NUM_LEAFS, \"PF: INVALID_LEAF_IND\");\n        if (leafIndex == TAXI_TREE_FOREST_LEAF_INDEX)\n            leafController = TAXI_TREE_CONTROLLER;\n\n        if (leafIndex == BUS_TREE_FOREST_LEAF_INDEX)\n            leafController = BUS_TREE_CONTROLLER;\n\n        if (leafIndex == FERRY_TREE_FOREST_LEAF_INDEX)\n            leafController = FERRY_TREE_CONTROLLER;\n\n        if (leafIndex == STATIC_TREE_FOREST_LEAF_INDEX)\n            leafController = STATIC_TREE_CONTROLLER;\n    }\n\n    function hash(bytes32[NUM_LEAFS] memory _leafs)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT5(_leafs);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/taxiTree/PantherTaxiTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\n\n// is PantherTreesZeros\nabstract contract PantherTaxiTree is ITreeRootGetter {\n    // Root of root with ZERO trees with depth 6\n    function getRoot() external pure returns (bytes32) {\n        return SIX_LEVEL_EMPTY_TREE_ROOT;\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// The roots of empty trees follow.\n// An \"empty\" tree is a binary merkle tree of a given number of levels bellow\n// the root (depth), fully populated with ZERO_VALUE leafs, with the `poseidon`\n// hash function applied.\n// (computed by `../../../../lib/binaryMerkleZerosContractGenerator.ts`)\n\nuint256 constant SIX_LEVELS = 6;\n/// @dev Root of the binary merkle SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 0: ZERO_VALUE\n// Level 1: 0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n// Level 2: 0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n// Level 3: 0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n// Level 4: 0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n// Level 5: 0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\nbytes32 constant SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69)\n);\n\nuint256 constant SIXTEEN_LEVELS = 16;\n/// @dev Root of the binary merkle SIXTEEN_LEVELS tree with ZERO_VALUE leafs\n// Level 6:  SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 7:  0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n// Level 8:  0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7\n// Level 9:  0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718\n// Level 10: 0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58\n// Level 11: 0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f\n// Level 12: 0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6\n// Level 13: 0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d\n// Level 14: 0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55\n// Level 15: 0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\nbytes32 constant SIXTEEN_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x0a5e5ec37bd8f9a21a1c2192e7c37d86bf975d947c2b38598b00babe567191c9)\n);\n\nuint256 constant TWENTY_LEVELS = 20;\n/// @dev Root of the merkle binary TWENTY_LEVELS tree with ZERO_VALUE leafs\n// Level 16: SIXTEEN_LEVEL_EMPTY_TREE_ROOT\n// Level 17: 0x21fb04b171b68944c640020a3a464602ec8d02495c44f1e403d9be4a97128e49\n// Level 18: 0x19151c748859974805eb30feac7a301266dec9f67e23e285fe750f86448a2af9\n// Level 19: 0x18fb0b755218eaa809681eb87e45925faa9197507d368210d73b5836ebf139e4\nbytes32 constant TWENTY_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1e294375b42dfd97795e07e1fe8bd6cefcb16c3bbb71b30bed950f8965861244)\n);\n\nuint256 constant TWENTY_SIX_LEVELS = 26;\n/// @dev Root of the binary merkle TWENTY_SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 21: 0x0d3e4235db275d9bab0808dd9ade8789d46d0e1f1c9a99ce73fefca51dc92f4a\n// Level 22: 0x075ab2ca945c4dc5ea40a9f1c66d5bf3c367cef1e04e73aa17c2bc747eb5fc87\n// Level 23: 0x26f0f533a8ea2210001aeb8f8306c7c70656ba6afe145c6540bd4ed2c967a230\n// Level 24: 0x24be7e64f680326e6e3621e5862d7b6b1f31e9e183a0bf5dd04e823be84e6af9\n// Level 25: 0x212b13c9cbf421942ae3e3c62a3c072903c2a745a220cfb3c43cd520f55f44bf\nbytes32 constant TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n\nuint256 constant THIRTY_TWO_LEVELS = 32;\n/// @dev Root of the binary merkle THIRTY_TWO_LEVELS tree with ZERO_VALUE leafs\n// Level 26: TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 27: 0x038acf368a174e10c45a64161131c0f93faf2f045ff663acbef804eb5644aad7\n// Level 28: 0x1b3ecbe4131d8d52d60b91ec8e13d5fc82235232bb43007d54cda6b50d932d6f\n// Level 29: 0x1b0b9059f431d38a66c82317d9ed1b744c439f10193ae44bcf519fe6e1766b65\n// Level 30: 0x240867e8bb31d6b8057f5ab067dc0bd1c4ba64a42258963ec45b7b4773ce5838\n// Level 31: 0x2310e5b3543ea766ecaec53003d0e1b73f19a149409190d00561da7090a2c5cb\nbytes32 constant THIRTY_TWO_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x24ab16594d418ca2e66ca284f56a4cb7039c6d8f8e0c3c8f362cf18b5afa19d0)\n);\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/SixLevelZeroTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZERO_VALUE } from \"./Constants.sol\";\n\n// @notice The binary Merkle tree of six levels populated with zero leaf values\nabstract contract SixLevelZeroTree {\n    // @dev Number of levels in a tree excluding the root level\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 internal constant SIX_LEVELS = 6;\n\n    // @param level From 0 for the leaf up to SIX_LEVELS for the root\n    function getZeroNodeAtLevel(uint256 level) internal pure returns (bytes32) {\n        require(level < SIX_LEVELS + 1, \"SZT:E1\");\n\n        // Generated by `../../../../lib/binaryMerkleZerosContractGenerator.ts`\n        uint256 zeroNode = [\n            // Leaf with the zero value\n            uint256(ZERO_VALUE),\n            // Roots of branches containing zero leafs only, one root per level\n            0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4,\n            0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8,\n            0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c,\n            0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800,\n            0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f,\n            // Root of the tree fully populated with zero leafs only\n            0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n        ][level];\n\n        return bytes32(zeroNode);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/AmountConvertor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { MAX_EXT_AMOUNT, MAX_IN_CIRCUIT_AMOUNT } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_AMOUNT, ERR_TOO_LARGE_SCALED_AMOUNT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title AmountConvertor\n * @author Pantherprotocol Contributors\n * @notice Methods for scaling amounts for computations within/outside the\n * Panther Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\nabstract contract AmountConvertor {\n    // \"Scaled amounts\" - amounts ZK-circuits of the MASP operate with\n    // \"Unscaled amounts\" - amounts token contracts operate with\n    // Scaling is relevant for fungible tokens only - for ERC-721/ERC-1155\n    // tokens, scaled and unscaled amounts MUST be equal. For some ERC-20\n    // tokens, the \"scaling factor\" MAY be 1:1, i.e. scaled and unscaled\n    // amounts are equal.\n\n    // Conversion from the unscaled amount (aka amount) to the scaled one.\n    // Returns the scaled amount and the reminder.\n    function _scaleAmount(uint256 amount, uint8 scale)\n        internal\n        pure\n        returns (uint64 scaledAmount, uint256 change)\n    {\n        uint256 _scaledAmount;\n        if (scale == 0) {\n            // No scaling and no change for zero `scale`\n            _scaledAmount = amount;\n            change = 0;\n        } else {\n            unchecked {\n                uint256 factor = _getScalingFactor(scale);\n                // divider can't be zero, loss of precision assumed\n                // slither-disable-next-line divide-before-multiply\n                _scaledAmount = amount / factor;\n                // `restoredAmount` can not exceed the `amount`\n                uint256 restoredAmount = _scaledAmount * factor;\n                change = amount - restoredAmount;\n            }\n        }\n        scaledAmount = _sanitizeScaledAmount(_scaledAmount);\n    }\n\n    // Conversion from the scaled amount to unscaled one.\n    // Returns the unscaled amount.\n    function _unscaleAmount(uint64 scaledAmount, uint8 scale)\n        internal\n        pure\n        returns (uint96)\n    {\n        uint256 amount = scale == 0\n            ? scaledAmount // no scaling\n            : uint256(scaledAmount) * _getScalingFactor(scale);\n        return _sanitizeAmount(amount);\n    }\n\n    function _sanitizeAmount(uint256 amount) internal pure returns (uint96) {\n        require(amount < MAX_EXT_AMOUNT, ERR_TOO_LARGE_AMOUNT);\n        return uint96(amount);\n    }\n\n    function _sanitizeScaledAmount(uint256 scaledAmount)\n        internal\n        pure\n        returns (uint64)\n    {\n        require(\n            scaledAmount < MAX_IN_CIRCUIT_AMOUNT,\n            ERR_TOO_LARGE_SCALED_AMOUNT\n        );\n        return uint64(scaledAmount);\n    }\n\n    /// Private functions follow\n\n    // Note: implementation accepts 0..255 values for nonZeroScale\n    // It is responsibility of the caller check it is indeed less than 255 since 10^255 overflows uint256\n    // This overflow check not implemented here since caller will implement it in upper level\n    function _getScalingFactor(uint8 nonZeroScale)\n        private\n        pure\n        returns (uint256)\n    {\n        return 10**nonZeroScale;\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\nimport { ERR_TOO_LARGE_PUBKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract CommitmentGenerator {\n    /// Generate UTXOs, these UTXOs will be used later\n    /// @param pubSpendingKeyX Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param pubSpendingKeyY Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param scaledAmount 64 bit size - used in circom\n    /// @param zAssetId 160 bit size - used in circom\n    /// @param creationTime 32 bit size - used in circom\n    function generateCommitment(\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyX,\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) internal pure returns (bytes32 commitment) {\n        require(\n            pubSpendingKeyX <= FIELD_SIZE && pubSpendingKeyY <= FIELD_SIZE,\n            ERR_TOO_LARGE_PUBKEY\n        );\n        // Being 160 bits and less, other input params can't exceed FIELD_SIZE\n        commitment = PoseidonT4.poseidon(\n            [\n                bytes32(pubSpendingKeyX),\n                bytes32(pubSpendingKeyY),\n                bytes32(\n                    (uint256(scaledAmount) << 192) |\n                        (uint256(zAssetId) << 32) |\n                        uint256(creationTime)\n                )\n            ]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentsTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\nimport { OUT_MAX_UTXOs } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_COMMITMENTS } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title CommitmentsTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees of commitments for the `PantherPool` contract\n */\nabstract contract CommitmentsTrees is TriadIncrementalMerkleTrees {\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * @notice Adds commitments to merkle tree(s) and emits events\n     * @param commitments Commitments (leaves hashes) to be inserted into merkle tree(s)\n     * @param msgTypes Types (i.e. formats) of the perUtxoData array elements\n     * @param perUtxoData opening values (encrypted and public) for every UTXO\n     * @return leftLeafId The `leafId` of the first leaf in the batch\n     */\n    function addAndEmitCommitments(\n        bytes32[OUT_MAX_UTXOs] memory commitments,\n        uint8 msgTypes,\n        bytes[OUT_MAX_UTXOs] memory perUtxoData,\n        uint256 timestamp\n    ) internal returns (uint256 leftLeafId) {\n        bytes memory utxoData = abi.encodePacked(msgTypes);\n\n        for (uint256 i = 0; i < OUT_MAX_UTXOs; i++) {\n            require(\n                uint256(commitments[i]) < FIELD_SIZE,\n                ERR_TOO_LARGE_COMMITMENTS\n            );\n            utxoData = bytes.concat(utxoData, perUtxoData[i]);\n        }\n\n        // Insert hashes into Merkle tree(s)\n        leftLeafId = insertBatch(commitments);\n\n        emit NewCommitments(leftLeafId, timestamp, commitments, utxoData);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pantherPool/MerkleProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\nimport \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\n\nabstract contract MerkleProofVerifier {\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 private constant TREE_DEPTH = 15;\n\n    //t |bH  bL| Subtree\n    //--|------|------------\n    //0 | 0  0 | hash(C,L,R)\n    //1 | 0  1 | hash(L,C,R)\n    //2 | 1  0 | hash(L,R,C)\n    //3 | 1  1 | Not allowed\n    //--|------|------------\n    // Current leaf index in triad is (C,L,R)\n    uint256 private constant iTRIAD_INDEX_LEFT = 0x0;\n    // Current leaf index in triad is (L,C,R)\n    uint256 private constant iTRIAD_INDEX_MIDDLE = 0x1;\n    // Current leaf index in triad is (L,R,C)\n    uint256 private constant iTRIAD_INDEX_RIGHT = 0x2;\n    // Forbidden triad value in tria is `11`\n    uint256 private constant iTRIAD_INDEX_FORBIDDEN = 0x3;\n\n    /// @param merkleRoot - verify checked to this hash\n    /// @param triadIndex - index inside triad = { 0, 1, 2 }\n    /// @param triadNodeIndex - index of triad hash ( c0,c1,c2 ) in the tree - Triad contract insures its is in range\n    /// @param leaf - commitment leaf value\n    /// @param pathElements - TREE_DEPTH + 1 elements - c1,c2 & path-elements\n    /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n    /// @dev defined by `root`. For this, a `proof` must be provided, containing\n    /// @dev sibling hashes on the branch from the leaf to the root of the tree.\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        uint256 triadIndex,\n        uint256 triadNodeIndex,\n        bytes32 leaf,\n        bytes32[TREE_DEPTH + 1] calldata pathElements\n    ) internal pure {\n        // [0] - Assumed it is computed by the TriadIncrementalMerkleTrees\n        //       using modulo operation, so no need to check lower range\n        //require(iTRIAD_INDEX_LEFT <= triadIndex, ERR_TRIAD_INDEX_MIN_VALUE);\n        require(triadIndex < iTRIAD_INDEX_FORBIDDEN, ERR_TRIAD_INDEX_MAX_VALUE);\n\n        // [1] - Compute zero level hash\n        // variable will be initialized inside the 'if' bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32 nodeHash;\n        // NOTE: no else-case needed since this code executed after require at step [0]\n        if (triadIndex == iTRIAD_INDEX_LEFT) {\n            nodeHash = PoseidonT4.poseidon(\n                [leaf, pathElements[0], pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_MIDDLE) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], leaf, pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_RIGHT) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], pathElements[1], leaf]\n            );\n        }\n\n        // [2] - Compute root\n        for (uint256 level = 2; level < pathElements.length; level++) {\n            bool isLeftNode;\n            unchecked {\n                // triadNodeIndex is actually a path to triad-node in merkle-tree\n                // each LSB bit of this number is left or right path\n                // it means for example: path = b111 , zero leaf will be from right size of hash\n                // and path element[2] will be from right side of hash, all other path elements [3,4] will be from\n                // left side of the next hashes till root.\n                isLeftNode = ((triadNodeIndex & (0x1 << (level - 2))) == 0);\n            }\n            if (isLeftNode) {\n                // computed node from left side\n                // Hash(left = nodeHash, right = pathElement)\n                nodeHash = PoseidonT3.poseidon([nodeHash, pathElements[level]]);\n            } else {\n                // computed node from right side\n                // Hash(left = pathElement, right = nodeHash)\n                nodeHash = PoseidonT3.poseidon([pathElements[level], nodeHash]);\n            }\n        }\n        // [3] - revert if verification fails\n        require(merkleRoot == nodeHash, ERR_MERKLE_PROOF_VERIFICATION_FAILED);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/NullifierGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3 } from \"../crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport { ERR_TOO_LARGE_LEAFID, ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\nabstract contract NullifierGenerator {\n    function generateNullifier(uint256 privSpendingKey, uint256 leafId)\n        internal\n        pure\n        returns (bytes32 nullifier)\n    {\n        require(privSpendingKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        require(leafId < FIELD_SIZE, ERR_TOO_LARGE_LEAFID);\n        nullifier = PoseidonT3.poseidon(\n            [bytes32(privSpendingKey), bytes32(leafId)]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/PubKeyGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport \"../crypto/BabyJubJub.sol\";\n\nabstract contract PubKeyGenerator {\n    function generatePubSpendingKey(uint256 privKey)\n        internal\n        view\n        returns (G1Point memory pubKey)\n    {\n        // [0] - Require\n        require(privKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        // [1] - Generate public key\n        G1Point memory base8 = G1Point({\n            x: BabyJubJub.BASE8_X,\n            y: BabyJubJub.BASE8_Y\n        });\n        pubKey = BabyJubJub.mulPointEscalar(base8, privKey);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/TransactionNoteEmitter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/***\n * @dev Every MASP transaction is accompanied by the \"Transaction Note\" - data\n * needed to process the transaction (think of opening UTXOs), reconstruct user\n * operations history (think of \"wallet cold start\"), or send a private message\n * to a user in extraordinary cases (think of a \"subpoena\").\n * `PantherPool` smart contract publishes Transaction Notes as \"events\" (logs).\n * The Transaction Note contains one or a few \"messages\", which may be \"public\"\n * or \"private\".\n * Public messages contain publicly seen on-chain data. Smart contracts, rather\n * than users (the DApp), compose public messages.\n * As the name assumes, private messages contain private data, and user (DApp)\n * prepares and encrypts these messages to pass them to smart contracts.\n * Every private message is encrypted with the reading key of a receiver, who\n * may be a recipient of an UTXO, or the user that spends UTXOs (\"messages to\n * the future\"), or even a user not involved in spending/creating UTXOs.\n * Smart contracts don't parse private messages but rather copy private messages\n * \"as is\" into Transaction Notes.\n * Every message belongs to a certain \"message type\". The message type defines\n * the exact message length and the content.\n * For \"fixed-content\" messages, the message type defines all data fields - i.e.\n * data interpretation, formats/size, and the sequence the fields must follow in.\n * Data fields of the \"free-content\" are unspecified, unlike the content size.\n * Public messages always have fixed content. Private messages may have fixed or\n * free content.\n * For fixed-content private messages, the protocol also specifies the content\n * of the preimage and the cipher to apply.\n * Every MASP transaction belongs to one of a few \"transaction types\".\n * For every transaction type, the protocol specifies \"mandatory\" messages which\n * MUST be included in the Transaction Note.\n * Users (DApp) may append \"optional\" messages to mandatory messages.\n * There is also a special \"void\" message that has no content. It MAY replace a\n * mandatory message when data is missing/undefined/irrelevant, providing public\n * knowledge of this fact does not leak privacy.\n */\nabstract contract TransactionNoteEmitter {\n    // @notice Transaction Note, emitted with every MASP transaction\n    event TransactionNote(uint8 txType, bytes content);\n\n    // **** `bytes content`\n\n    /* START of pseudo-code\n    bytes content = abi.packed(messages[0], ..., messages[numMessages - 1]);\n    numMessages = for_txType_num_of_mandatory_mssgs + num_of_opt_mssgs;\n\n    // For \"void\" message type:\n    bytes messages[i] = abi.packed(byte msgType);\n\n    // For messages of types other than \"void\":\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes[for_msgType_length] msgContainer\n    );\n\n    // Public fixed-content messages:\n    // Smart contract MUST compose `msgContainer` as defined by `msgType`\n    // (no `ephemeralKey` needed as data is publicly seen)\n    bytes msgContainer = avi.packed(<abi.packed on-chain data>)\n\n    // Private fixed-content messages:\n    // DApp MUST compose the `ciphertext` as defined by the `msgType`\n    bytes msgContainer = avi.packed(\n        bytes32(ephemeralKey),\n        bytes[for_msgType_ciphertext_length] ciphertext\n    )\n\n    // Private free-data messages:\n    // nBlocks - number of 16-byte blocks the `msgContent` occupies\n    require(nBlocks >= 1 && nBlocks =< 16)\n    msgType = 0x2F + nBlocks;\n    // DApp is not limited in composing (structuring) `msgContainer`\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes32(ephemeralKey),\n        bytes[nBlocks*16] msgContainer\n    )\n    END of pseudo-code */\n\n    // **** Transaction Types\n\n    // The range for `uint8 txType` divided into sub-ranges:\n    //  - 0x00 .. 0x1F allowed\n    //  - 0x20 .. 0xFF reserved (unused)\n\n    // solhint-disable var-name-mixedcase\n\n    uint8 internal constant TT_ZACCOUNT_ACTIVATION = 0x01;\n    // TransactionNote for this tx type MUST include in the specified sequence:\n    // - MT_UTXO_CREATE_TIME\n    // - MT_UTXO_BUSTREE_IDS\n    // - MT_UTXO_ZACCOUNT\n\n    // **** Message Types\n\n    // The range for `uint8 msgType` divided into sub-ranges:\n    //  - 0x00 - the \"void\" (empty) message\n    //  - 0x01 .. 0x2F for fixed-content private messages\n    //  - 0x30 .. 0x3F for free-content private messages\n    //  - 0x40 .. 0x5F reserved (unused)\n    //  - 0x60 .. 0x7F for fixed-content public messages\n    //  - 0x80 .. 0xFF reserved (unused)\n\n    // \"Void\" type messages contain just this single byte:\n    uint8 internal constant MT_VOID = 0x00;\n    // Length in bytes\n    uint256 internal constant LMT_VOID = 1;\n\n    // zAccount UTXO opening values:\n    uint8 internal constant MT_UTXO_ZACCOUNT = 0x06;\n    // `msgContainer` MUST include the following data:\n    // - bytes[64] cypherText\n    // Length in bytes (msgType, ephemeralKey, msgContainer)\n    uint256 internal constant LMT_UTXO_ZACCOUNT = 1 + 32 + 64;\n    // Preimage of `cipherText` MUST contain (512 bit):\n    // - random (256 bit)\n    // - networkId (6 bit)\n    // - zoneId (16 bit)\n    // - nonce (24 bit)\n    // - expiryTime (32 bit)\n    // - amountZkp (64 bit)\n    // - amountPrp (50 bit)\n    // - totalAmountPerTimePeriod (64 bit)\n\n    // Creation time of UTXO:\n    uint8 internal constant MT_UTXO_CREATE_TIME = 0x60;\n    // `msgContainer` MUST include the following data:\n    // - uint32 creationTime\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_CREATE_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_SPEND_TIME = 0x61;\n    // `msgContainer` MUST include the following data:\n    // - uint32 spendType\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_SPEND_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_BUSTREE_IDS = 0x62;\n    // `msgContainer` MUST include the following data:\n    // - bytes32 commitment\n    // - uint32 queueId\n    // - uint8 indexInQueue\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_BUSTREE_IDS = 1 + 37;\n\n    // solhint-enable var-name-mixedcase\n}\n"
    },
    "contracts/protocol/PantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../common/Constants.sol\";\nimport \"./errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/Utils.sol\";\nimport \"./interfaces/IPrpGrantor.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\nimport \"../common/Claimable.sol\";\nimport \"./pantherPool/AmountConvertor.sol\";\nimport \"./pantherPool/CommitmentGenerator.sol\";\nimport \"./pantherPool/CommitmentsTrees.sol\";\nimport \"./pantherPool/MerkleProofVerifier.sol\";\nimport \"./pantherPool/NullifierGenerator.sol\";\nimport \"./pantherPool/PubKeyGenerator.sol\";\n\n/**\n * @title PantherPool\n * @author Pantherprotocol Contributors\n * @notice Multi-Asset Shielded Pool main contract v0\n * @dev It is the \"version 0\" of the Panther Protocol Multi-Asset Shielded Pool (\"MASP\").\n * It locks assets (ERC-20, ERC-721 or ERC-1155 tokens) of a user with the `Vault` smart\n * contract and generates UTXO's in the MASP for the user (i.e. builds merkle trees of\n * UTXO's commitments).\n * This contract does not implement the functionality for spending UTXO's (other than the\n * `exit` described further) and is supposed to be upgraded with the new one.\n * The new contract, the \"v.1\" of the MASP, is planned to implement spending of UTXO's\n * using zero-knowledge proves.\n * To be upgradable, this contract is assumed to run as an \"implementation\" for a proxy\n * that DELEGATECALL's the implementation.\n * To protect holders against lost of assets in case this contract is not upgraded, it\n * exposes the `exit` function, through which users may withdraw their locked assets via\n * revealing preimages of commitments.\n */\ncontract PantherPoolV0 is\n    ImmutableOwnable,\n    NonReentrant,\n    Claimable,\n    CommitmentsTrees,\n    AmountConvertor,\n    CommitmentGenerator,\n    MerkleProofVerifier,\n    NullifierGenerator,\n    PubKeyGenerator,\n    Utils\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the ZAssetRegistry contract\n    address public immutable ASSET_REGISTRY;\n\n    /// @notice Address of the Vault contract\n    address public immutable VAULT;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice (UNIX) Time since when the `exit` calls get enabled\n    uint32 public exitTime;\n\n    /// @notice Period (seconds) since `commitToExit` when `exit` opens\n    // Needed to mitigate front-run attacks on `exit`\n    uint24 public exitDelay;\n\n    // (rest of the storage slot) reserved for upgrades\n    // slither-disable-next-line unused-state,constable-states\n    uint200 private _reserved;\n\n    // @notice Seen (i.e. spent) commitment nullifiers\n    // nullifier hash => spent\n    mapping(bytes32 => bool) public isSpent;\n\n    /// @notice Unused registered commitments to exit\n    // hash(privSpendKey, recipient) => commitment timestamp\n    mapping(bytes32 => uint32) public exitCommitments;\n\n    /// @dev Emitted when exit time and/or exit delay updated\n    event ExitTimesUpdated(uint256 newExitTime, uint256 newExitDelay);\n\n    /// @dev New nullifier has been seen\n    event Nullifier(bytes32 nullifier);\n\n    /// @dev A tiny disowned token amount gets locked in the Vault\n    /// (as a result of imprecise scaling of deposited amounts)\n    event Change(address indexed token, uint256 change);\n\n    /// @dev New exit commitment registered\n    event ExitCommitment(uint256 timestamp);\n\n    /// @param _owner Address of the `OWNER` who may call `onlyOwner` methods\n    /// @param assetRegistry Address of the ZAssetRegistry contract\n    /// @param vault Address of the Vault contract\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) ImmutableOwnable(_owner) {\n        require(TRIAD_SIZE == OUT_UTXOs, \"E0\");\n\n        revertZeroAddress(assetRegistry);\n        revertZeroAddress(vault);\n\n        // As it runs behind the DELEGATECALL'ing proxy, initialization of\n        // immutable \"vars\" only is allowed in the constructor\n\n        ASSET_REGISTRY = assetRegistry;\n        VAULT = vault;\n    }\n\n    /// @notice Update the exit time and the exit delay\n    /// @dev Owner only may calls\n    function updateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n        onlyOwner\n    {\n        require(\n            newExitTime >= exitTime &&\n                newExitTime < MAX_TIMESTAMP &&\n                newExitDelay != 0,\n            \"E1\"\n        );\n\n        exitTime = newExitTime;\n        exitDelay = newExitDelay;\n\n        emit ExitTimesUpdated(uint256(newExitTime), uint256(newExitDelay));\n    }\n\n    /// @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n    /// @param tokens Address of the token contract for every UTXO\n    /// @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n    /// @param amounts Token amounts (unscaled) to be deposited\n    /// @param pubSpendingKeys Public Spending Key for every UTXO\n    /// @param secrets Encrypted opening values for every UTXO\n    /// @param createdAt Optional, if 0 the network time used\n    /// @dev createdAt must be less (or equal) the network time\n    /// @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata amounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external nonReentrant returns (uint256 leftLeafId) {\n        require(exitTime > 0, ERR_UNCONFIGURED_EXIT_TIME);\n\n        uint32 timestamp = safe32TimeNow();\n        if (createdAt != 0) {\n            // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n            // slither-disable-next-line timestamp\n            require(createdAt <= timestamp, ERR_TOO_EARLY_CREATED_AT);\n            timestamp = createdAt;\n        }\n\n        // variables get initialized inside the loop bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32[OUT_MAX_UTXOs] memory commitments;\n        // slither-disable-next-line uninitialized-local\n        bytes[OUT_MAX_UTXOs] memory perUtxoData;\n\n        // Types of UTXO data messages packed into one byte\n        uint8 msgTypes = uint8(0);\n\n        for (uint256 utxoIndex = 0; utxoIndex < OUT_MAX_UTXOs; utxoIndex++) {\n            // The next call can't trigger the \"calls loop\" since it triggers\n            // external calls to known contracts, which are trusted to handle\n            // reentrancy risk properly.\n            // Slither's \"disable calls-loop detector\" directives are inserted\n            // in lines (bellow) with external calls rather than here only (as\n            // otherwise slither reports false-positive issues).\n            (uint160 zAssetId, uint64 scaledAmount) = _processDepositedAsset(\n                tokens[utxoIndex],\n                tokenIds[utxoIndex],\n                amounts[utxoIndex]\n            );\n\n            if (utxoIndex != 0) msgTypes = msgTypes << 2;\n\n            if (scaledAmount == 0) {\n                // the zero UTXO\n                // At least the 1st deposited amount shall be non-zero\n                require(utxoIndex != 0, ERR_ZERO_DEPOSIT);\n\n                commitments[utxoIndex] = ZERO_VALUE;\n                perUtxoData[utxoIndex] = \"\";\n                // As UTXO_DATA_TYPE5 is 0, next statement may be skipped\n                // msgTypes |= UTXO_DATA_TYPE5;\n            } else {\n                // non-zero UTXO\n                commitments[utxoIndex] = generateCommitment(\n                    pubSpendingKeys[utxoIndex].x,\n                    pubSpendingKeys[utxoIndex].y,\n                    scaledAmount,\n                    zAssetId,\n                    timestamp\n                );\n\n                uint256 zAssetIdAndAmount = (uint256(zAssetId) << 96) |\n                    uint256(scaledAmount);\n\n                if (tokenIds[utxoIndex] != 0) {\n                    msgTypes |= UTXO_DATA_TYPE1;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount\n                    );\n                } else {\n                    msgTypes |= UTXO_DATA_TYPE3;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount,\n                        tokenIds[utxoIndex]\n                    );\n                }\n            }\n        }\n\n        leftLeafId = addAndEmitCommitments(\n            commitments,\n            msgTypes,\n            perUtxoData,\n            timestamp\n        );\n    }\n\n    /// @notice Register future `exit` to protect against front-run and DoS.\n    /// The `exit` is possible only after `exitDelay` since this function call.\n    /// @param exitCommitment Commitment to the UTXO spending key and the recipient address.\n    /// MUST be equal to keccak256(abi.encode(uint256(privSpendingKey), address(recipient)).\n    function commitToExit(bytes32 exitCommitment) external {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(\n            exitCommitments[exitCommitment] == uint32(0),\n            ERR_EXITCOMMIT_EXISTS\n        );\n        uint32 timestamp = safe32TimeNow();\n        exitCommitments[exitCommitment] = timestamp;\n        emit ExitCommitment(timestamp);\n    }\n\n    /// @notice Spend an UTXO in the MASP and withdraw the asset from the Vault to the msg.sender.\n    /// This function call must be registered in advance with `commitToExit`.\n    /// @param token Address of the token contract\n    /// @param subId '_tokenId'/'_id' for ERC-721/1155, 0 for the \"default\" zAsset of an ERC-20 token,\n    // or `subId` for an \"alternative\" zAsset of an ERC-20 (see ZAssetRegistry.sol for details)\n    /// @param scaledAmount Token scaled amount\n    /// @param privSpendingKey UTXO's Private Spending Key\n    /// @param leafId Id of the leaf with the UTXO commitments in the Merkle Trees\n    /// @param pathElements Elements of the Merkle proof of inclusion\n    /// @param merkleRoot The root of the Merkle Tree the leaf is a part of\n    /// @param cacheIndexHint Index of the `merkleRoot` in the cache of roots, 0 by default\n    /// @dev `cacheIndexHint` needed for the \"current\" (partially populated) tree only\n    function exit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external nonReentrant {\n        // if exitTime == 0 -> `exit` is not accepted since init phase is not finished yet\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            safe32TimeNow() >= exitTime && exitTime != 0,\n            ERR_TOO_EARLY_EXIT\n        );\n        _verifyExitCommitment(privSpendingKey, msg.sender);\n\n        {\n            bytes32 nullifier = generateNullifier(privSpendingKey, leafId);\n            require(!isSpent[nullifier], ERR_SPENT_NULLIFIER);\n            isSpent[nullifier] = true;\n            emit Nullifier(nullifier);\n        }\n        require(\n            isKnownRoot(getTreeId(leafId), merkleRoot, cacheIndexHint),\n            ERR_UNKNOWN_MERKLE_ROOT\n        );\n\n        ZAsset memory asset;\n        uint256 _tokenId;\n        {\n            bytes32 commitment;\n            {\n                uint160 zAssetId;\n                {\n                    (zAssetId, _tokenId, , asset) = IZAssetsRegistry(\n                        ASSET_REGISTRY\n                    ).getZAssetAndIds(token, subId);\n                    require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n                }\n                G1Point memory pubSpendingKey = generatePubSpendingKey(\n                    privSpendingKey\n                );\n                commitment = generateCommitment(\n                    pubSpendingKey.x,\n                    pubSpendingKey.y,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                );\n            }\n            verifyMerkleProof(\n                merkleRoot,\n                _getTriadIndex(leafId),\n                _getTriadNodeIndex(leafId),\n                commitment,\n                pathElements\n            );\n        }\n\n        uint96 amount = _unscaleAmount(scaledAmount, asset.scale);\n        IVault(VAULT).unlockAsset(\n            LockData(asset.tokenType, token, _tokenId, msg.sender, amount)\n        );\n    }\n\n    /// @notice Withdraw accidentally sent tokens or ETH from this contract\n    /// @dev The \"owner\" may call only\n    function claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        _claimEthOrErc20(token, to, amount);\n    }\n\n    /// Internal and private functions follow\n\n    // Declared `internal` rather than `private` to ease testing\n    function _processDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 amount\n    ) internal returns (uint160 zAssetId, uint64 scaledAmount) {\n        // Do nothing if it's the \"zero\" (or \"dummy\") deposit\n        if (amount == 0) {\n            // Both token and subId must be zeros for the \"zero\" deposit\n            require(token == address(0) && subId == 0, ERR_WRONG_DEPOSIT);\n            return (0, 0);\n        }\n        // amount can't be zero here and further\n\n        // At this point, a non-zero deposit of a real asset (token) expected\n        uint256 _tokenId;\n        ZAsset memory asset;\n\n        // Note comments on \"calls-loop\" in `function generateDeposits`\n        // slither-disable-next-line calls-loop\n        (zAssetId, _tokenId, , asset) = IZAssetsRegistry(ASSET_REGISTRY)\n            .getZAssetAndIds(token, subId);\n        require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n\n        // Scale amount, if asset.scale provides for it (ERC-20 only)\n        uint256 change;\n        (scaledAmount, change) = _scaleAmount(amount, asset.scale);\n\n        // The `change` will remain locked in the Vault until it's claimed\n        // (when and if future upgrades implement change claiming)\n        if (change > 0) emit Change(token, change);\n\n        // slither-disable-next-line calls-loop\n        IVault(VAULT).lockAsset(\n            LockData(\n                asset.tokenType,\n                asset.token,\n                _tokenId,\n                msg.sender,\n                uint96(amount)\n            )\n        );\n\n        return (zAssetId, scaledAmount);\n    }\n\n    function _verifyExitCommitment(uint256 privSpendingKey, address recipient)\n        internal\n    {\n        bytes32 commitment = keccak256(abi.encode(privSpendingKey, recipient));\n\n        uint32 commitmentTime = exitCommitments[commitment];\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(commitmentTime != uint32(0), ERR_EXITCOMMIT_MISSING);\n\n        uint256 allowedTime = uint256(commitmentTime) + uint256(exitDelay);\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(timeNow() > allowedTime, ERR_EXITCOMMIT_LOCKED);\n\n        // Let's gain some gas back\n        exitCommitments[commitment] = uint32(0);\n        // No extra event emitted as spent UTXO and withdrawal events will fire\n    }\n}\n"
    },
    "contracts/protocol/PantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023s Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IPantherVerifier.sol\";\nimport \"./interfaces/IBusTree.sol\";\nimport \"./../common/ImmutableOwnable.sol\";\nimport { LockData } from \"./../common/Types.sol\";\nimport \"./errMsgs/PantherPoolV1ErrMsgs.sol\";\nimport \"./pantherForest/PantherForest.sol\";\nimport \"./pantherPool/TransactionNoteEmitter.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\n\ncontract PantherPoolV1 is\n    PantherForest,\n    TransactionNoteEmitter,\n    IPantherPoolV1\n{\n    // initialGap - PantherForest slots - CachedRoots slots => 500 - 22 - 25\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[453] private __gap;\n\n    // solhint-disable var-name-mixedcase\n    IVault public immutable VAULT;\n    IBusTree public immutable BUS_TREE;\n    IPantherVerifier public immutable VERIFIER;\n    address public immutable ZACCOUNT_REGISTRY;\n    // solhint-enable var-name-mixedcase\n\n    mapping(address => bool) public vaultAssetUnlockers;\n\n    uint160 public zAccountRegistrationCircuitId;\n\n    constructor(\n        address _owner,\n        address taxiTree,\n        address busTree,\n        address ferryTree,\n        address staticTree,\n        address vault,\n        address zAccountRegistry,\n        address verifier\n    ) PantherForest(_owner, taxiTree, busTree, ferryTree, staticTree) {\n        require(\n            vault != address(0) &&\n                verifier != address(0) &&\n                zAccountRegistry != address(0),\n            ERR_INIT\n        );\n\n        VAULT = IVault(vault);\n        BUS_TREE = IBusTree(busTree);\n        VERIFIER = IPantherVerifier(verifier);\n        ZACCOUNT_REGISTRY = zAccountRegistry;\n    }\n\n    function updateVaultAssetUnlocker(address _unlocker, bool _status)\n        external\n        onlyOwner\n    {\n        vaultAssetUnlockers[_unlocker] = _status;\n    }\n\n    function updateZAccountRegistrationCircuitId(uint160 _circuitId)\n        external\n        onlyOwner\n    {\n        zAccountRegistrationCircuitId = _circuitId;\n    }\n\n    function unlockAssetFromVault(LockData calldata data) external {\n        require(vaultAssetUnlockers[msg.sender], ERR_UNAUTHORIZED);\n\n        // Trusted contract - no reentrancy guard needed\n        VAULT.unlockAsset(data);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot\n    /// @param inputs[13] - saltHash\n    /// @param inputs[14] - magicalConstraint\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory privateMessages,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        require(msg.sender == ZACCOUNT_REGISTRY, ERR_UNAUTHORIZED);\n        require(zAccountRegistrationCircuitId != 0, ERR_UNDEFINED_CIRCUIT);\n        {\n            uint256 zAccountNullifier = inputs[9];\n            require(zAccountNullifier != 0, ERR_ZERO_ZACCOUNT_NULLIFIER);\n        }\n        uint256 zAccountCommitment;\n        {\n            zAccountCommitment = inputs[10];\n            require(zAccountCommitment != 0, ERR_ZERO_ZACCOUNT_COMMIT);\n        }\n        {\n            uint256 kycSignedMessageHash = inputs[11];\n            require(kycSignedMessageHash != 0, ERR_ZERO_KYC_MSG_HASH);\n        }\n        {\n            uint256 saltHash = inputs[13];\n            require(saltHash != 0, ERR_ZERO_SALT_HASH);\n        }\n        {\n            uint256 magicalConstraint = inputs[14];\n            require(magicalConstraint != 0, ERR_ZERO_MAGIC_CONSTR);\n        }\n        require(\n            uint8(privateMessages[0]) == MT_UTXO_ZACCOUNT &&\n                privateMessages.length >= LMT_UTXO_ZACCOUNT,\n            ERR_NOT_WELLFORMED_SECRETS\n        );\n        // Must be less than 32 bits and NOT in the past\n        uint32 createTime = uint32(inputs[5]);\n        require(\n            uint256(createTime) == inputs[5] && createTime >= block.timestamp,\n            ERR_INVALID_CREATE_TIME\n        );\n\n        require(\n            isCachedRoot(bytes32(inputs[12]), cachedForestRootIndex),\n            ERR_INVALID_FOREST_ROOT\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        require(\n            VERIFIER.verify(zAccountRegistrationCircuitId, inputs, proof),\n            ERR_FAILED_ZK_PROOF\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        (uint32 queueId, uint8 indexInQueue) = BUS_TREE.addUtxoToBusQueue(\n            bytes32(zAccountCommitment)\n        );\n        utxoBusQueuePos = (uint256(queueId) << 8) | uint256(indexInQueue);\n\n        bytes memory transactionNoteContent = abi.encodePacked(\n            // First public message\n            MT_UTXO_CREATE_TIME,\n            createTime,\n            // Seconds public message\n            MT_UTXO_BUSTREE_IDS,\n            inputs[11], // zAccountCommitment\n            queueId,\n            indexInQueue,\n            // Private message(s)\n            privateMessages\n        );\n\n        emit TransactionNote(TT_ZACCOUNT_ACTIVATION, transactionNoteContent);\n    }\n}\n"
    },
    "contracts/protocol/PantherStaticTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\nimport \"./pantherForest/Constants.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\n\n// TODO: write PantherStaticTree 'title' and 'notice' (description) similarly to the contracts have\n// (updating the state of the PantherForest contract on a network).\n// It's a one-level quin tree that holds the roots of the following trees:\n// - ZAssetsTree,\n// - ZZonesTree,\n// - ProvidersKeys tree,\n// - ZAccountsBlacklist tree,\n// - ZNetworksTree\n//\n// It's supposed to run on the mainnet only.\n// Bridges keepers are expected to propagate its root to other networks\ncontract PantherStaticTree is\n    ImmutableOwnable,\n    ITreeRootGetter,\n    ITreeRootUpdater\n{\n    bytes32[50] private _gap;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant NUM_LEAFS = 5;\n\n    address public immutable PANTHER_FOREST;\n\n    address public immutable ZASSETS_TREE_CONTROLLER;\n    address public immutable ZACCOUNTS_BLACKLISTED_TREE_CONTROLLER;\n    address public immutable ZNETWORKS_TREE_CONTROLLER;\n    address public immutable ZZONES_TREE_CONTROLLER;\n    address public immutable PROVIDERS_KEYS_TREE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _staticTreeRoot;\n    bytes32[NUM_LEAFS] public leafs;\n\n    // mapping from leaf index to leaf owner\n    mapping(uint8 => address) public leafControllers;\n\n    event RootUpdated(\n        uint256 indexed leafIndex,\n        bytes32 updatedLeaf,\n        bytes32 updatedRoot\n    );\n\n    constructor(\n        address _owner,\n        address _pantherForest,\n        address _zAssetsTreeController,\n        address _zAccountsBlacklistedTreeController,\n        address _zNetworksTreeController,\n        address _zZnonesTreeController,\n        address _providersKeysTreeController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _zAssetsTreeController != address(0) &&\n                _zAccountsBlacklistedTreeController != address(0) &&\n                _zNetworksTreeController != address(0) &&\n                _zZnonesTreeController != address(0) &&\n                _providersKeysTreeController != address(0),\n            \"init: zero address\"\n        );\n\n        PANTHER_FOREST = _pantherForest;\n\n        ZASSETS_TREE_CONTROLLER = _zAssetsTreeController;\n        ZACCOUNTS_BLACKLISTED_TREE_CONTROLLER = _zAccountsBlacklistedTreeController;\n        ZNETWORKS_TREE_CONTROLLER = _zNetworksTreeController;\n        ZZONES_TREE_CONTROLLER = _zZnonesTreeController;\n        PROVIDERS_KEYS_TREE_CONTROLLER = _providersKeysTreeController;\n    }\n\n    function initialize() external onlyOwner {\n        require(_staticTreeRoot == bytes32(0), \"PF: Already initialized\");\n\n        for (uint8 i; i < NUM_LEAFS; ) {\n            leafs[i] = ITreeRootGetter(_getLeafController(i)).getRoot();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _staticTreeRoot = hash(leafs);\n    }\n\n    function setDebugRoot() external onlyOwner {\n        for (uint8 i; i < NUM_LEAFS; ) {\n            leafs[i] = ITreeRootGetter(_getLeafController(i)).getRoot();\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        _staticTreeRoot = hash(leafs);\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _staticTreeRoot;\n    }\n\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external {\n        require(msg.sender == _getLeafController(leafIndex), \"unauthorized\");\n\n        leafs[leafIndex] = updatedLeaf;\n        _staticTreeRoot = hash(leafs);\n\n        ITreeRootUpdater(PANTHER_FOREST).updateRoot(\n            _staticTreeRoot,\n            STATIC_TREE_FOREST_LEAF_INDEX\n        );\n\n        emit RootUpdated(leafIndex, updatedLeaf, _staticTreeRoot);\n    }\n\n    function _getLeafController(uint256 leafIndex)\n        internal\n        view\n        returns (address leafController)\n    {\n        require(leafIndex < NUM_LEAFS, \"PF: INVALID_LEAF_IND\");\n        if (leafIndex == ZASSET_STATIC_LEAF_INDEX)\n            leafController = ZASSETS_TREE_CONTROLLER;\n\n        if (leafIndex == ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX)\n            leafController = ZACCOUNTS_BLACKLISTED_TREE_CONTROLLER;\n\n        if (leafIndex == ZNETWORK_STATIC_LEAF_INDEX)\n            leafController = ZNETWORKS_TREE_CONTROLLER;\n\n        if (leafIndex == ZZONE_STATIC_LEAF_INDEX)\n            leafController = ZZONES_TREE_CONTROLLER;\n\n        if (leafIndex == PROVIDERS_KEYS_STATIC_LEAF_INDEX)\n            leafController = PROVIDERS_KEYS_TREE_CONTROLLER;\n    }\n\n    function hash(bytes32[5] memory input) private pure returns (bytes32) {\n        // We trust the caller provides all input values within the SNARK field\n        return PoseidonHashers.poseidonT6(input);\n    }\n}\n"
    },
    "contracts/protocol/PantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../common/Bytecode.sol\";\nimport { VerifyingKey } from \"../common/Types.sol\";\nimport \"./pantherVerifier/Verifier.sol\";\nimport \"./interfaces/IPantherVerifier.sol\";\n\ncontract PantherVerifier is Verifier, IPantherVerifier {\n    /// @inheritdoc IPantherVerifier\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        override\n        returns (VerifyingKey memory)\n    {\n        return loadVerifyingKey(circuitId);\n    }\n\n    /// @dev It reads the verifying key from bytecode at `address(circuitId)`\n    function loadVerifyingKey(uint160 circuitId)\n        internal\n        view\n        virtual\n        override\n        returns (VerifyingKey memory)\n    {\n        return\n            // Stored key MUST be `abi.encode`d and prepended by 0x00\n            abi.decode(\n                Bytecode.read(address(circuitId), DATA_OFFSET),\n                (VerifyingKey)\n            );\n    }\n\n    // Keys in deployed bytecode MUST be prepended by 0x00 (STOP opcode)\n    uint256 private constant DATA_OFFSET = 1;\n}\n"
    },
    "contracts/protocol/pantherVerifier/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport { SnarkProof, VerifyingKey } from \"../../common/Types.sol\";\nimport { DEAD_CODE_ADDRESS } from \"../../common/Constants.sol\";\nimport \"../interfaces/IVerifier.sol\";\nimport \"../crypto/EllipticCurveMath.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\n/// @dev This is slightly modified code generated by the `snarkjs` lib (v.0.6.9).\nabstract contract Verifier is EllipticCurveMath, IVerifier {\n    /// @inheritdoc IVerifier\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) public view override returns (bool isVerified) {\n        VerifyingKey memory vk = loadVerifyingKey(circuitId);\n        require(input.length + 1 == vk.ic.length, \"verifier-bad-input\");\n\n        // Compute the linear combination vk_x\n        G1Point memory vk_x = G1Point(0, 0);\n        for (uint256 i = 0; i < input.length; i++) {\n            require(input[i] < FIELD_SIZE, \"verifier-gte-snark-scalar-field\");\n            vk_x = addition(vk_x, scalar_mul(vk.ic[i + 1], input[i]));\n        }\n        vk_x = addition(vk_x, vk.ic[0]);\n\n        isVerified =\n            pairingProd4(\n                negate(proof.a),\n                proof.b,\n                vk.alfa1,\n                vk.beta2,\n                vk_x,\n                vk.gamma2,\n                proof.c,\n                vk.delta2\n            ) ||\n            // May ever be TRUE in local tests only, has no effect in prod env.\n            // (must follow computations above to better estimate gas in tests)\n            tx.origin == DEAD_CODE_ADDRESS;\n    }\n\n    function loadVerifyingKey(uint160 circuitId)\n        internal\n        view\n        virtual\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/ProvidersKeys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\n\nimport \"../common/UtilsLib.sol\";\nimport \"./errMsgs/ProvidersKeysErrMsgs.sol\";\nimport \"./crypto/BabyJubJub.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\n\nimport \"./providersKeys/ProvidersKeysSignatureVerifier.sol\";\nimport \"./pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport { PROVIDERS_KEYS_STATIC_LEAF_INDEX } from \"./pantherForest/Constants.sol\";\nimport { SIXTEEN_LEVELS, SIXTEEN_LEVEL_EMPTY_TREE_ROOT, ZERO_VALUE } from \"./pantherForest/zeroTrees/Constants.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport { G1Point } from \"../common/Types.sol\";\n\n/**\n * @title ProvidersKeys\n * @author Pantherprotocol Contributors\n * @notice It registers public keys of providers, such as KYC/KYT attesters,\n * zone operators, data escrow (or \"data safe\") operators.\n * Each public key is stored as a leaf of a binary merkle tree. Every time the\n * tree is updated, this contract calls `PantherStaticTree` smart contract to\n * notify on update of the tree root.\n * The contract owner allocates leafs (\"keyring\") to a provider and authorizes\n * an address that may register provider's keys.\n * This way a provider gets the \"keyring\" where the provider may put that many\n * keys as the owner allocated.\n * @dev Public keys are points in the BabyJubjub elliptic curve. The contract\n * does not check, however, if the key is a valid curve point.\n * Since the off-chain computation of the tree updates proved by the SNARK will\n * replace the on-chain computation in the next version, the \"incremental tree\"\n * algorithm is not applied (\"incremental tree\" is easier for operators since\n * `proofSiblings` unneeded as input params on tree leafs insertions/updates).\n */\ncontract ProvidersKeys is\n    ProvidersKeysSignatureVerifier,\n    BinaryUpdatableTree,\n    ImmutableOwnable,\n    ITreeRootGetter\n{\n    // solhint-disable var-name-mixedcase\n\n    uint256 private KEYS_TREE_DEPTH = SIXTEEN_LEVELS;\n    uint16 private constant MAX_KEYS = uint16(2**SIXTEEN_LEVELS - 1);\n\n    uint32 private REVOKED_KEY_EXPIRY = 0;\n    uint256 private MAX_TREE_LOCK_PERIOD = 30 days;\n\n    ITreeRootUpdater public immutable PANTHER_STATIC_TREE;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice keyring status\n    enum STATUS {\n        UNDEFINED,\n        ACTIVE,\n        SUSPENDED\n    }\n\n    /// @notice keyring parameters\n    struct Keyring {\n        address operator;\n        STATUS status;\n        uint16 numKeys;\n        uint16 numAllocKeys;\n        uint32 registrationBlock;\n        uint24 _unused;\n    }\n\n    /// @notice Mapping from keyring ID to Keyring data\n    mapping(uint16 => Keyring) public keyrings;\n\n    /// @notice Mapping from key index to keyring ID\n    mapping(uint16 => uint16) public keyringIds;\n\n    /// @dev Number of keyrings added (created) so far\n    uint16 private _numKeyrings;\n\n    /// @dev Number of public keys registered so far\n    uint16 private _totalNumRegisteredKeys;\n\n    /// @dev Number of leafs reserved for public keys so far\n    uint16 private _totalNumAllocatedKeys;\n\n    /// @dev (UNIX) time till when operators can't register/revoke/extend keys\n    /// @dev Owner may temporally disable the tree changes by operators to avoid\n    /// the \"race condition\" (if multiple parties try to update simultaneously)\n    uint32 private _treeLockedTillTime;\n\n    /// @dev Root of the merkle tree with registered keys\n    bytes32 private _treeRoot;\n\n    event KeyRegistered(\n        uint16 indexed keyringId,\n        uint16 indexed keyIndex,\n        bytes32 packedPubKey,\n        uint32 expiry\n    );\n    event KeyExtended(\n        uint16 indexed keyringId,\n        uint16 indexed keyIndex,\n        uint32 newExpiry\n    );\n    event KeyRevoked(uint16 indexed keyringId, uint16 indexed keyIndex);\n\n    event KeyringUpdated(\n        uint16 indexed keyringId,\n        address operator,\n        STATUS status,\n        uint16 numAllocKeys\n    );\n\n    event TreeLockUpdated(uint32 tillTime);\n\n    constructor(\n        address _owner,\n        uint8 keyringVersion,\n        address pantherStaticTree\n    ) ImmutableOwnable(_owner) ProvidersKeysSignatureVerifier(keyringVersion) {\n        require(pantherStaticTree != address(0), ERR_INIT_CONTRACT);\n\n        // trusted contract - no reentrancy guard needed\n        // slither-disable-next-line unchecked-transfer,reentrancy-events\n        PANTHER_STATIC_TREE = ITreeRootUpdater(pantherStaticTree);\n    }\n\n    modifier whenTreeUnlocked() {\n        _requireTreeIsUnlocked();\n        _;\n    }\n\n    modifier keyInKeyring(uint16 keyIndex, uint16 keyringId) {\n        require(keyringIds[keyIndex] == keyringId, ERR_KEY_IS_NOT_IN_KEYRING);\n        _;\n    }\n\n    function getStatistics()\n        external\n        view\n        returns (\n            uint16 numKeyrings,\n            uint16 totalNumRegisteredKeys,\n            uint16 totalNumAllocatedKeys,\n            uint32 treeLockedTillTime\n        )\n    {\n        numKeyrings = _numKeyrings;\n        totalNumRegisteredKeys = _totalNumRegisteredKeys;\n        totalNumAllocatedKeys = _totalNumAllocatedKeys;\n        treeLockedTillTime = _treeLockedTillTime;\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _treeRoot == bytes32(0) ? zeroRoot() : _treeRoot;\n    }\n\n    // @dev It does NOT check if the pubKey is a point on the BabyJubJub curve\n    function packPubKey(G1Point memory pubKey) public pure returns (bytes32) {\n        // Coordinates must be in the SNARK field\n        require(\n            BabyJubJub.isG1PointLowerThanFieldSize([pubKey.x, pubKey.y]),\n            ERR_NOT_IN_FIELD\n        );\n        return BabyJubJub.pointPack(pubKey);\n    }\n\n    function getKeyCommitment(G1Point memory pubKey, uint32 expiry)\n        public\n        pure\n        returns (bytes32 commitment)\n    {\n        // Next call reverts if the input is not in the SNARK field\n        commitment = PoseidonHashers.poseidonT4(\n            [bytes32(pubKey.x), bytes32(pubKey.y), bytes32(uint256(expiry))]\n        );\n    }\n\n    /// @notice Register a public key. Only the keyring operator may call.\n    function registerKey(\n        uint16 keyringId,\n        G1Point memory pubKey,\n        uint32 expiry,\n        bytes32[] memory proofSiblings,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenTreeUnlocked returns (uint16 keyIndex) {\n        require(expiry > _timeNow(), ERR_INVALID_KEY_EXPIRY);\n\n        bytes32 keyPacked = BabyJubJub.pointPack(pubKey);\n        address operator = recoverOperator(\n            keyringId,\n            keyPacked,\n            expiry,\n            v,\n            r,\n            s\n        );\n\n        Keyring memory keyring = _getOperatorActiveKeyringOrRevert(\n            keyringId,\n            operator\n        );\n\n        require(\n            keyring.numAllocKeys >= keyring.numKeys,\n            ERR_INSUFFICIENT_ALLOCATION\n        );\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n\n        keyIndex = _totalNumRegisteredKeys;\n        keyringIds[keyIndex] = keyringId;\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            ZERO_VALUE,\n            commitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        _totalNumRegisteredKeys = ++keyIndex;\n\n        keyring.numKeys++;\n        keyrings[keyringId] = keyring;\n\n        emit KeyRegistered(keyringId, keyIndex, keyPacked, expiry);\n    }\n\n    /// @notice Extend the key expiry time. Only the keyring operator may call.\n    function extendKeyExpiry(\n        G1Point memory pubKey,\n        uint32 expiry,\n        uint32 newExpiry,\n        uint16 keyIndex,\n        bytes32[] memory proofSiblings\n    ) external whenTreeUnlocked {\n        require(\n            newExpiry > _timeNow() && newExpiry > expiry,\n            ERR_INVALID_KEY_EXPIRY\n        );\n        uint16 keyringId = keyringIds[keyIndex];\n        _getOperatorActiveKeyringOrRevert(keyringId, msg.sender);\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n        bytes32 newCommitment = getKeyCommitment(pubKey, newExpiry);\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            commitment,\n            newCommitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        emit KeyExtended(keyringId, keyIndex, newExpiry);\n    }\n\n    /// @notice Update keyring operator. Only the (current) operator may call.\n    function updateKeyringOperator(uint16 keyringId, address newOperator)\n        external\n    {\n        require(newOperator != address(0), ERR_ZERO_OPERATOR_ADDRESS);\n\n        Keyring memory keyring = _getOperatorActiveKeyringOrRevert(\n            keyringId,\n            msg.sender\n        );\n        require(newOperator != msg.sender, ERR_SAME_OPERATOR);\n\n        keyring.operator = newOperator;\n        keyrings[keyringId] = keyring;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    /// @notice Revoke registered key. Either the operator or the owner may call.\n    /// @dev It sets the `expiry` to 0, which is an indicator of a revoked key.\n    function revokeKey(\n        uint16 keyringId,\n        uint16 keyIndex,\n        G1Point memory pubKey,\n        uint32 expiry,\n        bytes32[] calldata proofSiblings\n    ) external keyInKeyring(keyIndex, keyringId) {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n\n        if (keyring.operator == msg.sender) {\n            _requireTreeIsUnlocked();\n        } else {\n            require(OWNER == msg.sender, ERR_UNAUTHORIZED_OPERATOR);\n        }\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n\n        bytes32 newCommitment = getKeyCommitment(pubKey, REVOKED_KEY_EXPIRY);\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            commitment,\n            newCommitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        emit KeyRevoked(keyringId, keyIndex);\n    }\n\n    /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    function addKeyring(address operator, uint16 numAllocKeys)\n        external\n        onlyOwner\n    {\n        require(operator != address(0), ERR_ZERO_OPERATOR_ADDRESS);\n\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        numAllocatedKeys += numAllocKeys;\n        require(MAX_KEYS >= numAllocatedKeys, ERR_TOO_HIGH_ALLOCATION);\n\n        uint16 keyringId = _getNextKeyringId();\n        keyrings[keyringId] = Keyring({\n            operator: operator,\n            status: STATUS.ACTIVE,\n            numKeys: 0,\n            numAllocKeys: numAllocKeys,\n            registrationBlock: UtilsLib.safe32BlockNow(),\n            _unused: 0\n        });\n\n        _numKeyrings = keyringId;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(keyringId, operator, STATUS.ACTIVE, numAllocKeys);\n    }\n\n    function suspendKeyring(uint16 keyringId) external onlyOwner {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n\n        _totalNumAllocatedKeys -= _getUnusedKeyringAllocation(keyring);\n\n        keyrings[keyringId] = _suspendKeyring(keyring);\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function reactivateKeyring(uint16 keyringId) external onlyOwner {\n        Keyring memory keyring = keyrings[keyringId];\n        require(\n            keyring.status == STATUS.SUSPENDED,\n            ERR_KEYRING_ALREADY_ACTIVATED\n        );\n\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        // Unused allocation before suspending. To be allocated again.\n        uint16 keyringUnusedKeys = _getUnusedKeyringAllocation(keyring);\n        numAllocatedKeys += keyringUnusedKeys;\n\n        // When there is not enough empty keys to give back to keyring\n        if (numAllocatedKeys > MAX_KEYS) {\n            keyringUnusedKeys =\n                MAX_KEYS -\n                (numAllocatedKeys - keyringUnusedKeys);\n\n            numAllocatedKeys = MAX_KEYS;\n        }\n\n        keyring.status = STATUS.ACTIVE;\n        keyrings[keyringId] = keyring;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function increaseKeyringKeyAllocation(uint16 keyringId, uint16 allocation)\n        external\n        onlyOwner\n    {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        numAllocatedKeys += allocation;\n        require(MAX_KEYS >= numAllocatedKeys, ERR_TOO_HIGH_ALLOCATION);\n\n        uint16 newKeyringAllocation = keyring.numAllocKeys + allocation;\n\n        keyrings[keyringId].numAllocKeys = newKeyringAllocation;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function updateTreeLock(uint32 lockPeriod) external onlyOwner {\n        require(\n            lockPeriod <= MAX_TREE_LOCK_PERIOD,\n            ERR_TREE_LOCK_ALREADY_UPDATED\n        );\n        uint32 timestamp = UtilsLib.safe32(_timeNow() + lockPeriod);\n        _treeLockedTillTime = timestamp;\n\n        emit TreeLockUpdated(timestamp);\n    }\n\n    /* ========== INTERNAL & PRIVATE FUNCTIONS ========== */\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        // Next call reverts if the input is not in the SNARK field\n        return PoseidonHashers.poseidonT3(input);\n    }\n\n    function zeroRoot() internal pure override returns (bytes32) {\n        return SIXTEEN_LEVEL_EMPTY_TREE_ROOT;\n    }\n\n    function _getNextKeyringId() private view returns (uint16) {\n        return _numKeyrings + 1;\n    }\n\n    function _getActiveKeyringOrRevert(uint16 keyringId)\n        private\n        view\n        returns (Keyring memory keyring)\n    {\n        keyring = keyrings[keyringId];\n\n        require(keyring.operator != address(0), ERR_KEYRING_NOT_EXISTS);\n        require(keyring.status == STATUS.ACTIVE, ERR_KEYRING_NOT_ACTIVATED);\n    }\n\n    function _getOperatorActiveKeyringOrRevert(\n        uint16 keyringId,\n        address operator\n    ) private view returns (Keyring memory keyring) {\n        keyring = _getActiveKeyringOrRevert(keyringId);\n        require(keyring.operator == operator, ERR_UNAUTHORIZED_OPERATOR);\n    }\n\n    function _suspendKeyring(Keyring memory keyring)\n        private\n        pure\n        returns (Keyring memory)\n    {\n        keyring.status = STATUS.SUSPENDED;\n        return keyring;\n    }\n\n    function _getUnusedKeyringAllocation(Keyring memory keyring)\n        private\n        pure\n        returns (uint16)\n    {\n        return keyring.numAllocKeys - keyring.numKeys;\n    }\n\n    function _updateProvidersKeysAndStaticTreeRoots(\n        bytes32 leaf,\n        bytes32 newLeaf,\n        uint16 keyIndex,\n        bytes32[] memory proofSiblings\n    ) private {\n        require(\n            proofSiblings.length == KEYS_TREE_DEPTH,\n            ERR_INCORRECT_SIBLINGS_SIZE\n        );\n\n        bytes32 updatedRoot = update(\n            _treeRoot,\n            leaf,\n            newLeaf,\n            keyIndex,\n            proofSiblings\n        );\n\n        _treeRoot = updatedRoot;\n\n        // trusted contract - no reentrancy guard needed\n        // slither-disable-next-line unchecked-transfer,reentrancy-events\n        PANTHER_STATIC_TREE.updateRoot(\n            updatedRoot,\n            PROVIDERS_KEYS_STATIC_LEAF_INDEX\n        );\n    }\n\n    function _requireTreeIsUnlocked() private view {\n        require(_timeNow() >= _treeLockedTillTime, ERR_TREE_IS_LOCKED);\n    }\n\n    function _timeNow() private view returns (uint32) {\n        // Time comparison accuracy is acceptable\n        // slither-disable-next-line timestamp\n        return UtilsLib.safe32TimeNow();\n    }\n}\n"
    },
    "contracts/protocol/providersKeys/ProvidersKeysSignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../../common/EIP712SignatureVerifier.sol\";\n\nabstract contract ProvidersKeysSignatureVerifier is EIP712SignatureVerifier {\n    // solhint-disable var-name-mixedcase\n\n    bytes32 internal constant REGISTRATION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"Registration(uint32 keyringId,bytes32 pubRootSpendingKey,uint32 expiryDate,uint256 version)\"\n            )\n        );\n\n    uint8 public immutable KEYRING_VERSION;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(uint8 keyringVersion) {\n        KEYRING_VERSION = keyringVersion;\n    }\n\n    function getRegistrationDataHash(\n        uint32 _keyringId,\n        bytes32 _pubRootSpendingKey,\n        uint32 _expiryDate\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    REGISTRATION_TYPEHASH,\n                    _keyringId,\n                    _pubRootSpendingKey,\n                    _expiryDate,\n                    uint256(KEYRING_VERSION)\n                )\n            );\n    }\n\n    function recoverOperator(\n        uint32 _keyringId,\n        bytes32 _pubRootSpendingKey,\n        uint32 _expiryDate,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 registrationDataHash = getRegistrationDataHash(\n            _keyringId,\n            _pubRootSpendingKey,\n            _expiryDate\n        );\n\n        bytes32 typedDataHash = toTypedDataHash(registrationDataHash);\n\n        return recover(typedDataHash, v, r, s);\n    }\n}\n"
    },
    "contracts/protocol/PrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./errMsgs/PrpGrantorErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./interfaces/IPrpGrantor.sol\";\n\n/**\n * @title PrpGrantor\n * @notice It registers issuing and redemption of PRP-nominated \"grants\"\n * @dev The owner may add (enable) new \"grant types\" or remove (disable) existing types. For every\n * type, the owner specifies (authorizes) the account of the \"curator\" and the amount of the grant\n * (in Panther Reward Points, aka \"PRPs\").\n * A curator calls `issueGrant` on this contract to issue a \"grant\" of a certain type to a grantee.\n * The curator must be authorized by the owner for this grant type.\n * Independently from curators, the owner may call `issueOwnerGrant` to issue a grant to a grantee.\n * In this case the amount is specified as the call param, rather than via the grant type.\n * Every `issueGrant` or `issueOwnerGrant` call increases the amount (in PRPs) of \"unused grants\"\n * for the grantee.\n * The authorized \"processor\" (one for all grant types) may call `redeemGrant` to account for usage\n * (i.e.  redemption) of grants. Every `redeemGrant` call decreases the amount of unused grants for\n * the grantee.\n * Assumed:\n * - the \"processor\" is the `PantherPool` contract\n * - a grant is redeemed when the PantherPool creates a PRP-nominated UTXO for a grantee.\n */\ncontract PrpGrantor is ImmutableOwnable, IPrpGrantor {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // Max amount in PRPs\n    uint256 private constant MAX_PRP_GRANT = 2**32;\n\n    // To distinguish \"undefined\" from \"zero\"\n    uint256 private constant ZERO_AMOUNT = 1;\n    uint256 private constant UNDEF_AMOUNT = 0;\n\n    // bytes4(keccak('issueOwnerGrant(address,uint256)'))\n    bytes4 private constant OWNER_GRANT_TYPE = 0x479ed83f;\n\n    // Account authorized to call `redeemGrant`\n    address private immutable GRANT_PROCESSOR;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @dev Mapping from \"curator\" to \"grant type\" to \"grant amount in PRPs\"\n    /// To distinguish \"zero\" from \"undefined\", values are biased by `ZERO_AMOUNT`\n    mapping(address => mapping(bytes4 => uint256)) private _prpGrantsAmounts;\n\n    /// @dev mapping from \"grantee\" to the PRP amount that may be \"used\"\n    mapping(address => uint256) private _unusedPrpGrants;\n\n    // Total amount (in PRPs) of grants issued so far\n    uint256 public override totalGrantsIssued;\n\n    // Total amount (in PRPs) of grants redeemed so far\n    // (excluding burnt grants amounts)\n    uint256 public override totalGrantsRedeemed;\n\n    // slither-disable-next-line similar-names\n    constructor(address _owner, address _grantProcessor)\n        ImmutableOwnable(_owner)\n    {\n        // As it runs behind the DELEGATECALL'ing proxy, initialization of\n        // immutable \"vars\" only is allowed in the constructor\n        require(_grantProcessor != address(0), ERR_ZERO_PROCESSOR_ADDR);\n        GRANT_PROCESSOR = _grantProcessor;\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function grantProcessor() external view override returns (address) {\n        return GRANT_PROCESSOR;\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        override\n        returns (uint256 prpAmount)\n    {\n        return _unusedPrpGrants[grantee];\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function getGrantAmount(address curator, bytes4 grantType)\n        external\n        view\n        override\n        returns (uint256 prpAmount)\n    {\n        prpAmount = _prpGrantsAmounts[curator][grantType];\n        _revertOnUndefPrpAmount(prpAmount);\n        // In this and other `unchecked` blocks, over/underflow impossible since:\n        // - prpAmount is limited when granted and can never exceed MAX_PRP_GRANT\n        // - prpAmount's summation (accumulation) can't practically exceed 2**256\n        // - prpAmount is checked to be equal or more than the value subtracted\n        // - prpAmount checked to be less or equal the value it's subtracted from\n        unchecked {\n            prpAmount -= ZERO_AMOUNT;\n        }\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function issueGrant(address grantee, bytes4 grantType)\n        external\n        override\n        nonZeroGrantType(grantType)\n        returns (uint256 prpAmount)\n    {\n        require(grantee != address(0), ERR_ZERO_GRANTEE_ADDR);\n        prpAmount = _prpGrantsAmounts[msg.sender][grantType];\n        _revertOnUndefPrpAmount(prpAmount);\n        unchecked {\n            prpAmount -= ZERO_AMOUNT;\n        }\n        _issueGrant(grantee, prpAmount, grantType);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function issueOwnerGrant(address grantee, uint256 prpAmount)\n        external\n        override\n        onlyOwner\n    {\n        require(grantee != address(0), ERR_ZERO_GRANTEE_ADDR);\n        _revertOnTooBigPrpAmount(prpAmount);\n        _issueGrant(grantee, prpAmount, OWNER_GRANT_TYPE);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function burnGrant(uint256 prpAmount) external override {\n        uint256 oldBalance = _unusedPrpGrants[msg.sender];\n        require(oldBalance >= prpAmount, ERR_LOW_GRANT_BALANCE);\n        unchecked {\n            _unusedPrpGrants[msg.sender] = oldBalance - prpAmount;\n            totalGrantsIssued -= prpAmount;\n        }\n        emit PrpGrantBurnt(msg.sender, prpAmount);\n    }\n\n    /// @inheritdoc IPrpGrantor\n    function redeemGrant(address grantee, uint256 prpAmount) external override {\n        require(msg.sender == GRANT_PROCESSOR, ERR_UNAUTHORIZED_CALL);\n        uint256 oldBalance = _unusedPrpGrants[grantee];\n        require(oldBalance >= prpAmount, ERR_LOW_GRANT_BALANCE);\n        unchecked {\n            _unusedPrpGrants[grantee] = oldBalance - prpAmount;\n            totalGrantsRedeemed += prpAmount;\n        }\n        emit PrpGrantRedeemed(grantee, prpAmount);\n    }\n\n    /// @dev Add a new \"grant type\", with the specified amount (in PRPs) of the grant, and\n    /// allow the specified \"curator\" to issue grants of this type (by calling `issueGrant`).\n    /// Only the owner may call.\n    function enableGrantType(\n        address curator,\n        bytes4 grantType,\n        uint256 prpAmount\n    ) external onlyOwner nonZeroGrantType(grantType) {\n        require(curator != address(0), ERR_ZERO_CURATOR_ADDR);\n        _revertOnTooBigPrpAmount(prpAmount);\n        require(\n            _prpGrantsAmounts[curator][grantType] == UNDEF_AMOUNT,\n            ERR_GRANT_TYPE_EXISTS\n        );\n        _prpGrantsAmounts[curator][grantType] = ZERO_AMOUNT + prpAmount;\n        emit PrpGrantEnabled(curator, grantType, prpAmount);\n    }\n\n    /// @dev Disable previously enabled \"grant type\".\n    /// Only the owner may call.\n    function disableGrantType(address curator, bytes4 grantType)\n        external\n        onlyOwner\n        nonZeroGrantType(grantType)\n    {\n        _revertOnUndefPrpAmount(_prpGrantsAmounts[curator][grantType]);\n        _prpGrantsAmounts[curator][grantType] = UNDEF_AMOUNT;\n        emit PrpGrantDisabled(curator, grantType);\n    }\n\n    /// Modifiers and private functions follow\n\n    modifier nonZeroGrantType(bytes4 grantType) {\n        require(grantType != bytes4(0), ERR_UKNOWN_GRANT_TYPE);\n        _;\n    }\n\n    function _revertOnTooBigPrpAmount(uint256 prpAmount) private pure {\n        require(prpAmount <= MAX_PRP_GRANT, ERR_TOO_LARGE_GRANT_AMOUNT);\n    }\n\n    function _revertOnUndefPrpAmount(uint256 prpAmount) private pure {\n        require(prpAmount != UNDEF_AMOUNT, ERR_UNDEF_GRANT);\n    }\n\n    function _issueGrant(\n        address grantee,\n        uint256 prpAmount,\n        bytes4 grantType\n    ) private {\n        unchecked {\n            if (prpAmount != 0) {\n                uint256 newBalance = _unusedPrpGrants[grantee] + prpAmount;\n                _revertOnTooBigPrpAmount(newBalance);\n                _unusedPrpGrants[grantee] = newBalance;\n                totalGrantsIssued += prpAmount;\n            }\n        }\n        emit PrpGrantIssued(grantType, grantee, prpAmount);\n    }\n}\n"
    },
    "contracts/protocol/triadTree/Hasher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\n/*\n * @dev Poseidon hash functions\n */\nabstract contract Hasher {\n    function hash(bytes32 left, bytes32 right) internal pure returns (bytes32) {\n        bytes32[2] memory input;\n        input[0] = left;\n        input[1] = right;\n        return PoseidonT3.poseidon(input);\n    }\n\n    function hash(\n        bytes32 left,\n        bytes32 mid,\n        bytes32 right\n    ) internal pure returns (bytes32) {\n        bytes32[3] memory input;\n        input[0] = left;\n        input[1] = mid;\n        input[2] = right;\n        return PoseidonT4.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/triadTree/TriadIncrementalMerkleTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./Hasher.sol\";\nimport \"./TriadMerkleZeros.sol\";\nimport { ERR_ZERO_ROOT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../interfaces/IRootsHistory.sol\";\n\n/**\n * @title TriadIncrementalMerkleTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees with batch insertion of 3 leaves at once\n * @dev Refer to {TriadMerkleZeros} for comments on \"triad trees\" used\n * Inspired by MACI project\n * https://github.com/appliedzkp/maci/blob/master/contracts/sol/IncrementalMerkleTree.sol\n */\ncontract TriadIncrementalMerkleTrees is\n    TriadMerkleZeros,\n    Hasher,\n    IRootsHistory\n{\n    /**\n     * @dev {treeId} is a consecutive number of trees, starting from 0.\n     * @dev {leafId} of a leaf is a \"modified\" number of leaves inserted in all\n     * tries before this leaf. It is unique across all trees, starts from 0 for\n     * the 1st leaf of the 1st tree, and constantly increments like this:\n     * 0,1,2,  4,5,6,  8,9,10,  12,13,14 ... (i.e. every 4th number is skipped)\n     * See comments to {TriadMerkleZeros}.\n     */\n\n    // `leafId` of the next leaf to insert\n    // !!! NEVER access it directly from child contracts: `internal` to ease testing only\n    uint256 internal _nextLeafId;\n\n    // Right-most elements (hashes) in the current tree per level\n    // level index => hash\n    mapping(uint256 => bytes32) private _filledSubtrees;\n\n    /// @notice Roots of fully populated trees\n    /// @dev treeId => root\n    mapping(uint256 => bytes32) public finalRoots;\n\n    // Recent roots of trees seen\n    // cacheIndex => root ^ treeId\n    mapping(uint256 => uint256) private _cachedRoots;\n\n    // @dev Root permanently added to the `finalRoots`\n    event AnchoredRoot(uint256 indexed treeId, bytes32 root);\n\n    // @dev Root temporarily saved in the `_cachedRoots`\n    event CachedRoot(uint256 indexed treeId, bytes32 root);\n\n    // NOTE: No `constructor` (initialization) function needed\n\n    // solhint-disable const-name-snakecase\n\n    // Max number of latest roots to cache (must be a power of 2)\n    uint256 internal constant CACHED_ROOTS_NUM = 256;\n\n    // Number of leaves in a modified triad used for leaf ID calculation\n    uint256 private constant iTRIAD_SIZE = 4;\n    // The number of leaves in a tree used for leaf ID calculation\n    uint256 private constant iLEAVES_NUM = 2**(TREE_DEPTH - 1) * iTRIAD_SIZE;\n\n    // Bitmasks and numbers of bits for \"cheaper\" arithmetics\n    uint256 private constant iTRIAD_SIZE_MASK = iTRIAD_SIZE - 1;\n    uint256 private constant iTRIAD_SIZE_BITS = 2;\n    uint256 private constant iLEAVES_NUM_MASK = iLEAVES_NUM - 1;\n    uint256 private constant iLEAVES_NUM_BITS =\n        TREE_DEPTH - 1 + iTRIAD_SIZE_BITS;\n    uint256 private constant CACHE_SIZE_MASK =\n        CACHED_ROOTS_NUM * iTRIAD_SIZE - 1;\n\n    // solhint-enable const-name-snakecase\n\n    /**\n     * @notice Returns the number of leaves inserted in all trees so far\n     */\n    function leavesNum() external view returns (uint256) {\n        return _nextLeafId2LeavesNum(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the current tree\n     */\n    function curTree() external view returns (uint256) {\n        return getTreeId(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the given leaf's tree\n     */\n    function getTreeId(uint256 leafId) public pure returns (uint256) {\n        // equivalent to `leafId / iLEAVES_NUM`\n        return leafId >> iLEAVES_NUM_BITS;\n    }\n\n    /**\n     * @notice Returns `leafIndex` (index in the tree) of the given leaf\n     */\n    function getLeafIndex(uint256 leafId) public pure returns (uint256) {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return iIndex - fullTriadsNum; // start index of first leaf in the triad\n        }\n    }\n\n    /**\n     * @notice Returns the root of the current tree and its index in cache\n     */\n    function curRoot()\n        external\n        view\n        returns (bytes32 root, uint256 cacheIndex)\n    {\n        // Return zero root and index if the current tree is empty\n        uint256 nextLeafId = _nextLeafId;\n        if (_isEmptyTree(nextLeafId)) return (ZERO_ROOT, 0);\n\n        // Return cached values otherwise\n        uint256 treeId = getTreeId(nextLeafId);\n        cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n        uint256 v = _cachedRoots[cacheIndex];\n        root = bytes32(v ^ treeId);\n    }\n\n    /// @inheritdoc IRootsHistory\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) public view override returns (bool) {\n        require(root != 0, ERR_ZERO_ROOT);\n\n        // if hint provided, use hint\n        if (cacheIndexHint != 0)\n            return _isCorrectCachedRoot(treeId, root, cacheIndexHint);\n\n        // then, check the history\n        if (finalRoots[treeId] == root) return true;\n\n        // finally, look in cache, starting from the current root\n        uint256 leafId = _nextLeafId;\n        unchecked {\n            uint256 i = CACHED_ROOTS_NUM;\n            while ((leafId >= iTRIAD_SIZE) && (i != 0)) {\n                i -= 1;\n                // Skip the last triad in a tree (i.e. the full tree root)\n                if (leafId & iLEAVES_NUM_MASK == 0) continue;\n                uint256 cacheIndex = _nextLeafId2CacheIndex(leafId);\n                if (_isCorrectCachedRoot(treeId, root, cacheIndex)) return true;\n                leafId -= iTRIAD_SIZE;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Inserts 3 leaves into the current tree, or a new one, if that's full\n     * @param leaves The 3 leaves to insert (must be less than SNARK_SCALAR_FIELD)\n     * @return leftLeafId The `leafId` of the first leaf from 3 inserted\n     */\n    function insertBatch(bytes32[TRIAD_SIZE] memory leaves)\n        internal\n        returns (uint256 leftLeafId)\n    {\n        leftLeafId = _nextLeafId;\n\n        // here the variable is intentionally declared only ...\n        // slither-disable-next-line uninitialized-local\n        bytes32[TREE_DEPTH] memory zeros;\n        // ... and initialized in this call\n        populateZeros(zeros);\n\n        // index of a \"current\" node (0 for the leftmost node/leaf of a level)\n        uint256 nodeIndex;\n        // hash (value) of a \"current\" node\n        bytes32 nodeHash;\n        // index of a \"current\" level (0 for leaves, increments toward root)\n        uint256 level;\n\n        // subtree from 3 leaves being inserted on `level = 0`\n        nodeHash = hash(leaves[0], leaves[1], leaves[2]);\n        // ... to be placed under this index on `level = 1`\n        // (equivalent to `(leftLeafId % iLEAVES_NUM) / iTRIAD_SIZE`)\n        nodeIndex = (leftLeafId & iLEAVES_NUM_MASK) >> iTRIAD_SIZE_BITS;\n\n        bytes32 left;\n        bytes32 right;\n        for (level = 1; level < TREE_DEPTH; level++) {\n            // if `nodeIndex` is, say, 25, over the iterations it will be:\n            // 25, 12, 6, 3, 1, 0, 0 ...\n\n            if (nodeIndex % 2 == 0) {\n                left = nodeHash;\n                right = zeros[level];\n                _filledSubtrees[level] = nodeHash;\n            } else {\n                // for a new tree, \"than\" block always run before \"else\" block\n                // so `_filledSubtrees[level]` gets updated before its use\n                left = _filledSubtrees[level];\n                right = nodeHash;\n            }\n\n            nodeHash = hash(left, right);\n\n            // equivalent to `nodeIndex /= 2`\n            nodeIndex >>= 1;\n        }\n\n        uint256 nextLeafId = leftLeafId + iTRIAD_SIZE;\n        _nextLeafId = nextLeafId;\n\n        uint256 treeId = getTreeId(leftLeafId);\n        if (_isFullTree(leftLeafId)) {\n            // Switch to a new tree\n            // Ignore `_filledSubtrees` old values as they are never re-used\n            finalRoots[treeId] = nodeHash;\n            emit AnchoredRoot(treeId, nodeHash);\n        } else {\n            uint256 cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n            _cachedRoots[cacheIndex] = uint256(nodeHash) ^ treeId;\n            emit CachedRoot(treeId, nodeHash);\n        }\n    }\n\n    /// private functions follow (some of them made `internal` to ease testing)\n    function _isFullTree(uint256 leftLeafId) internal pure returns (bool) {\n        unchecked {\n            return\n                (iLEAVES_NUM - (leftLeafId & iLEAVES_NUM_MASK)) <= iTRIAD_SIZE;\n        }\n    }\n\n    function _isEmptyTree(uint256 nextLeafId) internal pure returns (bool) {\n        return (nextLeafId & iLEAVES_NUM_MASK) == 0;\n    }\n\n    function _nextLeafId2LeavesNum(\n        uint256 nextLeafId // declared as `internal` to facilitate testing\n    ) internal pure returns (uint256) {\n        // equiv to `nextLeafId / iTRIAD_SIZE * TRIAD_SIZE + nextLeafId % iTRIAD_SIZE`\n        unchecked {\n            return\n                (nextLeafId >> iTRIAD_SIZE_BITS) *\n                TRIAD_SIZE +\n                (nextLeafId & iTRIAD_SIZE_MASK);\n        }\n    }\n\n    // Returns `triadIndex` index in the triad-node of the given leaf = { 0, 1, 2 }\n    function _getTriadIndex(uint256 leafId) internal pure returns (uint256) {\n        return getLeafIndex(leafId) % TRIAD_SIZE;\n    }\n\n    // Returns `triadNodeIndex` index of the triad-node of the given leaf\n    // This index is the path to this node - used by anyone who needs the path\n    function _getTriadNodeIndex(uint256 leafId)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return fullTriadsNum;\n        }\n    }\n\n    // nextLeafId must be even\n    function _nextLeafId2CacheIndex(uint256 nextLeafId)\n        private\n        pure\n        returns (uint256)\n    {\n        // equiv to `nextLeafId % (CACHED_ROOTS_NUM * iTRIAD_SIZE) + 1`\n        return (nextLeafId & CACHE_SIZE_MASK) | 1;\n    }\n\n    function _isCorrectCachedRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndex\n    ) private view returns (bool) {\n        uint256 v = _cachedRoots[cacheIndex];\n        return v == (uint256(root) ^ treeId);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/triadTree/TriadMerkleZeros.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\n// Content is autogenerated by `lib/triadMerkleZerosContractGenerator.ts`\n\n/**\n * @dev The \"triad binary tree\" is a modified Merkle (full) binary tree with:\n * - every node, from the root upto the level preceding leaves, excluding\n * that level, has 2 child nodes (i.e. this subtree is a full binary tree);\n * - every node of the layer preceding leaves has 3 child nodes (3 leaves).\n * Example:\n * [4]                                       0\n *                                           |\n * [3]                        0--------------------------------1\n *                            |                                |\n * [2]                0---------------1                 2--------------3\n *                    |               |                 |              |\n * [1]            0-------1       2-------3        4-------5       6-------7\n *               /|\\     /|\\     /|\\     /|\\      /|\\     /|\\     /|\\     /|\\\n * [0] index:   0..2    3..5    6..8    9...11  12..14  15..17  18..20  21..24\n *\n *   leaf ID:   0..2    4..6    8..10   12..14  16..18  20..23  24..27  28..30\n *\n * - Number in [] is the \"level index\" that starts from 0 for the leaves level.\n * - Numbers in node/leaf positions are \"node/leaf indices\" which starts from 0\n *   for the leftmost node/leaf of every level.\n * - Numbers bellow leaves are IDs of leaves.\n *\n * Arithmetic operations with multiples of 2 (i.e. shifting) is \"cheaper\" than\n * operations with multiples of 3 (both on-chain and in zk-circuits).\n * Therefore, IDs of leaves (but NOT hashes of nodes) are calculated as if the\n * tree would have 4 (not 3) leaves in branches, with every 4th leaf skipped.\n * In other words, there are no leaves with IDs 3, 7, 11, 15, 19...\n */\n\n// @notice The \"triad binary tree\" populated with zero leaf values\nabstract contract TriadMerkleZeros {\n    // solhint-disable var-name-mixedcase\n\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 internal constant TREE_DEPTH = 15;\n\n    // Number of leaves in a branch with the root on the level 1\n    uint256 internal constant TRIAD_SIZE = 3;\n\n    // @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n    bytes32 internal constant ZERO_VALUE =\n        bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n\n    // Merkle root of a tree that contains zeros only\n    bytes32 internal constant ZERO_ROOT =\n        bytes32(\n            uint256(\n                0x20fc043586a9fcb416cdf2a3bc8a995f8f815d43f1046a20d1c588cf20482a55\n            )\n        );\n\n    // solhint-enable var-name-mixedcase\n\n    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {\n        zeros[0] = bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n        zeros[1] = bytes32(\n            uint256(\n                0x1be18cd72ac1586de27dd60eba90654bd54383004991951bccb0f6bad02c67f6\n            )\n        );\n        zeros[2] = bytes32(\n            uint256(\n                0x7677e6102f0acf343edde864f79ef7652faa5a66d575b8b60bb826a4aa517e6\n            )\n        );\n        zeros[3] = bytes32(\n            uint256(\n                0x28a85866ab97bd65cc94b0d1f5c5986481f8a0d65bdd5c1e562659eebb13cf63\n            )\n        );\n        zeros[4] = bytes32(\n            uint256(\n                0x87321a66ea3af7780128ea1995d7fc6ec44a96a1b2d85d3021208cede68c15c\n            )\n        );\n        zeros[5] = bytes32(\n            uint256(\n                0x233b4e488f0aaf5faef4fc8ea4fefeadb6934eb882bc33b9df782fd1d83b41a0\n            )\n        );\n        zeros[6] = bytes32(\n            uint256(\n                0x1a0cefcf0c592da6426717d3718408c61af1d0a9492887f3faecefcba1a0a309\n            )\n        );\n        zeros[7] = bytes32(\n            uint256(\n                0x2cdf963150b321923dd07b2b52659aceb529516a537dfebe24106881dd974293\n            )\n        );\n        zeros[8] = bytes32(\n            uint256(\n                0x93a186bf9ec2cc874ceab26409d581579e1a431ecb6987d428777ceedfa15c4\n            )\n        );\n        zeros[9] = bytes32(\n            uint256(\n                0xcbfc07131ef4197a4b4e60153d43381520ec9ab4c9c3ed34d88883a881a4e07\n            )\n        );\n        zeros[10] = bytes32(\n            uint256(\n                0x17b31de43ba4c687cf950ad00dfbe33df40047e79245b50bd1d9f87e622bf2af\n            )\n        );\n        zeros[11] = bytes32(\n            uint256(\n                0x2f3328354bceaf5882a8cc88053e0dd0ae594009a4e84e9e75a4fefe8604a602\n            )\n        );\n        zeros[12] = bytes32(\n            uint256(\n                0x2b2e8defd4dad2404c6874918925fc1192123f45df0ee3e04b6c16ff22ca1cfd\n            )\n        );\n        zeros[13] = bytes32(\n            uint256(\n                0x1cbdc4065aa4137da01d64a090706267d65f425ea5e815673516d29d9aa14d38\n            )\n        );\n        zeros[14] = bytes32(\n            uint256(\n                0x13ca69f9fde4ece39e395bb55dd41ed7dd9dfaa26671e26bd9fd6f4f635fc872\n            )\n        );\n    }\n}\n"
    },
    "contracts/protocol/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, ERC721_TOKEN_TYPE, ERC1155_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport \"./errMsgs/VaultErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/TransferHelper.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./vault/OnERC1155Received.sol\";\nimport \"./vault/OnERC721Received.sol\";\n\n/**\n * @title Vault\n * @author Pantherprotocol Contributors\n * @notice Holder of assets (tokens) for `PantherPool` contract\n * @dev It transfers assets from user to itself (Lock) and vice versa (Unlock).\n * `PantherPool` is assumed to be the `owner` that is authorized to trigger\n * locking/unlocking assets.\n */\ncontract Vault is\n    ImmutableOwnable,\n    OnERC721Received,\n    OnERC1155Received,\n    IVault\n{\n    using TransferHelper for address;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function lockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // Owner, who only may call this code, is trusted to protect\n            // against \"Arbitrary from in transferFrom\" vulnerability\n            // slither-disable-next-line arbitrary-send-erc20,reentrancy-benign,reentrancy-events\n            data.token.safeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.extAmount\n            );\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                data.extAccount,\n                address(this)\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.tokenId,\n                uint256(data.extAmount),\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Locked(data);\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function unlockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.safeTransfer(data.extAccount, data.extAmount);\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                address(this),\n                data.extAccount\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                address(this),\n                data.extAccount,\n                data.tokenId,\n                data.extAmount,\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Unlocked(data);\n    }\n\n    modifier checkLockData(LockData calldata data) {\n        require(data.token != address(0), ERR_ZERO_LOCK_TOKEN_ADDR);\n        require(data.extAccount != address(0), ERR_ZERO_EXT_ACCOUNT_ADDR);\n        require(data.extAmount > 0, ERR_ZERO_EXT_AMOUNT);\n        _;\n    }\n}\n"
    },
    "contracts/protocol/vault/OnERC1155Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of ERC1155:onERC1155Received interface\nabstract contract OnERC1155Received {\n    // It accepts all tokens\n    function onERC1155Received(\n        address, /* operator */\n        address, /* from */\n        uint256, /* id */\n        uint256, /* value */\n        bytes calldata /* data */\n    ) external pure virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n}\n"
    },
    "contracts/protocol/vault/OnERC721Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of the ERC721TokenReceiver interface\nabstract contract OnERC721Received {\n    // It accepts all tokens\n    function onERC721Received(\n        address, // operator\n        address, // from\n        uint256, // tokenId\n        bytes memory // data\n    ) external virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n        return 0x150b7a02;\n    }\n}\n"
    },
    "contracts/protocol/ZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./interfaces/IOnboardingController.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\n\nimport \"./crypto/BabyJubJub.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\n\nimport \"./zAccountsRegistry/BlacklistedZAccountIdsTree.sol\";\nimport \"./zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/UtilsLib.sol\";\nimport { ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX } from \"./pantherForest/Constants.sol\";\n\n/**\n * @title ZAccountsRegistry\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of zAccounts allowed to interact with MASP.\n */\n\n// solhint-disable contract-name-camelcase\ncontract ZAccountsRegistry is\n    ImmutableOwnable,\n    BlacklistedZAccountIdsTree,\n    ZAccountsRegeistrationSignatureVerifier\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    enum ZACCOUNT_STATUS {\n        UNDEFINED,\n        REGISTERED,\n        ACTIVATED\n    }\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant ZACCOUNT_ID_COUNTER_JUMP = 2;\n\n    IPantherPoolV1 public immutable PANTHER_POOL;\n    ITreeRootUpdater public immutable PANTHER_STATIC_TREE;\n    IOnboardingController public immutable ONBOARDING_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    struct ZAccount {\n        uint224 _unused; // reserved\n        uint24 id; // the ZAccount id, starts from 0\n        uint8 version; // ZAccount version\n        bytes32 pubRootSpendingKey;\n        bytes32 pubReadingKey;\n    }\n\n    uint256 public zAccountIdTracker;\n\n    mapping(bytes32 => uint256) public zoneZAccountNullifiers;\n    mapping(address => ZACCOUNT_STATUS) public zAccountStatus;\n    mapping(address => bool) public isMasterEoaBlacklisted;\n    mapping(bytes32 => bool) public isPubRootSpendingKeyBlacklisted;\n    mapping(uint24 => bool) public isZAccountIdBlacklisted;\n\n    // Mapping from `MasterEoa` to ZAccount (i.e. params of an ZAccount)\n    mapping(address => ZAccount) public zAccounts;\n\n    // Mapping from zAccount Id to Master Eoa\n    mapping(uint24 => address) public masterEOAs;\n\n    event ZAccountRegistered(address masterEoa, ZAccount zAccount);\n    event ZAccountActivated(uint24 id);\n    event BlacklistForZAccountIdUpdated(uint24 zAccountId, bool isBlackListed);\n    event BlacklistForMasterEoaUpdated(address masterEoa, bool isBlackListed);\n    event BlacklistForPubRootSpendingKeyUpdated(\n        bytes32 packedPubRootSpendingKey,\n        bool isBlackListed\n    );\n\n    constructor(\n        address _owner,\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingController\n    )\n        ImmutableOwnable(_owner)\n        ZAccountsRegeistrationSignatureVerifier(_zAccountVersion)\n    {\n        require(\n            pantherPool != address(0) &&\n                pantherStaticTree != address(0) &&\n                onboardingController != address(0),\n            ERR_INIT_CONTRACT\n        );\n\n        PANTHER_POOL = IPantherPoolV1(pantherPool);\n        PANTHER_STATIC_TREE = ITreeRootUpdater(pantherStaticTree);\n        ONBOARDING_CONTROLLER = IOnboardingController(onboardingController);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function isZAccountWhitelisted(address _masterEOA)\n        external\n        view\n        returns (bool isWhitelisted)\n    {\n        ZAccount memory _zAccount = zAccounts[_masterEOA];\n\n        bool isZAccountExists = masterEOAs[_zAccount.id] != address(0);\n\n        (bool isBlacklisted, ) = _isBlacklisted(\n            _zAccount.id,\n            _masterEOA,\n            _zAccount.pubRootSpendingKey\n        );\n\n        return isZAccountExists && !isBlacklisted;\n    }\n\n    /* ========== EXTERNAL FUNCTIONS ========== */\n\n    function registerZAccount(\n        G1Point memory _pubRootSpendingKey,\n        G1Point memory _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 pubRootSpendingKeyPacked = BabyJubJub.pointPack(\n            _pubRootSpendingKey\n        );\n        bytes32 pubReadingKeyPacked = BabyJubJub.pointPack(_pubReadingKey);\n\n        require(\n            !isPubRootSpendingKeyBlacklisted[pubRootSpendingKeyPacked],\n            ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n        );\n\n        address masterEoa = recoverMasterEoa(\n            pubRootSpendingKeyPacked,\n            pubReadingKeyPacked,\n            v,\n            r,\n            s\n        );\n\n        require(!isMasterEoaBlacklisted[masterEoa], ERR_BLACKLIST_MASTER_EOA);\n        require(\n            zAccountStatus[masterEoa] == ZACCOUNT_STATUS.UNDEFINED,\n            ERR_DUPLICATED_MASTER_EOA\n        );\n\n        uint24 zAccountId = uint24(_getNextZAccountId());\n\n        ZAccount memory _zAccount = ZAccount({\n            _unused: uint224(0),\n            id: zAccountId,\n            version: uint8(ZACCOUNT_VERSION),\n            pubRootSpendingKey: pubRootSpendingKeyPacked,\n            pubReadingKey: pubReadingKeyPacked\n        });\n\n        masterEOAs[zAccountId] = masterEoa;\n        zAccounts[masterEoa] = _zAccount;\n        zAccountStatus[masterEoa] = ZACCOUNT_STATUS.REGISTERED;\n\n        emit ZAccountRegistered(masterEoa, _zAccount);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange (passed w/o checks)\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime (passed w/o checks)\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot (passed w/o checks)\n    /// @param inputs[13] - saltHash (passed w/o checks)\n    /// @param inputs[14] - magicalConstraint (passed w/o checks)\n    function activateZAccount(\n        uint256[] calldata inputs,\n        bytes memory privateMessages,\n        SnarkProof calldata proof,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        {\n            uint256 extraInputsHash = inputs[0];\n            bytes memory extraInp = abi.encodePacked(\n                privateMessages,\n                cachedForestRootIndex\n            );\n            require(\n                extraInputsHash == uint256(keccak256(extraInp)) % FIELD_SIZE,\n                ERR_INVALID_EXTRA_INPUT_HASH\n            );\n        }\n        {\n            uint256 zAccountPrpAmount = inputs[4];\n            // No PRP rewards provided on zAccount activation\n            require(zAccountPrpAmount == 0, ERR_UNEXPECTED_PRP_AMOUNT);\n        }\n\n        uint24 zAccountId = UtilsLib.safe24(inputs[3]);\n        address zAccountMasterEOA = address(uint160(inputs[8]));\n\n        require(\n            masterEOAs[zAccountId] == zAccountMasterEOA,\n            ERR_UNKNOWN_ZACCOUNT\n        );\n\n        {\n            bytes32 zAccountRootSpendPubKey = BabyJubJub.pointPack(\n                G1Point({ x: inputs[6], y: inputs[7] })\n            );\n            (bool isBlacklisted, string memory errMsg) = _isBlacklisted(\n                zAccountId,\n                zAccountMasterEOA,\n                zAccountRootSpendPubKey\n            );\n            require(!isBlacklisted, errMsg);\n        }\n        {\n            // Prevent double-activation for the same zone and network\n            bytes32 zAccountNullifier = bytes32(inputs[9]);\n            require(\n                zoneZAccountNullifiers[zAccountNullifier] == 0,\n                ERR_DUPLICATED_NULLIFIER\n            );\n\n            zoneZAccountNullifiers[zAccountNullifier] = block.number;\n        }\n\n        ZACCOUNT_STATUS userPrevStatus = zAccountStatus[zAccountMasterEOA];\n\n        // if the status is registered, then change it to activate.\n        // If status is already activated, it means  Zaccount is activated at least in 1 zone.\n        if (userPrevStatus == ZACCOUNT_STATUS.REGISTERED) {\n            zAccountStatus[zAccountMasterEOA] = ZACCOUNT_STATUS.ACTIVATED;\n        }\n\n        {\n            uint256 _zkpRewards = _notifyOnboardingController(\n                zAccountMasterEOA,\n                uint8(userPrevStatus),\n                uint8(ZACCOUNT_STATUS.ACTIVATED),\n                new bytes(0)\n            );\n            uint256 zkpAmount = inputs[1];\n            require(_zkpRewards == zkpAmount, ERR_UNEXPECTED_ZKP_AMOUNT);\n        }\n\n        utxoBusQueuePos = _createZAccountUTXO(\n            inputs,\n            proof,\n            privateMessages,\n            cachedForestRootIndex\n        );\n\n        emit ZAccountActivated(zAccountId);\n    }\n\n    // /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    function batchUpdateBlacklistForMasterEoa(\n        address[] calldata masterEoas,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            masterEoas.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < masterEoas.length; ) {\n            require(\n                isMasterEoaBlacklisted[masterEoas[i]] != isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isMasterEoaBlacklisted[masterEoas[i]] = isBlackListed[i];\n\n            emit BlacklistForMasterEoaUpdated(masterEoas[i], isBlackListed[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function batchUpdateBlacklistForPubRootSpendingKey(\n        bytes32[] calldata packedPubRootSpendingKeys,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            packedPubRootSpendingKeys.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < packedPubRootSpendingKeys.length; ) {\n            require(\n                isPubRootSpendingKeyBlacklisted[packedPubRootSpendingKeys[i]] !=\n                    isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isPubRootSpendingKeyBlacklisted[\n                packedPubRootSpendingKeys[i]\n            ] = isBlackListed[i];\n\n            emit BlacklistForPubRootSpendingKeyUpdated(\n                packedPubRootSpendingKeys[i],\n                isBlackListed[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateBlacklistForZAccountId(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] calldata proofSiblings,\n        bool isBlacklisted\n    ) public onlyOwner {\n        require(masterEOAs[zAccountId] != address(0), ERR_UNKNOWN_ZACCOUNT);\n        require(\n            isZAccountIdBlacklisted[zAccountId] != isBlacklisted,\n            ERR_REPETITIVE_STATUS\n        );\n\n        bytes32 blacklistedZAccountIdsTreeRoot;\n\n        if (isBlacklisted) {\n            blacklistedZAccountIdsTreeRoot = _addZAccountIdToBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        } else {\n            blacklistedZAccountIdsTreeRoot = _removeZAccountIdFromBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        }\n\n        isZAccountIdBlacklisted[zAccountId] = isBlacklisted;\n\n        // Trusted contract - no reentrancy guard needed\n        PANTHER_STATIC_TREE.updateRoot(\n            blacklistedZAccountIdsTreeRoot,\n            ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX\n        );\n\n        emit BlacklistForZAccountIdUpdated(zAccountId, isBlacklisted);\n    }\n\n    // /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _getNextZAccountId() internal returns (uint256 curId) {\n        curId = zAccountIdTracker;\n        zAccountIdTracker = curId & 0xFF < 254\n            ? curId + 1\n            : curId + ZACCOUNT_ID_COUNTER_JUMP;\n    }\n\n    function _createZAccountUTXO(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory privateMessages,\n        uint256 cachedForestRootIndex\n    ) private returns (uint256 utxoBusQueuePos) {\n        utxoBusQueuePos = 0;\n        // Pool is supposed to revert in case of any error\n        try\n            // Trusted contract - no reentrancy guard needed\n            PANTHER_POOL.createZAccountUtxo(\n                inputs,\n                proof,\n                privateMessages,\n                cachedForestRootIndex\n            )\n        returns (uint256 result) {\n            utxoBusQueuePos = result;\n        } catch Error(string memory reason) {\n            revert(reason);\n        }\n    }\n\n    function _notifyOnboardingController(\n        address _user,\n        uint8 _prevStatus,\n        uint8 _newStatus,\n        bytes memory _data\n    ) private returns (uint256 _zkpRewards) {\n        // Trusted contract - no reentrancy guard needed\n        _zkpRewards = ONBOARDING_CONTROLLER.grantRewards(\n            _user,\n            _prevStatus,\n            _newStatus,\n            _data\n        );\n    }\n\n    function _isBlacklisted(\n        uint24 id,\n        address _masterEOA,\n        bytes32 pubRootSpendingKey\n    ) private view returns (bool isBlaklisted, string memory err) {\n        if (isZAccountIdBlacklisted[id]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_ZACCOUNT_ID);\n        }\n        if (isMasterEoaBlacklisted[_masterEOA]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_MASTER_EOA);\n        }\n        if (isPubRootSpendingKeyBlacklisted[pubRootSpendingKey]) {\n            err = _formatBlackListError(\n                err,\n                ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n            );\n        }\n\n        return (isBlaklisted = bytes(err).length > 0 ? true : false, err);\n    }\n\n    function _formatBlackListError(\n        string memory currentErrMsg,\n        string memory errToBeAdded\n    ) private pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(currentErrMsg).length > 0\n                        ? string(abi.encodePacked(currentErrMsg, \",\"))\n                        : \"\",\n                    errToBeAdded\n                )\n            );\n    }\n\n    /// @dev Concatenate the strings together and returns the result\n    function formatBlackListError(\n        string memory content,\n        string memory contentToBeAdded,\n        string memory separator\n    ) internal pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(content).length > 0\n                        ? string(abi.encodePacked(content, separator))\n                        : \"\",\n                    contentToBeAdded\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/BlacklistedZAccountIdsTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../pantherForest/interfaces/ITreeRootGetter.sol\";\n\nimport \"../pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport \"../errMsgs/ZAccountsRegistryErrMsgs.sol\";\n\nimport \"../crypto/PoseidonHashers.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract BlacklistedZAccountIdsTree is\n    BinaryUpdatableTree,\n    ITreeRootGetter\n{\n    // The current root of merkle tree.\n    // If it's undefined, the `zeroRoot()` shall be called.\n    bytes32 private _currentRoot;\n\n    function getRoot() external view returns (bytes32) {\n        return _currentRoot == bytes32(0) ? zeroRoot() : _currentRoot;\n    }\n\n    function _getZAccountFlagAndLeafIndexes(uint24 zAccountId)\n        internal\n        pure\n        returns (uint256 flagIndex, uint256 leafIndex)\n    {\n        // getting index which is between 0 and 253\n        flagIndex = zAccountId & 0xFF;\n\n        require(\n            flagIndex >= 0 && flagIndex < 254,\n            ERR_INVALID_ZACCOUNT_FLAG_POSITION\n        );\n\n        // getting the 16 MSB from uint24\n        leafIndex = zAccountId >> 8;\n    }\n\n    function _addZAccountIdToBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) | (1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function _removeZAccountIdFromBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) & ~(1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3(input);\n    }\n\n    //@dev returns the root of tree with depth 16 where each leaf is 0\n    function zeroRoot() internal pure override returns (bytes32) {\n        /**\n        '0x0000000000000000000000000000000000000000000000000000000000000000'   Level 0\n        '0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864'   Level 1\n        '0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1'   Level 2\n        '0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238'   Level 3\n        '0x07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a'   Level 4\n        '0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55'   Level 5\n        '0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78'   Level 6\n        '0x078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d'   Level 7\n        '0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61'   Level 8\n        '0x0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747'   Level 9\n        '0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2'   Level 10\n        '0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636'   Level 11\n        '0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a'   Level 12\n        '0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0'   Level 13\n        '0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c'   Level 14\n        '0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92'   Level 15\n         */\n        return\n            bytes32(\n                uint256(\n                    0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../../common/EIP712SignatureVerifier.sol\";\n\nabstract contract ZAccountsRegeistrationSignatureVerifier is\n    EIP712SignatureVerifier\n{\n    // solhint-disable var-name-mixedcase\n\n    bytes32 internal constant REGISTRATION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"Registration(bytes32 pubRootSpendingKey,bytes32 pubReadingKey,uint256 version)\"\n            )\n        );\n\n    uint8 public immutable ZACCOUNT_VERSION;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(uint8 zAccountVersion) {\n        ZACCOUNT_VERSION = zAccountVersion;\n    }\n\n    function getRegistrationDataHash(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    REGISTRATION_TYPEHASH,\n                    _pubRootSpendingKey,\n                    _pubReadingKey,\n                    uint256(ZACCOUNT_VERSION)\n                )\n            );\n    }\n\n    function recoverMasterEoa(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 registrationDataHash = getRegistrationDataHash(\n            _pubRootSpendingKey,\n            _pubReadingKey\n        );\n\n        bytes32 typedDataHash = toTypedDataHash(registrationDataHash);\n\n        return recover(typedDataHash, v, r, s);\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/ZAccountsStatusResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.16;\n\nimport \"../interfaces/IPureFiIssuerRequestResolver.sol\";\nimport \"../interfaces/IZAccountsRegistry.sol\";\n\ncontract ZAccountsStatusResolver is IPureFiIssuerRequestResolver {\n    // solhint-disable-next-line var-name-mixedcase\n    IZAccountsRegistry public immutable zAccountsRegistry;\n\n    constructor(address _zAccountsRegistry) {\n        require(_zAccountsRegistry != address(0), \"init:zero address\");\n        zAccountsRegistry = IZAccountsRegistry(_zAccountsRegistry);\n    }\n\n    function resolveRequest(\n        uint8, /*_type*/\n        uint256, /*_ruleID*/\n        address _signer,\n        address, /*_from*/\n        address /*_to*/\n    ) external view override returns (bool) {\n        return zAccountsRegistry.isZAccountWhitelisted(_signer);\n    }\n}\n"
    },
    "contracts/protocol/ZAssetsRegistryV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, zASSET_ENABLED, zASSET_UNKNOWN } from \"../common/Constants.sol\";\nimport \"./errMsgs/ZAssetsRegistryErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport { ZAsset } from \"../common/Types.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\n\n/**\n * @title ZAssetsRegistryV0\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of assets (tokens) supported by the Panther\n * Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\ncontract ZAssetsRegistryV0 is ImmutableOwnable, IZAssetsRegistry {\n    /**\n    \"zAsset\" - abstraction of a token for representation in the MASP.\n    ZK-circuits \"treat\" each zAsset as a unique (independent) token.\n    `zAssetId` - ID of a zAsset.\n    Circuits \"know\" a token by its zAssetID rather than the token addresses or\n    its _tokenId/_id.\n    Each distinguishable token supported by the MASP must be represented by its\n    \"own\" zAsset. zAsset must never  \"represent\" two (or more) different tokens.\n    An ERC-721/ERC-1155 token, with its unique _tokenId/_id, must \"have\" its own\n    zAsset, different from zAssets of other tokens on the same contract.\n    An ERC-20 token should be represented by at least one zAsset (further\n    referred to as the \"default\" zAsset). A few other zAssets (aka \"alternative\"\n    zAssets) may exist for the same ERC-20 token, with each zAsset having a\n    different \"scaling factor\" (`ZAsset.scale`).\n\n    `ZAsset` - a record on the Registry with parameters of zAsset(s).\n    `zAssetRecId` - ID of a ZAsset record.\n    Not every zAsset has its \"own\" ZAsset record, but each ZAsset keeps params\n    of at least one zAsset. It groups all zAssets, which share the same token\n    contract and the \"scaling factor\".\n    There is just one ZAsset record for all zAssets representing tokens on an\n    ERC-721/1155 contract. Thus, for any such supported contract there must be\n    EXACTLY one ZAsset record on the Registry.\n    Every zAsset representing an ERC-20 token must have its own ZAsset record.\n    So, the Registry must have at LEAST one ZAsset (for the default zAsset) for\n    an ERC-20 contract. However, other ZAsset records (for alternative zAssets)\n    may exist for the same ERC-20 token.\n\n    `subId` - additional ID which, coupled with the token contract address, let\n    deterministically compute `zAssetId` and `zAssetRecId`.\n\n    This code is written with the following specs in mind:\n    - If at least one token on an ERC-721/ERC-1155 contract is whitelisted, any\n      token on the contract is implicitly whitelisted w/o further configuration\n    - Registry must have one ZAsset record only for all tokens of an ERC-721/\n      ERC-1155 contract\n    - ZAsset record of any zAsset, w/ exception of extremely rare cases, should\n      be obtained with just a single SLOAD\n    - Backward compatible upgrades should be able to implement ..\n    -- .. separate whitelists of zAssets allowed for deposits and withdrawals\n       (e.g. via extension of ZAsset.status)\n    -- .. blacklist for some tokens on a whitelisted ERC-721/ERC-1155 contract\n       (e.g. by extending ZAsset.tokenType and introducing a blacklist)\n    -- .. limits per a zAsset for max allowed amounts of deposits/withdrawals\n       (e.g. with \"alternative\" zAssets and re-defining ZAsset._unused)\n    */\n\n    uint8 private constant MAX_SCALE = 32; // min scale is 0\n    uint8 private constant NO_SCALING = 0;\n    uint256 private constant DEFAULT_VER = 0;\n\n    // Mapping from `zAssetRecId` to ZAsset (i.e. params of an zAsset)\n    mapping(uint160 => ZAsset) private _registry;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    function getZAssetId(address token, uint256 subId)\n        public\n        pure\n        override\n        returns (uint160)\n    {\n        // Being uint160, it is surely less then the FIELD_SIZE\n        return\n            uint160(\n                uint256(\n                    keccak256(abi.encode(uint256(uint160(token)), subId))\n                ) >> 96\n            );\n    }\n\n    /// @notice Returns ZAsset record for the given record ID\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (ZAsset memory asset)\n    {\n        asset = _registry[zAssetRecId];\n    }\n\n    /// @notice Returns zAsset IDs and ZAsset record for the given token\n    /// @param token Address of the token contract\n    /// @param subId Extra ID to identify zAsset (0 by default)\n    /// @dev For ERC-721/ERC-1155 token, `subId` is the _tokenId/_id. For  the\n    // \"default\" zAsset of an ERC-20 token it is 0. For an \"alternative\" zAsset\n    // it is the `defaultZAssetRecId XOR ver`, where `defaultZAssetRecId` is the\n    // `zAssetRecId` of the default zAsset for this token, and `ver` is a unique\n    // int in the range [1..31].\n    /// @return zAssetId\n    /// @return _tokenId ERC-721/1155 _tokenId/_id, if it's an NFT, or 0 for ERC-20\n    /// @return zAssetRecId ID of the ZAsset record\n    /// @return asset ZAsset record for the token\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        override\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        )\n    {\n        require(token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n\n        // Gas optimized based on assumptions:\n        // - most often, this code is called for the default zAsset of ERC-20\n        // - if `ver` is in [1..MAX_SCALE], likely it's an alternative zAsset\n        _tokenId = subId;\n        if (subId != 0) {\n            // Risk of zAssetRecId collision attack (see further) ignored since\n            // `subId` variant space is small (less than MAX_SCALE of ~5 bits).\n            // Therefore `require(asset.token == token)` omitted here.\n\n            // For an \"alternative\" zAsset, `subId` must be none-zero...\n            uint256 ver = uint256(uint160(token)) ^ subId;\n            // ... and `ver` must be in [1..MAX_SCALE]\n            if (ver < MAX_SCALE && ver != DEFAULT_VER) {\n                // Likely, it's the alternative zAsset w/ `zAssetRecId = subId`\n                asset = _registry[uint160(subId)];\n\n                if (asset.version == uint8(ver)) {\n                    // Surely, it's the alternative zAsset of the ERC-20 token\n                    // as `.version` must be 0 for NFTs and default zAssets.\n                    // As `.version != 0`, `.status` can't be zASSET_UNKNOWN.\n                    // Check `asset.tokenType == ERC20_TOKEN_TYPE` is skipped\n                    // as the code registering ZAssets is assumed to ensure it.\n                    zAssetId = getZAssetId(token, subId);\n                    zAssetRecId = uint160(subId);\n                    _tokenId = DEFAULT_VER;\n                    return (zAssetId, _tokenId, zAssetRecId, asset);\n                }\n            }\n        }\n        // The zAsset can't be an alternative zAsset of an ERC-20 token here.\n        // It's either an NFT (`subId` is _tokenId), or the default zAsset of\n        // an ERC-20 token (`subId` is 0). In both cases `asset.version == 0`.\n\n        zAssetRecId = uint160(token); // same as `uint160(token) ^ 0`\n        asset = _registry[zAssetRecId];\n        if (asset.status == zASSET_UNKNOWN) {\n            // Unknown token - return zero IDs, and empty ZAsset\n            return (0, 0, 0, asset);\n        }\n\n        require(\n            // `subId` of an ERC-20 token's default zAsset must be 0\n            (subId == 0 || asset.tokenType != ERC20_TOKEN_TYPE) &&\n                // zAssetReqId collision attack protection:\n                // attacker may vary token id of a fake NFT to make zAssetReqId\n                // (i.e. `token ^ subId`) equal to zAssetReqId of another token\n                asset.token == token,\n            ERR_ZERO_SUBID_EXPECTED\n        );\n        zAssetId = getZAssetId(token, _tokenId);\n        return (zAssetId, _tokenId, zAssetRecId, asset);\n    }\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        ZAsset memory asset = _registry[zAssetRecId];\n        return asset.status == zASSET_ENABLED;\n    }\n\n    /// @notice Register with the MASP a new asset with given params\n    /// @param asset Params of the asset (including its `ZAsset.status`)\n    /// @dev The \"owner\" may call only\n    function addZAsset(ZAsset memory asset) external onlyOwner {\n        require(asset.token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n        require(asset.status != zASSET_UNKNOWN, ERR_WRONG_ASSET_STATUS);\n        require(\n            // ERC-20 zAsset only may be \"alternative\" ones\n            asset.version == 0 ||\n                (asset.tokenType == ERC20_TOKEN_TYPE &&\n                    asset.version < MAX_SCALE),\n            ERR_WRONG_ASSET_VER\n        );\n        _checkScaleIsInRange(asset);\n\n        // note, `x ^ 0 == x`\n        uint160 zAssetRecId = uint160(asset.token) ^ uint160(asset.version);\n\n        ZAsset memory existingAsset = _registry[zAssetRecId];\n        require(\n            existingAsset.status == zASSET_UNKNOWN,\n            ERR_ASSET_ALREADY_REGISTERED\n        );\n        _registry[zAssetRecId] = asset;\n        emit AssetAdded(zAssetRecId, asset);\n    }\n\n    /// @notice Updates the status of the existing asset\n    /// @param zAssetRecId ID of the ZAsset record\n    /// @param newStatus Status to be set\n    /// @dev The \"owner\" may call only\n    function changeZAssetStatus(uint160 zAssetRecId, uint8 newStatus)\n        external\n        onlyOwner\n    {\n        require(_registry[zAssetRecId].token != address(0), ERR_UNKNOWN_ASSET);\n        uint8 oldStatus = _registry[zAssetRecId].status;\n        // New status value restrictions relaxed to allow for protocol updates.\n        require(\n            newStatus != zASSET_UNKNOWN && oldStatus != newStatus,\n            ERR_WRONG_ASSET_STATUS\n        );\n        _registry[zAssetRecId].status = newStatus;\n        emit AssetStatusChanged(zAssetRecId, newStatus, oldStatus);\n    }\n\n    function _checkScaleIsInRange(ZAsset memory asset) private pure {\n        // Valid range for ERC-20 is [0..31]\n        // Valid range for ERC-721/ERC-1155 is 0\n        require(\n            (asset.scale == NO_SCALING ||\n                ((asset.scale < MAX_SCALE) &&\n                    (asset.tokenType == ERC20_TOKEN_TYPE))),\n            ERR_WRONG_ASSET_SCALE\n        );\n    }\n}\n"
    },
    "contracts/protocol/ZAssetsRegistryV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\n\n/**\n * @title ZAssetsRegistryV1\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of assets (tokens) supported by the Panther\n * Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\ncontract ZAssetsRegistryV1 is ITreeRootGetter {\n    /**\n     * ZAssets tree root generation\n     * This tree consists of a single leaf yet: testZKP on Mumbai\n     *      - leafIndex = 0\n     *      - commitment = poseidon([\n     *              0, // zAsset (zAssetId MUST be 0 for ZKP on all networks)\n     *              BigInt('0x4004C49aBb96B11D89A52DeCCa2D1522da7f3089'), // token (ZKP address on Mumbai)\n     *              0, // tokenId (irrelevant)\n     *              2, // network (mumbai)\n     *              0, // offset\n     *              1, // weight\n     *              12, // scale (UTXO amount = external amounts * 1e-12)\n  \n     *\n     *          ]) = 0x04c47be1c966148d8373a2c9a8725fa5a648678416cbe5a39c1600b69e31666a\n     *               // (2156408421028048248978532747114059242009883911295094375617969196164719928938n)\n     *\n     *      - siblings = [\n     *              0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d,\n     *              0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4,\n     *              0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8,\n     *              0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c,\n     *              0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800,\n     *              0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f,\n     *              0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69,\n     *              0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f,\n     *              0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7,\n     *              0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718,\n     *              0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58,\n     *              0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f,\n     *              0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6,\n     *              0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d,\n     *              0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55,\n     *              0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\n     *          ]\n     */\n    function getRoot() external pure returns (bytes32) {\n        // 3723247354377620069387735695862260139005999863996254561023715046060291769010n\n        return\n            0x083b4887dfb6b09c333fdaea1a3ff792183758862ebb371b60de839b7a57c2b2;\n    }\n}\n"
    },
    "contracts/protocol/ZNetworksRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\n\ncontract ZNetworksRegistry is ITreeRootGetter {\n    /**\n     * ZNetworks tree root generation\n     * This tree consists of 2 leafs: first leaf is for Goerli network and second one is for Mumbai\n     * - List for Goerli:\n     *      - leafIndex = 0\n     *      - commitment = poseidon([\n     *              // active\n     *              1,\n     *              // chainId\n     *              5,\n     *              // networkId\n     *              1,\n     *              // networkIDsBitMap:\n     *              // One-bit flags enabling creating/spending on this network UTXOs spendable/created on\n     *              // other networks; LS bit for the network with ID 1, followed by the bit for the ID 2, ...)\n     *              // (networks with IDs 1 and 2 are enabled)\n     *              3,\n     *              // forTxReward\n     *              0,\n     *              // forUtxoReward\n     *              1000\n     *              // forDepositReward\n     *              0\n     *              // daoDataEscrowPubKey[0]\n     *              12272087043529289524334796370800745508281317430063431496260996322077559426628n\n     *              // daoDataEscrowPubKey[1]\n     *              9194872949126287643523554866093178264045906284036198776275995684726142899669n\n     *\n     *          ]) = 0x1e11d3c31a82691f36c10d8501d9e0fb5c6a4dcddcbe93349512d09313ad8ec9\n     *\n     *      - siblings = [\n     *              0x2caf2892c4eac8f126437b6faf9bd10990fb2f5e3e9f9041646059df91d90b67\n     *              0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n     *              0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n     *              0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n     *              0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n     *              0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\n     *          ]\n     * - List for Mumbai:\n     *      - leafIndex = 1\n     *      - commitment = poseidon([\n     *              // active\n     *              1,\n     *              // chainId\n     *              80001,\n     *              // networkId\n     *              2,\n     *              // networkIDsBitMap:\n     *              // One-bit flags enabling creating/spending on this network UTXOs spendable/created on\n     *              // other networks; LS bit for the network with ID 1, followed by the bit for the ID 2, ...)\n     *              // (networks with IDs 1 and 2 are enabled)\n     *              3,\n     *              // forTxReward\n     *              0,\n     *              // forUtxoReward\n     *              1000\n     *              // forDepositReward\n     *              0\n     *              // daoDataEscrowPubKey[0]\n     *              12272087043529289524334796370800745508281317430063431496260996322077559426628n\n     *              // daoDataEscrowPubKey[1]\n     *              9194872949126287643523554866093178264045906284036198776275995684726142899669n\n     *\n     *          ]) = 0x2caf2892c4eac8f126437b6faf9bd10990fb2f5e3e9f9041646059df91d90b67\n     *\n     *      - siblings = [\n     *              0x1e11d3c31a82691f36c10d8501d9e0fb5c6a4dcddcbe93349512d09313ad8ec9\n     *              0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n     *              0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n     *              0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n     *              0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n     *              0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\n     *          ]\n     *\n     */\n    function getRoot() external pure returns (bytes32) {\n        // 14012219796450685573713237305847642356367283250649627741328974142691321346497n\n        return\n            0x1efaa2a689ac8f5b9d97f7a963d6a34a8a806321a52a3db5720366b3ad0079c1;\n    }\n}\n"
    },
    "contracts/protocol/ZZonesRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\n\ncontract ZZonesRegistry is ITreeRootGetter {\n    /**\n     * ZZone tree root generation\n     * This tree consists of 1 leaf:\n     *      - leafIndex = 0\n     *      - commitment = poseidon([\n     *              // `zoneId`, ID of the only zone currently active\n     *              1n,\n     *              // `edDsaPubKey[0]`, x-coordinate of the of the Zone Safe operator's pubkey\n     *              1079947189093879423832572021742411110959706509214994525945407912687412115152n,\n     *              // `edDsaPubKey[1]`, y-coordinate of the of the Zone Safe operator's pubkey\n     *              6617854811593651784376273094293148407007707755076821057553730151008062424747n,\n     *              // `originZoneIDs`, List of allowed origin zones IDs (the only zone, with ID \"1\", is allowed yet)\n     *              1n,\n     *              // `targetZoneIDs`, List of allowed target zones IDs (only this zone, with ID \"1\", is allowed yet)\n     *              1n,\n     *              // `zZoneNetworkIDsBitMap`, The bit map of allowed network (bit index is network ID)\n     *              // Two one-bit flags are set (to \"1\"):\n     *              //      - bit #0 (LS bit) - Goerli (zNetworkId = 0) enabled\n     *              //      - bit #1 - Mumbai (zNetworkId = 1) enabled\n     *              3n,\n     *              // `zZoneKycKytMerkleTreeLeafIDsAndRulesList`\n     *              // List of allowed KYC/KYT pubkeys and rule (10 elements x 24 bits each)\n     *              // 1st element defined only, it's in LS 24 bits:\n     *              //      - KYC rule ID, 91 ('0b1011011'), in 8 LS bits,\n     *              //      - followed by the provider pubkey leaf index, 0, in next 16 bits\n     *              //      (0b000000000000000001011011)\n     *              91n,\n     *              // `zZoneKycExpiryTime`, Period in seconds of KYC attestation validity (120 days)\n     *              10368000n,\n     *              // `zZoneKytExpiryTime`, Period in seconds of KYT attestation validity (24 hours)\n     *              86400n,\n     *              // `zZoneDepositMaxAmount`, Maximum allowed deposit amount\n     *              // (expressed in the \"weighted scaled\" units)\n     *              BigInt(5e10),\n     *              // `zZoneWithrawMaxAmount`, Maximum allowed withdrawal amount\n     *              // (expressed in the \"weighted scaled\" units)\n     *              BigInt(5e10),\n     *              // `zZoneInternalMaxAmount`, Maximum allowed internal tx amount\n     *              // (expressed in the \"weighted scaled\" units)\n     *              BigInt(5e12),\n     *              // `zZoneZAccountIDsBlackList`, Zone-level List of blacklisted zAccount IDs\n     *              // (10 elements of 24 bits each)\n     *              // The zAccount ID of 0x0FFF can't exist. 24 bits set to \"1\" in a\n     *              // list element means \"no zAccount\" is blacklisted.\n     *              // 240 bits set to one means \"no zAccounts are blacklisted\"\n     *              // The value is 240 bits set to 1:\n     *              1766847064778384329583297500742918515827483896875618958121606201292619775n,\n     *              // `zZoneMaximumAmountPerTimePeriod`, Limit on the sum of\n     *              // deposits+withdrawals+internal_txs amounts for the\n     *              // period defined further (expressed in the \"weighted scaled\" units)\n     *              BigInt(5e14),\n     *              // `zZoneTimePeriodPerMaximumAmount`, Period to count the above limit for (24 hours)\n     *              86400n,\n     *          ]) = 0x0e6ab28e813839edfc865b663fef947a99c7c5418b52bfdf99a7e6d35a28d611\n     *              // (6520898021802809410287280892217974246949765980761337479284035863305500808721n)\n     *\n     *      - siblings = [\n     *              0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n     *              0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n     *              0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n     *              0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n     *              0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n     *              0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\n     *              0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69\n     *              0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n     *              0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7\n     *              0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718\n     *              0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58\n     *              0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f\n     *              0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6\n     *              0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d\n     *              0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55\n     *              0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\n     *          ]\n     */\n    function getRoot() external pure returns (bytes32) {\n        // 2768686232753548194788154003002220124197365245281377680762459495658913308970n\n        return\n            0x061f055809dd21f02840c10fca69afe1254a20a617fb0e5aae1465c39f04a12a;\n    }\n}\n"
    },
    "contracts/staking/actions/AdvancedStakingBridgedDataCoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/***\n * @title AdvancedStakingBridgedDataDecoder\n * @dev It encode (pack) and decodes (unpack) messages for bridging them between networks\n */\nabstract contract AdvancedStakingBridgedDataCoder {\n    function _encodeBridgedData(\n        uint24 _nonce,\n        bytes4 action,\n        bytes memory message\n    ) internal pure returns (bytes memory content) {\n        content = abi.encodePacked(_nonce, action, message);\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _decodeBridgedData(bytes memory content)\n        internal\n        pure\n        returns (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        )\n    {\n        require(content.length >= 7, \"ABD:WRONG_LENGTH\");\n\n        _nonce =\n            (uint256(uint8(content[0])) << 16) |\n            (uint256(uint8(content[1])) << 8) |\n            uint256(uint8(content[2]));\n\n        action = bytes4(\n            uint32(\n                (uint256(uint8(content[3])) << 24) |\n                    (uint256(uint8(content[4])) << 16) |\n                    (uint256(uint8(content[5])) << 8) |\n                    uint256(uint8(content[6]))\n            )\n        );\n\n        uint256 curPos = 7;\n        uint256 msgLength = content.length - curPos;\n        message = new bytes(msgLength);\n        if (msgLength > 0) {\n            uint256 i = 0;\n            while (i < msgLength) {\n                message[i++] = content[curPos++];\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/actions/AdvancedStakingDataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { CIPHERTEXT1_WORDS, OUT_RWRD_UTXOs, PUBKEY_WORDS } from \"../../common/Constants.sol\";\nimport { G1Point } from \"../../common/Types.sol\";\n\n/***\n * @title AdvancedStakingDataDecoder\n * @dev It decodes (unpack) `bytes data` of the 'STAKED' message for \"advanced staking\"\n */\nabstract contract AdvancedStakingDataDecoder {\n    // in bytes\n    uint256 private constant DATA_LENGTH =\n        OUT_RWRD_UTXOs * (PUBKEY_WORDS + CIPHERTEXT1_WORDS) * 32;\n    // in 32-byte memory slots\n    uint256 private constant NUM_DATA_SLOTS =\n        (DATA_LENGTH / 32) + ((DATA_LENGTH % 32) & 1);\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function unpackStakingData(bytes memory data)\n        internal\n        pure\n        returns (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        )\n    {\n        require(data.length == DATA_LENGTH, \"SMP: unexpected msg length\");\n\n        // Let's read bytes as uint256 values\n        uint256[NUM_DATA_SLOTS + 1] memory words;\n        // the 1st slot is `data.length`, then slots with values follow\n        for (uint256 i = 1; i <= NUM_DATA_SLOTS; ++i) {\n            // solhint-disable no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                let offset := mul(i, 0x20)\n                let word := mload(add(data, offset))\n                mstore(add(words, offset), word)\n            }\n            // solhint-enable no-inline-assembly\n        }\n        /*\n            `bytes memory sample = 0x00010203..1f2021` stored in the memory like this:\n            slot #0: 0x22 - length (34 bytes)\n            slot #1: 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n            slot #2: 0x2021000000000000000000000000000000000000000000000000000000000000\n\n            If `OUT_RWRD_UTXOs == 2` and `CIPHERTEXT1_WORDS == 2`,\n            `bytes memory data` expected to be:\n            concatenate( // each element is 32-byte long\n                pubSpendingKeys[0].x, pubSpendingKeys[0].y,\n                pubSpendingKeys[1].x, pubSpendingKeys[1].y,\n                (secrets[0])[0], (secrets[0])[1],\n                (secrets[1])[0], (secrets[1])[1]\n            )\n        */\n        for (uint256 i = 0; i < OUT_RWRD_UTXOs; i++) {\n            pubSpendingKeys[i].x = words[i * PUBKEY_WORDS + 1];\n            pubSpendingKeys[i].y = words[i * PUBKEY_WORDS + 2];\n            for (uint256 k = 0; k < CIPHERTEXT1_WORDS; k++) {\n                secrets[i][k] = words[\n                    PUBKEY_WORDS *\n                        OUT_RWRD_UTXOs +\n                        CIPHERTEXT1_WORDS *\n                        i +\n                        k +\n                        1\n                ];\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/actions/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// solhint-disable var-name-mixedcase\n\n// The \"stake type\" for the \"classic staking\"\n// bytes4(keccak256(\"classic\"))\nbytes4 constant CLASSIC_STAKE_TYPE = 0x4ab0941a;\n\n// STAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_STAKE = 0x1e4d02b5;\n\n// UNSTAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_UNSTAKE = 0x493bdf45;\n\n// The \"stake type\" for the \"advance staking\"\n// bytes4(keccak256(\"advanced\"))\nbytes4 constant ADVANCED_STAKE_TYPE = 0x7ec13a06;\n\n// STAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_STAKE = 0xcc995ce8;\n\n// UNSTAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_UNSTAKE = 0xb8372e55;\n\n// The \"stake type\" for the \"advance staking\"\n// bytes4(keccak256(\"advanced-v2\"))\nbytes4 constant ADVANCED_STAKE_V2_TYPE = 0x8496de05;\n\n// STAKE \"action type\" for the \"advanced staking V2\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), ADVANCED_STAKE_V2_TYPE)))\nbytes4 constant ADVANCED_STAKE_V2 = 0x1954e321;\n\n// UNSTAKE \"action type\" for the \"advanced staking v2\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), ADVANCED_STAKE_V2_TYPE)))\nbytes4 constant ADVANCED_UNSTAKE_V2 = 0x6a8ecb81;\n\n// PRP grant type for the \"advanced\" stake\n// bytes4(keccak256(\"forAdvancedStakeGrant\"))\nbytes4 constant FOR_ADVANCED_STAKE_GRANT = 0x31a180d4;\n\n// solhint-enable var-name-mixedcase\n"
    },
    "contracts/staking/actions/RewardAdvisersList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IRewardAdviser.sol\";\n\n/**\n * @title ActionControllers\n * @notice It maintains a list of \"ActionOracle\" and \"RewardAdviser\" instances.\n * For a tuple of ActionOracle address and action type, an RewardAdviser\n * instance of  may be mapped.\n */\nabstract contract RewardAdvisersList {\n    /// @dev Emitted when RewardAdviser added, updated, or removed\n    event AdviserUpdated(\n        address indexed oracle,\n        bytes4 indexed action,\n        address adviser\n    );\n\n    /// @dev mapping from ActionOracle and (type of) action to ActionController\n    mapping(address => mapping(bytes4 => address)) public rewardAdvisers;\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) internal {\n        require(\n            oracle != address(0) &&\n                adviser != address(0) &&\n                action != bytes4(0),\n            \"ACM:E1\"\n        );\n        require(rewardAdvisers[oracle][action] == address(0), \"ACM:E2\");\n        rewardAdvisers[oracle][action] = adviser;\n        emit AdviserUpdated(oracle, action, adviser);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _removeRewardAdviser(address oracle, bytes4 action) internal {\n        require(rewardAdvisers[oracle][action] != address(0), \"ACM:E3\");\n        rewardAdvisers[oracle][action] = address(0);\n        emit AdviserUpdated(oracle, action, address(0));\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _getRewardAdviserOrRevert(address oracle, bytes4 action)\n        internal\n        view\n        returns (IRewardAdviser)\n    {\n        address adviser = rewardAdvisers[oracle][action];\n        require(adviser != address(0), \"ACM:E4\");\n        return IRewardAdviser(adviser);\n    }\n}\n"
    },
    "contracts/staking/actions/StakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IStakingTypes.sol\";\n\nabstract contract StakingMsgProcessor {\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\"stake\"));\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\"unstake\"));\n\n    function _encodeStakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\n    }\n\n    function _encodeUnstakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\n    }\n\n    function _packStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                staker, // address\n                stake.amount, // uint96\n                stake.id, // uint32\n                stake.stakedAt, // uint32\n                stake.lockedTill, // uint32\n                stake.claimedAt, // uint32\n                data // bytes\n            );\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _unpackStakingActionMsg(bytes memory message)\n        internal\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\n        // (`data` may be of zero length)\n        require(message.length >= 48, \"SMP: unexpected msg length\");\n\n        uint256 stakerAndAmount;\n        uint256 idAndStamps;\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n            // .. and (16 bytes of) the 3rd word\n            idAndStamps := mload(add(message, 0x40))\n        }\n        // solhint-enable no-inline-assembly\n\n        staker = address(uint160(stakerAndAmount >> 96));\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\n\n        uint256 dataLength = message.length - 48;\n        data = new bytes(dataLength);\n        for (uint256 i = 0; i < dataLength; i++) {\n            data[i] = message[i + 48];\n        }\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeActionMsgRelayer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingBridgedDataCoder.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IFxMessageProcessor.sol\";\n\n/***\n * @title AdvancedStakeActionMsgRelayer\n * @notice It re-translates messages on new \"advanced\" stakes created on the mainnet (or Goerli)\n * network to the `RewardMaster` contract running on the Polygon (or Mumbai) network.\n * @dev It is assumed to run on the Polygon (or Mumbai) network.\n * Like the `Staking` contract, this contract acts as the \"Action Oracle\" for the RewardMaster, and\n * this contract must be registered as the oracle with the latest.\n * It receives STAKE action messages (on new \"advanced\" stakes created) from the `FxChild` contract\n * (a contract of the \"Fx-Portal\" PoS bridge), sanitizes and relays messages to the RewardMaster on\n * the Polygon (or Mumbai).\n * The `AdvancedStakeRewardAdviserAndMsgSender` contract, a counterpart to this contract that runs\n * on the mainnet (or Goerli) network, sends these messages to this contract over the bridge.\n */\ncontract AdvancedStakeActionMsgRelayer is\n    AdvancedStakingBridgedDataCoder,\n    IFxMessageProcessor\n{\n    event StakeMsgRelayed(uint256 _nonce, bytes data);\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the `FxChild` contract on the Polygon/Mumbai network\n    /// @dev `FxChild` is the contract of the \"Fx-Portal\" on the Polygon/Mumbai\n    address public immutable FX_CHILD;\n\n    /// @notice Address of the RewardMaster contract on the Polygon/Mumbai\n    address public immutable REWARD_MASTER;\n\n    /// @notice Address of the AdvancedStakeRewardAdviserAndMsgSender on the mainnet/Goerli\n    /// @dev It sends messages over the PoS bridge to this contract\n    address public immutable STAKE_MSG_SENDER;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Message nonce (i.e. sequential number of the latest message)\n    uint256 public nonce;\n\n    /// @param _rewardMaster Address of the RewardMaster contract on the Polygon/Mumbai\n    /// @param _stakeMsgSender Address of the AdvancedStakeRewardAdviserAndMsgSender on the mainnet/Goerli\n    /// @param _fxChild Address of the `FxChild` (Bridge) contract on Polygon/Mumbai\n    constructor(\n        // slither-disable-next-line similar-names\n        address _rewardMaster,\n        address _stakeMsgSender,\n        address _fxChild\n    ) {\n        require(\n            _fxChild != address(0) &&\n                _stakeMsgSender != address(0) &&\n                _rewardMaster != address(0),\n            \"AMR:E01\"\n        );\n\n        FX_CHILD = _fxChild;\n        REWARD_MASTER = _rewardMaster;\n        STAKE_MSG_SENDER = _stakeMsgSender;\n    }\n\n    /// @dev Sanitizes, decodes and relay to the RewardMaster the STAKE action message.\n    /// PoS bridge validators call this method via the `FxChild` contract each time\n    /// a new message is posted to the bridge on the mainnet/Goerli\n    /// @param rootMessageSender Address on the mainnet/Goerli that sent the message\n    /// @param content Message data\n    function processMessageFromRoot(\n        uint256, // stateId (Polygon PoS Bridge state sync ID, unused)\n        address rootMessageSender,\n        bytes calldata content\n    ) external override {\n        require(msg.sender == FX_CHILD, \"AMR:INVALID_CALLER\");\n        require(rootMessageSender == STAKE_MSG_SENDER, \"AMR:INVALID_SENDER\");\n\n        (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        ) = _decodeBridgedData(content);\n\n        // Protection against replay attacks/errors. It's supposed that:\n        // - failed `.onAction` shall not stop further messages bridging\n        // - nonce is expected never be large enough to overflow.\n        require(_nonce > nonce, \"AMR:INVALID_NONCE\");\n        nonce = _nonce;\n\n        // trusted contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        IActionMsgReceiver(REWARD_MASTER).onAction(action, message);\n\n        emit StakeMsgRelayed(_nonce, content);\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeActionMsgTranslator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport { ADVANCED_STAKE } from \"./actions/Constants.sol\";\n\n/**\n * @title AdvancedStakeV2ActionMsgTranslator\n * @notice It processes action messages for the new stakes type (e.g. `advanced-v2`,\n *  `advanced-v3 and so on...)\n * @dev It \"translates\" the `action` in messages so that other contracts, which\n * are \"unaware\" of the new stakes type, may process this new type exactly like\n * they process `advanced` type stakes.\n * It shall be registered with the `RewardMaster` as the \"RewardAdviser\" for\n * the new stakes type and the \"ActionOracle\" for `advanced` stakes type.\n * Being called `getRewardAdvice` by the RewardMaster for a message with the\n * new STAKE action, it replaces the `action` to be the `advanced`\n * (but not new action such as `advanced-v2`) STAKE action.\n * Then it calls `onAction` on the RewardMaster with the substituted message.\n * When called back, the latter processes the substituted action message as if\n * it is the `advanced` (not `advanced-v2`) STAKE action.\n */\ncontract AdvancedStakeV2ActionMsgTranslator is IRewardAdviser {\n    // solhint-disable var-name-mixedcase\n\n    /// @notice RewardMaster contract instance\n    address private immutable REWARD_MASTER;\n\n    /// @notice The action type of stake\n    bytes4 private immutable ADV_STAKE_ACTION_TYPE;\n\n    /// @notice The action type of unstake\n    bytes4 private immutable ADV_UNSTAKE_ACTION_TYPE;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(\n        address rewardMaster,\n        bytes4 advStakeActionType,\n        bytes4 advUnstakeActionType\n    ) {\n        require(rewardMaster != address(0), \"Zero address\");\n        require(\n            advStakeActionType.length != 0 && advUnstakeActionType.length != 0,\n            \"Empty action type\"\n        );\n\n        REWARD_MASTER = rewardMaster;\n        ADV_STAKE_ACTION_TYPE = advStakeActionType;\n        ADV_UNSTAKE_ACTION_TYPE = advUnstakeActionType;\n    }\n\n    /// @dev To be called by the {RewardMaster} for `advanced-v2` type actions.\n    /// It makes the `action` to look like the `advanced` (not \"v2\") type action\n    /// and calls the {RewardMaster} back simulating a \"new\" action message.\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"AMT: unauthorized\");\n\n        if (action == ADV_STAKE_ACTION_TYPE) {\n            // Replace the action and return the message back to REWARD_MASTER\n            IActionMsgReceiver(REWARD_MASTER).onAction(ADVANCED_STAKE, message);\n        } else {\n            require(\n                action == ADV_UNSTAKE_ACTION_TYPE,\n                \"AMT: unsupported action\"\n            );\n        }\n\n        // Return \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeRewardAdviserAndMsgSender.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingBridgedDataCoder.sol\";\nimport \"./actions/Constants.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IFxStateSender.sol\";\nimport \"./StakeZeroRewardAdviser.sol\";\n\n/***\n * @title AdvancedStakeRewardAdviserAndMsgSender\n * @notice The \"zero reward adviser\" for the `RewardMaster` that sends `STAKE` action messages over\n * the PoS bridge to the STAKE_MSG_RECEIVER.\n * @dev It is assumed to run on the mainnet/Goerli and be authorized with the `RewardMaster` on the\n * same network as the \"Reward Adviser\" for \"advanced\" stakes.\n * As the \"Reward Adviser\" it gets called `getRewardAdvice` by the `RewardMaster` every time a user\n * creates or withdraws an \"advanced\" stake. It returns the \"zero\" advices, i.e. the `Advice` data\n * structure with zero `sharesToCreate` and `sharesToRedeem`.\n * On \"zero\" advices, the RewardMaster skips creating/redeeming \"treasure shares\" for/to stakers.\n * If the `getRewardAdvice` is called w/ the action STAKE (i.e. a new stake is being created), this\n * contract sends the STAKE message over the \"Fx-Portal\" (the PoS bridge run by the Polygon team)\n * to the STAKE_MSG_RECEIVER on the Polygon/Mumbai. The STAKE_MSG_RECEIVER is supposed to be the\n * `AdvancedStakeActionMsgRelayer` contract that processes the bridged messages, rewarding stakers\n * on the Polygon/Mumbai.\n */\ncontract AdvancedStakeRewardAdviserAndMsgSender is\n    StakeZeroRewardAdviser,\n    AdvancedStakingBridgedDataCoder\n{\n    event StakeMsgBridged(uint256 _nonce, bytes data);\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the `FxRoot` contract on the mainnet/Goerli network\n    /// @dev `FxRoot` is the contract of the \"Fx-Portal\" on the mainnet/Goerli.\n    address public immutable FX_ROOT;\n\n    /// @notice Address of the RewardMaster contract on the mainnet/Goerli\n    address public immutable REWARD_MASTER;\n\n    /// @notice Address on the AdvancedStakeActionMsgRelayer on the Polygon/Mumbai\n    address public immutable ACTION_MSG_RECEIVER;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Message nonce (i.e. sequential number of the latest message)\n    uint256 public nonce;\n\n    /// @param _rewardMaster Address of the RewardMaster contract on the mainnet/Goerli\n    /// @param _actionMsgReceiver Address of the AdvancedStakeActionMsgRelayer on Polygon/Mumbai\n    /// @param _fxRoot Address of the `FxRoot` (PoS Bridge) contract on mainnet/Goerli\n    constructor(\n        // slither-disable-next-line similar-names\n        address _rewardMaster,\n        address _actionMsgReceiver,\n        address _fxRoot\n    ) StakeZeroRewardAdviser(ADVANCED_STAKE, ADVANCED_UNSTAKE) {\n        require(\n            _fxRoot != address(0) &&\n                _actionMsgReceiver != address(0) &&\n                _rewardMaster != address(0),\n            \"AMS:E01\"\n        );\n\n        FX_ROOT = _fxRoot;\n        REWARD_MASTER = _rewardMaster;\n        ACTION_MSG_RECEIVER = _actionMsgReceiver;\n    }\n\n    // It is called withing the `function getRewardAdvice`\n    function _onRequest(bytes4 action, bytes memory message) internal override {\n        // Ignore other messages except the STAKE\n        if (action != STAKE) return;\n\n        // Overflow ignored as the nonce is unexpected ever be that big\n        uint24 _nonce = uint24(nonce + 1);\n        nonce = uint256(_nonce);\n\n        bytes memory content = _encodeBridgedData(_nonce, action, message);\n        // known contract call - no need in reentrancy guard\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        IFxStateSender(FX_ROOT).sendMessageToChild(\n            ACTION_MSG_RECEIVER,\n            content\n        );\n\n        emit StakeMsgBridged(_nonce, content);\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingDataDecoder.sol\";\nimport \"./actions/Constants.sol\";\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IERC721Receiver.sol\";\nimport \"./interfaces/INftGrantor.sol\";\nimport \"./interfaces/IPantherPoolV0.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Utils.sol\";\nimport \"../common/TransferHelper.sol\";\n\n/**\n * @title AdvancedStakeRewardController\n * @notice It generates UTXOs in the MASP as rewards to stakers for the \"Advanced Staking\"\n * @dev This contract is supposed to run on the Polygon. Unless otherwise mentioned, other smart\n * contracts are supposed to run on the Polygon also.\n * As the \"Reward Adviser\" on the \"advanced\" stakes, every time a new stake is being created, it\n * receives the `getRewardAdvice` call from the `RewardMaster` contract with the `STAKE` action\n * type and the stake data (the `message`) being the call parameters.\n * On the `getRewardAdvice` call received, this contract:\n * - computes the amounts of the $ZKP reward and the optional NFT reward\n * - if the `NFT_TOKEN` is non-zero address, it calls `grantOneToken` on the NFT_TOKEN, and gets\n * the `tokenId` of the minted NFT token\n * - calls `generateDeposits` of the PantherPoolV0, providing amounts/parameters of $ZKP, and\n *   optional NFT as \"deposits\", as well as \"spending pubKeys\" and \"secrets\" (explained below)\n * - returns the \"zero reward advice\" (with zero `sharesToCreate`) to the RewardMaster.\n *\n * On the \"zero\" advice, the RewardMaster skips creating \"treasure shares\" for the staker. This way\n * rewarding gets orchestrated by this contract rather than the RewardMaster.\n *\n * Being called `generateDeposits`, the PantherPoolV0:\n * - requests the `Vault` to take (`transferFrom`) the $ZKP and NFT tokens from this contract\n * - generates \"UTXOs\" with the \"spending pubKeys\" and \"secrets\" provided (see bellow).\n *\n * Creating a new stake (i.e. calling the `stake`), the staker generates and provides the \"pubKeys\"\n * and \"secrets\" to the Staking. Both the Staking on the mainnet and the Staking on the Polygon\n * encodes them into the STAKE message and passes to the RewardMaster, which passes the message to\n * this contract with the `getRewardAdvice` call. So this contracts get pubKeys and secrets needed\n * for the `generateDeposits`.\n * For stakes on the Polygon, when all contracts (i.e. Staking, RewardMaster and this contract) run\n * on the same network, the RewardMaster on the Polygon calls this contract directly.\n * For stakes made on the mainnet, where the Staking and the RewardMaster run, but this contract is\n * on the Polygon, the RewardMaster on the mainnet sends the STAKE message to the RewardMaster on\n * the Polygon via the PoS bridge and mediator contracts. The RewardMaster on the Polygon handles a\n * bridged STAKE message (calling the `getRewardAdvice`) as if the message had been sent by the\n * Staking on the Polygon.\n *\n * As a prerequisite:\n * - this contract shall:\n * -- be authorized as the \"RewardAdviser\" with the RewardMaster on the Polygon for advanced stakes\n * -- be authorized as \"Minter\" (aka \"grantor\") with the NFT_TOKEN contract\n * -- hold enough $ZKP to reward stakers\n * - the Vault contract shall be approved to transfer $ZKPs and the NFT tokens from this contract\n * - the $ZKP and the NFT tokens shall be registered as zAssets on the PantherPoolV0.\n */\ncontract AdvancedStakeRewardController is\n    ImmutableOwnable,\n    NonReentrant,\n    StakingMsgProcessor,\n    AdvancedStakingDataDecoder,\n    Utils,\n    Claimable,\n    IERC721Receiver,\n    IRewardAdviser\n{\n    using TransferHelper for address;\n\n    /// @dev Total amount of $ZKP and NFTs (ever) rewarded and staked\n    struct Totals {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n        // Accumulated amount of $ZKP (ever) staked, scaled (divided) by 1e15\n        uint40 scZkpStaked;\n    }\n\n    /// @dev Maximum amounts of $ZKPs and NFTs which may be rewarded\n    struct Limits {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n    }\n\n    /// @dev Reward Timestamps and APYs\n    struct RewardParams {\n        /// @param (UNIX) Time when $ZKP rewards start to accrue\n        uint32 startTime;\n        /// @param (UNIX) Time when $ZKP rewards accruals end\n        uint32 endTime;\n        /// @param $ZKP reward APY at startTime (APY declines from this value)\n        uint8 startZkpApy;\n        /// @param $ZKP reward APY at endTime (APY declines to this value)\n        uint8 endZkpApy;\n    }\n\n    // solhint-disable var-name-mixedcase\n    // These three constants used to align with IPantherPool::generateDeposits API\n    uint256 private constant ZERO_AMOUNT = 0;\n    uint256 private constant ZERO_TOKEN_ID = 0;\n    address private constant ZERO_TOKEN = address(0);\n\n    /// @notice RewardMaster contract instance\n    address public immutable REWARD_MASTER;\n    /// @notice PantherPoolV0 contract instance\n    address public immutable PANTHER_POOL;\n\n    // Address of the $ZKP token contract\n    address private immutable ZKP_TOKEN;\n    // Address of the NFT token contract\n    address private immutable NFT_TOKEN;\n\n    /// @notice Block when this contract is deployed\n    uint256 public immutable START_BLOCK;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Amounts of $ZKP and NFT allocated for rewards\n    Limits public limits;\n\n    /// @notice Total amounts of $ZKP and NFT rewarded so far\n    Totals public totals;\n\n    /// @notice Reward parameters (start and end point for time and APY)\n    RewardParams public rewardParams;\n\n    /// @dev Emitted when new amounts are allocated to reward stakers\n    event RewardLimitUpdated(Limits newLimits);\n\n    /// @dev Emitted when rewarding params updated\n    event RewardParamsUpdated(RewardParams newRewardParams);\n\n    /// @dev Emitted when the reward for a stake is generated\n    event RewardGenerated(\n        address indexed staker,\n        uint256 firstLeafId,\n        uint256 zkp,\n        uint256 nft\n    );\n\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    ) ImmutableOwnable(_owner) {\n        require(\n            // nftToken may be zero address\n            rewardMaster != address(0) &&\n                pantherPool != address(0) &&\n                zkpToken != address(0),\n            \"ARC:E1\"\n        );\n\n        REWARD_MASTER = rewardMaster;\n        PANTHER_POOL = pantherPool;\n\n        ZKP_TOKEN = zkpToken;\n        NFT_TOKEN = nftToken;\n\n        START_BLOCK = block.number;\n    }\n\n    /// @dev To be called by the {RewardMaster} contract on \"advanced\" `STAKE` and `UNSTAKE` actions.\n    /// The caller is trusted to never call w/ the STAKE acton:\n    /// - twice for the same stake\n    /// - after the rewarded period has ended\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"ARC: unauthorized\");\n\n        if (action == ADVANCED_STAKE) {\n            _generateRewards(message);\n        } else {\n            require(action == ADVANCED_UNSTAKE, \"ARC: unsupported action\");\n        }\n\n        // Return \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n\n    /// @notice Return the APY for the $ZKP reward at a given time\n    function getZkpApyAt(uint256 time) external view returns (uint256) {\n        RewardParams memory _rewardParams = rewardParams;\n        if (time < _rewardParams.startTime || time > _rewardParams.endTime)\n            return 0;\n\n        return _getZkpApyWithinRewardedPeriod(_rewardParams, time);\n    }\n\n    function updateRewardParams(RewardParams memory _newParams)\n        external\n        onlyOwner\n    {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            _newParams.startTime != 0 &&\n                _newParams.endTime > _newParams.startTime &&\n                _newParams.endTime > timeNow(),\n            \"ARC: invalid time\"\n        );\n        require(\n            _newParams.startZkpApy >= _newParams.endZkpApy,\n            \"ARC: invalid APY\"\n        );\n\n        rewardParams = _newParams;\n        emit RewardParamsUpdated(_newParams);\n    }\n\n    /// @notice Allocate NFT rewards and approve the Vault to transfer them\n    /// @dev Only owner may call it.\n    function setNftRewardLimit(uint256 _desiredNftRewardsLimit)\n        external\n        onlyOwner\n    {\n        if (NFT_TOKEN == address(0)) return;\n\n        Limits memory _limits = limits;\n\n        require(\n            _desiredNftRewardsLimit > totals.nftRewards,\n            \"ARC: low nft rewards limit\"\n        );\n\n        // known contract - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        bool isUpdated = _updateNftRewardsLimitAndAllowance(\n            _desiredNftRewardsLimit,\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Allocate for rewards the entire $ZKP balance\n    /// this contract has and approve the Vault to transfer $ZKP from this contract.\n    /// @dev Anyone may call it.\n    function updateZkpRewardsLimit() external {\n        Limits memory _limits = limits;\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        // Updating the rewards limits\n        bool isUpdated = _updateZkpRewardsLimitAndAllowance(\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Withdraws unclaimed rewards or accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function rescueErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external nonReentrant {\n        RewardParams memory _rewardParams = rewardParams;\n\n        require(OWNER == msg.sender, \"ARC: unauthorized\");\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            (token != ZKP_TOKEN) || (block.timestamp > _rewardParams.endTime),\n            \"ARC: too early withdrawal\"\n        );\n\n        _claimErc20(token, to, amount);\n    }\n\n    // Implementation of the {IERC721Receiver}. It accepts NFT_TOKEN transfers only.\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external view override returns (bytes4) {\n        return\n            msg.sender == NFT_TOKEN\n                ? this.onERC721Received.selector // accepted\n                : bytes4(0); // rejected\n    }\n\n    // Private functions follow\n    // Some of them declared `internal` rather than `private` to ease testing\n\n    function _generateRewards(bytes memory message) internal {\n        // (stakeId and claimedAt are irrelevant)\n        (\n            address staker,\n            uint96 stakeAmount,\n            ,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            ,\n            bytes memory data\n        ) = _unpackStakingActionMsg(message);\n\n        require(stakeAmount != 0, \"ARC: unexpected zero stakeAmount\");\n        require(lockedTill > stakedAt, \"ARC: unexpected lockedTill\");\n\n        uint256 zkpAmount = 0;\n        uint256 nftAmount = 0;\n        uint256 nftTokenId = 0;\n        {\n            Totals memory _totals = totals;\n            Limits memory _limits = limits;\n            RewardParams memory _rewardParams = rewardParams;\n\n            // Compute amount of the $ZKP reward  and check the limit\n            {\n                zkpAmount = _computeZkpReward(\n                    stakeAmount,\n                    lockedTill,\n                    stakedAt,\n                    _rewardParams\n                );\n\n                if (zkpAmount > 0) {\n                    uint256 newTotalZkpReward = uint256(_totals.zkpRewards) +\n                        zkpAmount;\n                    require(\n                        _limits.zkpRewards >= newTotalZkpReward,\n                        \"ARC: too less rewards available\"\n                    );\n                    // Can't exceed uint96 here due to the `require` above\n                    _totals.zkpRewards = uint96(newTotalZkpReward);\n                }\n                // update scSkpStaked in any case when stakeAmount > 0 which already been required\n                uint256 newScZkpStaked = uint256(_totals.scZkpStaked) +\n                    uint256(stakeAmount) /\n                    1e15;\n                // Overflow risk ignored as $ZKP max total supply is 1e9 tokens\n                _totals.scZkpStaked = uint40(newScZkpStaked);\n            }\n\n            if (_totals.nftRewards < _limits.nftRewards) {\n                // `_limits.nftRewards > 0` therefore `NFT_TOKEN != address(0)`\n                // trusted contract called - no reentrancy guard needed\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth\n                nftTokenId = INftGrantor(NFT_TOKEN).grantOneToken(\n                    address(this)\n                );\n\n                nftAmount = 1;\n                _totals.nftRewards += 1;\n            }\n\n            totals = _totals;\n        }\n\n        // Extract public spending keys and \"secrets\"\n        (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        ) = unpackStakingData(data);\n\n        // Finally, generate deposits (i.e. UTXOs in the MASP)\n        address[OUT_MAX_UTXOs] memory tokens = [\n            // PantherPool reverts if non-zero address provided for zero amount\n            zkpAmount == 0 ? address(0) : ZKP_TOKEN,\n            nftAmount == 0 ? address(0) : NFT_TOKEN,\n            ZERO_TOKEN\n        ];\n\n        uint256[OUT_MAX_UTXOs] memory subIds = [0, nftTokenId, ZERO_TOKEN_ID];\n        uint256[OUT_MAX_UTXOs] memory extAmounts = [\n            zkpAmount,\n            nftAmount,\n            ZERO_AMOUNT\n        ];\n\n        uint32 createdAt = safe32TimeNow();\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        uint256 leftLeafId = IPantherPoolV0(PANTHER_POOL).generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            [\n                pubSpendingKeys[0],\n                pubSpendingKeys[1],\n                pubSpendingKeys[1] // dummy public key - reused\n            ],\n            [\n                secrets[0],\n                secrets[1],\n                secrets[1] // dummy secret - reused\n            ],\n            createdAt\n        );\n\n        emit RewardGenerated(staker, leftLeafId, zkpAmount, nftAmount);\n    }\n\n    // The calling code is assumed to ensure `lockedTill > stakedAt`\n    function _computeZkpReward(\n        uint256 stakeAmount,\n        uint256 lockedTill,\n        uint256 stakedAt,\n        RewardParams memory _rewardParams\n    ) internal pure returns (uint256 zkpAmount) {\n        // No rewarding after `endTime`\n        if (stakedAt >= _rewardParams.endTime) return 0;\n        // No rewarding before `startTime`\n        if (lockedTill <= _rewardParams.startTime) return 0;\n\n        uint256 rewardedSince = _rewardParams.startTime > stakedAt\n            ? _rewardParams.startTime\n            : stakedAt;\n\n        uint256 rewardedTill = lockedTill > _rewardParams.endTime\n            ? _rewardParams.endTime\n            : lockedTill;\n\n        uint256 period = rewardedTill - rewardedSince;\n        uint256 apy = _getZkpApyWithinRewardedPeriod(\n            _rewardParams,\n            rewardedSince\n        );\n\n        // 3153600000 = 365 * 24 * 3600 seconds * 100 percents\n        // slither-disable-next-line too-many-digits\n        zkpAmount = (stakeAmount * apy * period) / 3153600000;\n        // round to 2nd digits after decimal point: X.YZ{0..0} x 1e18\n        unchecked {\n            // rounding (accuracy loss is assumed)\n            // slither-disable-next-line divide-before-multiply\n            zkpAmount = (zkpAmount / 1e16) * (1e16);\n        }\n    }\n\n    // The calling code is assumed to ensure that\n    // `startTime < time < endTime` and `startZkpApy >= endZkpApy`\n    function _getZkpApyWithinRewardedPeriod(\n        RewardParams memory _rewardParams,\n        uint256 time\n    ) private pure returns (uint256 apy) {\n        unchecked {\n            uint256 fullDrop = uint256(\n                _rewardParams.startZkpApy - _rewardParams.endZkpApy\n            );\n            apy = uint256(_rewardParams.startZkpApy);\n\n            if (fullDrop > 0) {\n                uint256 dropDuration = time - _rewardParams.startTime;\n                uint256 fullDuration = uint256(\n                    _rewardParams.endTime - _rewardParams.startTime\n                );\n                uint256 apyDrop = (fullDrop * dropDuration) / fullDuration;\n\n                apy -= apyDrop;\n            }\n        }\n    }\n\n    // Allocate for rewards the entire $ZKP balance this contract holds,\n    // and update allowance for the VAULT to spend for $ZKP from the balance\n    function _updateZkpRewardsLimitAndAllowance(\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        // Reentrancy guard unneeded for the trusted contract call\n        // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n        uint256 balance = ZKP_TOKEN.safeBalanceOf(address(this));\n\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            balance,\n            _limits.zkpRewards,\n            _totals.zkpRewards\n        );\n\n        if (isUpdated) {\n            _limits.zkpRewards = newLimit;\n\n            // Approve the vault to transfer tokens from this contract\n            // Reentrancy guard unneeded for the trusted contract call\n            // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n            ZKP_TOKEN.safeApprove(vault, uint256(newLimit));\n        }\n    }\n\n    // Allocate for rewards the entire NFT amount this contract can mint,\n    // and update allowance for the VAULT to spend that NFT\n    function _updateNftRewardsLimitAndAllowance(\n        uint256 _desiredNftRewardsLimit,\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            _desiredNftRewardsLimit,\n            _limits.nftRewards,\n            _totals.nftRewards\n        );\n\n        if (isUpdated) {\n            bool isAllowanceToBeUpdated = _limits.nftRewards == 0;\n\n            // Overflow is unrealistic and therefore ignored\n            _limits.nftRewards = uint24(newLimit);\n\n            if (isAllowanceToBeUpdated)\n                // Approve the vault to transfer tokens from this contract\n                // Reentrancy guard unneeded for the trusted contract call\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n                NFT_TOKEN.safeSetApprovalForAll(vault, true);\n        }\n    }\n\n    // Calculates and returns the updated reward limit\n    function _getUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) internal pure returns (bool isUpdated, uint96 limit) {\n        uint256 unusedLimit = uint256(currentLimit) - uint256(usedLimit);\n\n        if (available == unusedLimit) return (false, currentLimit);\n\n        isUpdated = true;\n        // underflow is impossible due to `if` checks\n        unchecked {\n            if (available > unusedLimit) {\n                // new tokens for rewarding have been provided\n                uint256 newAllocation = available - unusedLimit;\n                limit = safe96(newAllocation + currentLimit);\n            } else {\n                // gracefully handle this unexpected situation\n                uint96 shortage = safe96(unusedLimit - available);\n                limit = currentLimit > shortage ? currentLimit - shortage : 0;\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IActionMsgReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IActionMsgReceiver {\n    function onAction(bytes4 action, bytes memory message) external;\n}\n"
    },
    "contracts/staking/interfaces/IArptHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IArptHistory {\n    function getScArptAt(uint32 timestamp)\n        external\n        view\n        returns (uint256 scArpt);\n}\n"
    },
    "contracts/staking/interfaces/IErc20Approve.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @dev Interface to call ERC-20 `approve` function\ninterface IErc20Approve {\n    /// @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n    // Beware of risk: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/staking/interfaces/IErc20Min.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IErc20Min {\n    /// @dev ERC-20 `balanceOf`\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @dev ERC-20 `transfer`\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /// @dev ERC-20 `transferFrom`\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @dev EIP-2612 `permit`\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/staking/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient,\n     * the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/staking/interfaces/IFxMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev A receiver on the Polygon (or Mumbai) network of a message sent over the\n * \"Fx-Portal\" must implement this interface.\n * The \"Fx-Portal\" is the PoS bridge run by the Polygon team.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/staking/interfaces/IFxStateSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev An interface of the `FxRoot` contract\n * `FxRoot` is the contract of the \"Fx-Portal\" (a PoS bridge run by the Polygon team) on the\n * mainnet/Goerli network. It passes data to s user-defined contract on the Polygon/Mumbai.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data)\n        external;\n}\n"
    },
    "contracts/staking/interfaces/INftGrantor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface INftGrantor {\n    function grantOneToken(address to) external returns (uint256 tokenId);\n}\n"
    },
    "contracts/staking/interfaces/IPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { CIPHERTEXT1_WORDS, OUT_MAX_UTXOs, PATH_ELEMENTS_NUM } from \"../../common/Constants.sol\";\n\n/**\n * @notice (Truncated) Interface of the PantherPoolV0\n * @dev Only those functions and events included which the `AdvancedStakeRewardController` contract uses\n */\ninterface IPantherPoolV0 {\n    /**\n     * @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n     * @param tokens Address of the token contract for every UTXO\n     * @dev For PRP granted the address ot this contract (proxy) is supposed to be used\n     * @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n     * @param extAmounts Token amounts (external) to be deposited\n     * @param pubSpendingKeys Public Spending Key for every UTXO\n     * @param secrets Encrypted opening values for every UTXO\n     * @param  createdAt Optional, if 0 network time used\n     * @dev createdAt must be less (or equal) the network time\n     * @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n     */\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata extAmounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external returns (uint256 leftLeafId);\n\n    function exit(\n        address token,\n        uint256 tokenId,\n        uint256 amount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[PATH_ELEMENTS_NUM] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external;\n\n    /**\n     * @return Address of the Vault\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function VAULT() external view returns (address);\n\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * Nullifier is seen (i.e. UTXO is spent)\n     */\n    event Nullifier(bytes32 nullifier);\n}\n"
    },
    "contracts/staking/interfaces/IPrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/**\n * @title (Truncated) Interface of PrpGrantor\n * @dev Only those functions and events included which the `AdvancedStakeRewardController` contract uses\n */\ninterface IPrpGrantor {\n    /// @notice Returns the total amount (in PRPs) of unused grants for the given grantee\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        returns (uint256 prpAmount);\n}\n"
    },
    "contracts/staking/interfaces/IRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IRewardAdviser {\n    struct Advice {\n        // advice on new \"shares\" (in the reward pool) to create\n        address createSharesFor;\n        uint96 sharesToCreate;\n        // advice on \"shares\" to redeem\n        address redeemSharesFrom;\n        uint96 sharesToRedeem;\n        // advice on address the reward against redeemed shares to send to\n        address sendRewardTo;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        returns (Advice memory);\n}\n"
    },
    "contracts/staking/interfaces/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IRewardPool {\n    /// @notice Returns token amount that may be released (vested) now\n    function releasableAmount() external view returns (uint256);\n\n    /// @notice Vests releasable token amount to the {recipient}\n    /// @dev {recipient} only may call\n    function vestRewards() external returns (uint256 amount);\n\n    /// @notice Emitted on vesting to the {recipient}\n    event Vested(uint256 amount);\n\n    /// @notice Emitted on parameters initialized.\n    event Initialized(uint256 _poolId, address _recipient, uint256 _endTime);\n}\n"
    },
    "contracts/staking/interfaces/IStakeRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./IStakingTypes.sol\";\n\ninterface IStakeRegister {\n    function stakes(address _account, uint256 _stakeId)\n        external\n        view\n        returns (IStakingTypes.Stake memory);\n\n    function accountStakes(address _account)\n        external\n        view\n        returns (IStakingTypes.Stake[] memory);\n}\n"
    },
    "contracts/staking/interfaces/IStakingTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IStakingTypes {\n    // Stake type terms\n    struct Terms {\n        // if stakes of this kind allowed\n        bool isEnabled;\n        // if messages on stakes to be sent to the {RewardMaster}\n        bool isRewarded;\n        // limit on the minimum amount staked, no limit if zero\n        uint32 minAmountScaled;\n        // limit on the maximum amount staked, no limit if zero\n        uint32 maxAmountScaled;\n        // Stakes not accepted before this time, has no effect if zero\n        uint32 allowedSince;\n        // Stakes not accepted after this time, has no effect if zero\n        uint32 allowedTill;\n        // One (at least) of the following three params must be non-zero\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\n        uint32 lockedTill;\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\n        uint32 exactLockPeriod;\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\n        uint32 minLockPeriod;\n    }\n\n    struct Stake {\n        // index in the `Stake[]` array of `stakes`\n        uint32 id;\n        // defines Terms\n        bytes4 stakeType;\n        // time this stake was created at\n        uint32 stakedAt;\n        // time this stake can be claimed at\n        uint32 lockedTill;\n        // time this stake was claimed at (unclaimed if 0)\n        uint32 claimedAt;\n        // amount of tokens on this stake (assumed to be less 1e27)\n        uint96 amount;\n        // address stake voting power is delegated to\n        address delegatee;\n    }\n}\n"
    },
    "contracts/staking/interfaces/ITotalStaked.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @dev Interface to call `totalStaked` on the Staking contract\ninterface ITotalStaked {\n    function totalStaked() external returns (uint96);\n}\n"
    },
    "contracts/staking/interfaces/IVestingPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IVestingPools {\n    /**\n     * @notice Returns Token address.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Returns the wallet address of the specified pool.\n     */\n    function getWallet(uint256 poolId) external view returns (address);\n\n    /**\n     * @notice Returns the amount that may be vested now from the given pool.\n     */\n    function releasableAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount that has been vested from the given pool\n     */\n    function vestedAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the pool wallet.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function release(uint256 poolId, uint256 amount)\n        external\n        returns (uint256 released);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the given address.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function releaseTo(\n        uint256 poolId,\n        address account,\n        uint256 amount\n    ) external returns (uint256 released);\n\n    /**\n     * @notice Updates the wallet for the given pool.\n     * @dev Only address with the 'wallet' role may call.\n     */\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\n\n    /// @notice Emitted on an amount vesting.\n    event Released(uint256 indexed poolId, address to, uint256 amount);\n}\n"
    },
    "contracts/staking/interfaces/IVotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title IStaking\ninterface IVotingPower {\n    struct Snapshot {\n        uint32 beforeBlock;\n        uint96 ownPower;\n        uint96 delegatedPower;\n    }\n\n    /// @dev Voting power integrants\n    struct Power {\n        uint96 own; // voting power that remains after delegating to others\n        uint96 delegated; // voting power delegated by others\n    }\n\n    /// @notice Returns total voting power staked\n    /// @dev \"own\" and \"delegated\" voting power summed up\n    function totalVotingPower() external view returns (uint256);\n\n    /// @notice Returns total \"own\" and total \"delegated\" voting power separately\n    /// @dev Useful, if \"own\" and \"delegated\" voting power treated differently\n    function totalPower() external view returns (Power memory);\n\n    /// @notice Returns global snapshot for given block\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @notice Returns snapshot on given block for given account\n    /// @param _account - account to get snapshot for\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view returns (Snapshot memory);\n\n    /// @dev Returns block number of the latest global snapshot\n    function latestGlobalsSnapshotBlock() external view returns (uint256);\n\n    /// @dev Returns block number of the given account latest snapshot\n    function latestSnapshotBlock(address _account)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns number of global snapshots\n    function globalsSnapshotLength() external view returns (uint256);\n\n    /// @dev Returns number of snapshots for given account\n    function snapshotLength(address _account) external view returns (uint256);\n\n    /// @dev Returns global snapshot at given index\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @dev Returns snapshot at given index for given account\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n}\n"
    },
    "contracts/staking/interfaces/IVotingPowerSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version,pragma\npragma solidity ^0.8.4;\n\ninterface IVotingPowerSource {\n    /// @dev Voting power integrants\n    struct Power {\n        uint96 own; // voting power that remains after delegating to others\n        uint96 delegated; // voting power delegated by others\n    }\n\n    function power(address voter) external view returns (Power memory);\n}\n"
    },
    "contracts/staking/mocks/FakePantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport { CIPHERTEXT1_WORDS, OUT_MAX_UTXOs, PATH_ELEMENTS_NUM } from \"../../common/Constants.sol\";\nimport { G1Point } from \"../../common/Types.sol\";\nimport \"../interfaces/IPantherPoolV0.sol\";\nimport { FIELD_SIZE } from \"../../protocol/crypto/SnarkConstants.sol\";\n\n/// @dev It simulates (but not precisely!!!) `IPantherPoolV0`. See an example bellow.\ncontract FakePantherPoolV0 is IPantherPoolV0 {\n    // solhint-disable var-name-mixedcase\n\n    // Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n    bytes32 internal constant ZERO_VALUE =\n        bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n\n    address public immutable override VAULT;\n    uint256 public immutable exitTime;\n\n    // solhint-enable var-name-mixedcase\n\n    uint256 public fakeLeavesNum;\n\n    mapping(bytes32 => bool) public isSpent;\n\n    constructor(address anyVaultAddress, uint256 _exitTime) {\n        VAULT = anyVaultAddress;\n        exitTime = _exitTime;\n    }\n\n    // It fakes generation of deposits and emits\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata extAmounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external override returns (uint256 leftLeafId) {\n        require(\n            createdAt <= block.timestamp,\n            \"FakePantherPoolV0:TOO_LARGE_createdAt\"\n        );\n        bytes32[OUT_MAX_UTXOs] memory commitments;\n        bytes memory utxoData = \"\";\n\n        for (uint256 utxoIndex = 0; utxoIndex < OUT_MAX_UTXOs; utxoIndex++) {\n            require(\n                pubSpendingKeys[utxoIndex].x < FIELD_SIZE,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_PUBKEY.x\"\n            );\n            require(\n                pubSpendingKeys[utxoIndex].x < FIELD_SIZE,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_PUBKEY.x\"\n            );\n            require(\n                tokenIds[utxoIndex] < FIELD_SIZE,\n                \"FakePantherPoolV0:TOO_LARGE_tokenId\"\n            );\n            require(\n                extAmounts[utxoIndex] < 2**96,\n                \"FakePantherPoolV0:ERR_TOO_LARGE_AMOUNT\"\n            );\n            require(\n                extAmounts[utxoIndex] != 0 ||\n                    (tokens[utxoIndex] == address(0) &&\n                        tokenIds[utxoIndex] == 0),\n                \"FakePantherPoolV0:ERR_WRONG_DEPOSIT\"\n            );\n\n            bytes memory thisUtxoData;\n            if (extAmounts[utxoIndex] == 0) {\n                // zero UTXO\n                commitments[utxoIndex] = ZERO_VALUE;\n                // UTXO_DATA_TYPE_ZERO\n                thisUtxoData = bytes.concat(abi.encodePacked(uint8(0xA0)));\n            } else {\n                // Fake (!!!) the commitment\n                commitments[utxoIndex] = bytes32(\n                    uint256(keccak256(abi.encode(block.timestamp, utxoIndex))) %\n                        FIELD_SIZE\n                );\n\n                // No scaling (!!!)\n                uint256 scaledAmount = extAmounts[utxoIndex];\n                uint256 tokenAndAmount = (uint256(uint160(tokens[utxoIndex])) <<\n                    96) | scaledAmount;\n\n                thisUtxoData = abi.encodePacked(\n                    uint8(0xAB), // UTXO_DATA_TYPE1\n                    secrets[utxoIndex],\n                    tokenAndAmount,\n                    tokenIds[utxoIndex]\n                );\n            }\n\n            utxoData = bytes.concat(utxoData, thisUtxoData);\n        }\n\n        uint256 n = fakeLeavesNum;\n        leftLeafId = ((n / 3) * 4) + (n % 3);\n        fakeLeavesNum = n + OUT_MAX_UTXOs;\n\n        emit NewCommitments(\n            leftLeafId,\n            block.timestamp, // creationTime,\n            commitments,\n            utxoData\n        );\n    }\n\n    function exit(\n        address, // token,\n        uint256, // tokenId,\n        uint256 amount,\n        uint32, // creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[PATH_ELEMENTS_NUM] calldata, // pathElements,\n        bytes32, // merkleRoot,\n        uint256 // cacheIndexHint\n    ) external override {\n        require(\n            block.timestamp >= exitTime,\n            \"FakePantherPoolV0:ERR_TOO_EARLY_EXIT\"\n        );\n        require(amount < 2**96, \"FakePantherPoolV0:ERR_TOO_LARGE_AMOUNT\");\n\n        // Fake (!!!) nullifier\n        bytes32 nullifier = bytes32(\n            uint256(keccak256(abi.encode(privSpendingKey, leafId))) % FIELD_SIZE\n        );\n\n        require(!isSpent[nullifier], \"FakePantherPoolV0:ERR_SPENT_NULLIFIER\");\n        isSpent[nullifier] = true;\n        emit Nullifier(nullifier);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../AdvancedStakeRewardController.sol\";\n\ncontract MockAdvancedStakeRewardController is AdvancedStakeRewardController {\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    )\n        AdvancedStakeRewardController(\n            _owner,\n            rewardMaster,\n            pantherPool,\n            zkpToken,\n            nftToken\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function internalComputeZkpReward(\n        uint256 stakeAmount,\n        uint32 lockedTill,\n        uint32 stakedAt,\n        RewardParams memory _rewardParams\n    ) external pure returns (uint256 zkpAmount) {\n        return\n            _computeZkpReward(stakeAmount, lockedTill, stakedAt, _rewardParams);\n    }\n\n    function internalGenerateRewards(bytes calldata message) external {\n        _generateRewards(message);\n    }\n\n    function internalGetUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) external pure returns (bool isUpdated, uint96 limit) {\n        return _getUpdatedLimit(available, currentLimit, usedLimit);\n    }\n\n    function fakeTotals(Totals memory _totals) external {\n        totals = _totals;\n    }\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakingBridgedDataCoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../actions/AdvancedStakingBridgedDataCoder.sol\";\n\ncontract MockAdvancedStakingBridgedDataCoder is\n    AdvancedStakingBridgedDataCoder\n{\n    function internalEncodeBridgedData(\n        uint24 _nonce,\n        bytes4 action,\n        bytes memory message\n    ) external pure returns (bytes memory content) {\n        return _encodeBridgedData(_nonce, action, message);\n    }\n\n    function internalDecodeBridgedData(bytes memory content)\n        external\n        pure\n        returns (\n            uint256 _nonce,\n            bytes4 action,\n            bytes memory message\n        )\n    {\n        return _decodeBridgedData(content);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakingDataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../actions/AdvancedStakingDataDecoder.sol\";\nimport \"../../common/Constants.sol\";\n\ncontract MockAdvancedStakingDataDecoder is AdvancedStakingDataDecoder {\n    function internalUnpackStakingData(bytes memory data)\n        external\n        pure\n        returns (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        )\n    {\n        return unpackStakingData(data);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../../common/Claimable.sol\";\n\ncontract MockClaimable is Claimable {\n    function internalClaimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        _claimErc20(token, to, amount);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockStakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../actions/StakingMsgProcessor.sol\";\nimport \"../interfaces/IStakingTypes.sol\";\n\ncontract MockStakingMsgProcessor is StakingMsgProcessor {\n    function internalEncodeStakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeStakeActionType(stakeType);\n    }\n\n    function internalEncodeUnstakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeUnstakeActionType(stakeType);\n    }\n\n    function internalPackStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) external pure returns (bytes memory) {\n        return _packStakingActionMsg(staker, stake, data);\n    }\n\n    function internalUnpackStakingActionMsg(bytes memory message)\n        external\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        return _unpackStakingActionMsg(message);\n    }\n}\n"
    },
    "contracts/staking/mocks/MockVotingPowerSource.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ncontract MockVotingPowerSource {\n    struct Power {\n        uint96 own;\n        uint96 delegated;\n    }\n\n    mapping(address => Power) private _powers;\n\n    function power(address voter) external view returns (Power memory) {\n        return _powers[voter];\n    }\n\n    function _setMockPower(address voter, Power memory _power) external {\n        _powers[voter] = _power;\n    }\n}\n"
    },
    "contracts/staking/mocks/TokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\n// mocked methods of ZKPToken\ncontract TokenMock is ERC20Permit {\n    constructor() ERC20Permit(\"TEST\") ERC20(\"TEST\", \"TT\") {\n        _mint(msg.sender, 1e27);\n    }\n}\n\ncontract ERC721Mock is ERC721 {\n    uint256 private _tokenId;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor() ERC721(\"TEST\", \"TT\") {}\n\n    function mintBatch(address _to, uint256 _amount) external {\n        for (uint256 i = 0; i < _amount; i++) {\n            _mint(_to, _tokenId);\n            _tokenId++;\n        }\n    }\n\n    function grantOneToken(address _to) external returns (uint256 id) {\n        id = _tokenId;\n        _mint(_to, id);\n\n        _tokenId++;\n    }\n}\n"
    },
    "contracts/staking/PNftToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./pNftToken/NativeMetaTransaction.sol\";\nimport \"./pNftToken/ContentMixin.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./interfaces/INftGrantor.sol\";\n\n/**\n * @title PNftToken\n * @notice Panther NFT (PNFT) token on Polygon.\n * @dev If called by the \"minter\", it mints and grants one NFT to the address\n * given. The `AdvancedStakeRewardController` is supposed to be the minter and\n * call it to reward stakers with $PNFTs.\n * An immutable \"owner\" may update the minter and set the metadata (URIs) once.\n * Inspired and borrowed by/from the OpenSea's ERC721Tradable contract.\n * https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/ERC721Tradable.sol\n */\ncontract PNftToken is\n    ImmutableOwnable,\n    ERC721,\n    ContextMixin,\n    NativeMetaTransaction,\n    INftGrantor\n{\n    using Counters for Counters.Counter;\n\n    /**\n     * We rely on the OZ Counter util to keep track of the next available ID.\n     * We track the nextTokenId instead of the currentTokenId to save users on gas costs.\n     */\n    Counters.Counter private _nextTokenId;\n\n    /// @notice Operator (or user's Proxy Register) approved for all transactions\n    address public approvedForAll;\n    address public minter;\n\n    string public contractURI;\n    string public baseTokenURI;\n\n    event MinterUpdated(address _minter);\n    event TokenUriUpdated(string _tokenURI);\n    event ContractUriUpdated(string _contractURI);\n    event ApprovedForAllUpdated(address approvee);\n\n    constructor(\n        address _owner,\n        string memory _name,\n        string memory _symbol\n    ) ERC721(_name, _symbol) ImmutableOwnable(_owner) {\n        // nextTokenId is initialized to 1, since starting at 0 leads to higher gas cost for the first minter\n        _nextTokenId.increment();\n        _initializeEIP712(_name);\n    }\n\n    /**\n     * @dev Returns the total tokens minted so far.\n     * 1 is always subtracted from the Counter since it tracks the next available tokenId.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _nextTokenId.current() - 1;\n    }\n\n    function tokenURI(uint256 _tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return\n            string(abi.encodePacked(baseTokenURI, Strings.toString(_tokenId)));\n    }\n\n    /**\n     * @dev Sets the minter address\n     * @param _minter The address that can mint token\n     */\n    function setMinter(address _minter) external onlyOwner {\n        require(_minter != address(0), \"Zero address\");\n        minter = _minter;\n\n        emit MinterUpdated(_minter);\n    }\n\n    /**\n     * @dev Sets the URI of the contract. it can be called\n     * only once by the owner\n     * @param _contractURI URI of the contract\n     */\n    function setContractURI(string calldata _contractURI) external onlyOwner {\n        require(!(bytes(contractURI).length > 0), \"Contract URI is defined\");\n\n        contractURI = _contractURI;\n\n        emit ContractUriUpdated(_contractURI);\n    }\n\n    /**\n     * @dev Sets the URI of the token. it can be called\n     * only once by the owner\n     * @param _baseTokenURI URI of the token\n     */\n    function setBaseTokenURI(string calldata _baseTokenURI) external onlyOwner {\n        require(!(bytes(baseTokenURI).length > 0), \"Base URI is defined\");\n\n        baseTokenURI = _baseTokenURI;\n\n        emit TokenUriUpdated(_baseTokenURI);\n    }\n\n    /**\n     * @dev Sets the address of the \"operator\" approved for all transactions.\n     * May be set by the owner only.\n     * @param approvee Approved address. It may be a Panther's contract or\n     * OpenSea's ERC721 Proxy Registry, which is at\n     * matic:0x58807baD0B376efc12F5AD86aAc70E78ed67deaE\n     * (mumbai:0xff7Ca10aF37178BdD056628eF42fD7F799fAc77c)\n     */\n    function setApprovedForAllOperator(address approvee) external onlyOwner {\n        // Zero address allowed (meaning \"no account is set\")\n        // slither-disable-next-line missing-zero-check\n        approvedForAll = approvee;\n        emit ApprovedForAllUpdated(approvee);\n    }\n\n    /**\n     * @dev Mints a token to an address with a tokenURI.\n     * @param _to address of the future owner of the token\n     */\n    function grantOneToken(address _to)\n        external\n        virtual\n        returns (uint256 currentTokenId)\n    {\n        require(_msgSender() == minter, \"Only minter\");\n\n        currentTokenId = _nextTokenId.current();\n        _nextTokenId.increment();\n        _safeMint(_to, currentTokenId);\n    }\n\n    /**\n     * Override isApprovedForAll to whitelist a Panther authorized account or\n     * user's OpenSea proxy accounts to enable gas-less transactions/listings.\n     */\n    function isApprovedForAll(address owner, address operator)\n        public\n        view\n        override\n        returns (bool)\n    {\n        if (super.isApprovedForAll(owner, operator)) return true;\n\n        // if \"approved for all\" operator (proxy registry) is detected, return true\n        address approvee = approvedForAll;\n        return (approvee != address(0)) && (approvee == operator);\n    }\n\n    /**\n     * This is used instead of msg.sender as transactions might be sent by a relayer rather than by a user directly.\n     */\n    function _msgSender() internal view override returns (address sender) {\n        return ContextMixin.msgSender();\n    }\n}\n"
    },
    "contracts/staking/pNftToken/ContentMixin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/ContentMixin.sol\n\npragma solidity ^0.8.16;\n\n/**\n * @title ContextMixin contract\n * @dev It supports gasless user transactions\n */\nabstract contract ContextMixin {\n    function msgSender() internal view returns (address payable sender) {\n        if (msg.sender == address(this)) {\n            bytes memory array = msg.data;\n            uint256 index = msg.data.length;\n            // solhint-disable no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n                sender := and(\n                    mload(add(array, index)),\n                    0xffffffffffffffffffffffffffffffffffffffff\n                )\n            }\n            // solhint-enable no-inline-assembly\n        } else {\n            sender = payable(msg.sender);\n        }\n        return sender;\n    }\n}\n"
    },
    "contracts/staking/pNftToken/EIP712Base.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/EIP712Base.sol\n\npragma solidity ^0.8.16;\n\nimport { Initializable } from \"./Initializable.sol\";\n\n/**\n * @title EIP712Base contract\n */\ncontract EIP712Base is Initializable {\n    struct EIP712Domain {\n        string name;\n        string version;\n        address verifyingContract;\n        bytes32 salt;\n    }\n\n    string public constant ERC712_VERSION = \"1\";\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\"\n            )\n        );\n    bytes32 internal domainSeperator;\n\n    // supposed to be called once while initializing.\n    // one of the contracts that inherits this contract follows proxy pattern\n    // so it is not possible to do this in a constructor\n    function _initializeEIP712(string memory name) internal initializer {\n        _setDomainSeperator(name);\n    }\n\n    function _setDomainSeperator(string memory name) internal {\n        domainSeperator = keccak256(\n            abi.encode(\n                EIP712_DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(ERC712_VERSION)),\n                address(this),\n                bytes32(getChainId())\n            )\n        );\n    }\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return domainSeperator;\n    }\n\n    function getChainId() public view returns (uint256) {\n        uint256 id;\n\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            id := chainid()\n        }\n        // solhint-enable no-inline-assembly\n\n        return id;\n    }\n\n    /**\n     * Accept message hash and returns hash message in EIP712 compatible form\n     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n     * https://eips.ethereum.org/EIPS/eip-712\n     * \"\\\\x19\" makes the encoding deterministic\n     * \"\\\\x01\" is the version byte to make it compatible to EIP-191\n     */\n    function toTypedMessageHash(bytes32 messageHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(), messageHash)\n            );\n    }\n}\n"
    },
    "contracts/staking/pNftToken/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/Initializable.sol\n\npragma solidity ^0.8.16;\n\n/**\n * @title Initializable contract\n */\ncontract Initializable {\n    bool private inited = false;\n\n    modifier initializer() {\n        require(!inited, \"already inited\");\n        _;\n        inited = true;\n    }\n}\n"
    },
    "contracts/staking/pNftToken/NativeMetaTransaction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line max-line-length\n// Source: https://github.com/ProjectOpenSea/opensea-creatures/blob/master/contracts/common/meta-transactions/NativeMetaTransaction.sol\n\npragma solidity ^0.8.16;\n\nimport { EIP712Base } from \"./EIP712Base.sol\";\n\n/**\n * @title NativeMetaTransaction contract\n * @dev It enables gasless user transactions\n */\ncontract NativeMetaTransaction is EIP712Base {\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\n            )\n        );\n    event MetaTransactionExecuted(\n        address userAddress,\n        address payable relayerAddress,\n        bytes functionSignature\n    );\n    mapping(address => uint256) private nonces;\n\n    /*\n     * Meta transaction structure.\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n     * He should call the desired function directly in that case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    // slither-disable-next-line locked-ether\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress] + 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        // solhint-enable avoid-low-level-calls\n\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }\n\n    function hashMetaTransaction(MetaTransaction memory metaTx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    META_TRANSACTION_TYPEHASH,\n                    metaTx.nonce,\n                    metaTx.from,\n                    keccak256(metaTx.functionSignature)\n                )\n            );\n    }\n\n    function getNonce(address user) public view returns (uint256 nonce) {\n        nonce = nonces[user];\n    }\n\n    function verify(\n        address signer,\n        MetaTransaction memory metaTx,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) internal view returns (bool) {\n        require(signer != address(0), \"NativeMetaTransaction: INVALID_SIGNER\");\n        return\n            signer ==\n            ecrecover(\n                toTypedMessageHash(hashMetaTransaction(metaTx)),\n                sigV,\n                sigR,\n                sigS\n            );\n    }\n}\n"
    },
    "contracts/staking/StakeZeroRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\n\n/**\n * @title StakeZeroRewardAdviser\n * @notice The \"reward adviser\" for the `RewardMaster` that returns the \"zero reward advice\" only.\n * @dev The \"zero\" reward advice is the `Advice` with zero `sharesToCreate` and `sharesToRedeem`.\n * On \"zero\" advices, the RewardMaster skips creating/redeeming \"treasure shares\" for/to stakers.\n */\nabstract contract StakeZeroRewardAdviser is\n    StakingMsgProcessor,\n    IRewardAdviser\n{\n    // solhint-disable var-name-mixedcase\n\n    // `stakeAction` for the STAKE\n    bytes4 internal immutable STAKE;\n\n    // `stakeAction` for the UNSTAKE\n    bytes4 internal immutable UNSTAKE;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @param stakeAction The STAKE action type (see StakingMsgProcessor::_encodeStakeActionType)\n    /// @param unstakeAction The UNSTAKE action type (see StakingMsgProcessor::_encodeUNstakeActionType)\n    constructor(bytes4 stakeAction, bytes4 unstakeAction) {\n        require(\n            stakeAction != bytes4(0) && unstakeAction != bytes4(0),\n            \"ZRA:E1\"\n        );\n        STAKE = stakeAction;\n        UNSTAKE = unstakeAction;\n    }\n\n    /// @dev It is assumed to be called by the RewardMaster contract.\n    /// It returns the \"zero\" reward advises, no matter who calls it.\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(\n            action == STAKE || action == UNSTAKE,\n            \"ZRA: unsupported action\"\n        );\n\n        _onRequest(action, message);\n\n        // Return the \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n\n    // solhint-disable no-empty-blocks\n    // slither-disable-next-line dead-code\n    function _onRequest(bytes4 action, bytes memory message) internal virtual {\n        // Child contracts may re-define it\n    }\n    // solhint-enable no-empty-blocks\n}\n"
    },
    "contracts/staking/ZkpFaucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\n\n// When called `drink`, it sends tokens to the `_to`\n// As a prerequisite, it shall get enough tokens on the balance\ncontract ZkpFaucet is Claimable, ImmutableOwnable {\n    address public immutable token;\n    uint256 public cupSize;\n    uint256 public tokenPrice;\n    uint256 public maxAmountToPay;\n    uint256 public maxDrinkCount;\n\n    // @notice  store the whitelisted addresses who can drink\n    mapping(address => bool) public whitelistedAddresses;\n    // @notice store the number of times each user has drank\n    mapping(address => uint256) public drinkCount;\n\n    // @notice enabling/disabling check for whitelisted addresses\n    bool public restrictToWhitelisted;\n\n    event CupSizeUpdated(uint256 newCupSice);\n    event TokenPriceUpdated(uint256 newTokenPrice);\n    event MaxDrinkCountUpdated(uint256 newMaxDrinkCount);\n    event WhitelistRestrictUpdated(bool newIsRestricted);\n\n    constructor(\n        address _owner,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _maxAmountToPay,\n        uint256 _cupSize,\n        uint256 _maxDrinkCount\n    ) ImmutableOwnable(_owner) {\n        require(_cupSize > 0, \"invalid cup size\");\n        require(_token != address(0), \"invalid token address\");\n\n        token = _token;\n        tokenPrice = _tokenPrice;\n        cupSize = _cupSize;\n        maxAmountToPay = _maxAmountToPay;\n        maxDrinkCount = _maxDrinkCount;\n\n        emit TokenPriceUpdated(_tokenPrice);\n        emit CupSizeUpdated(_cupSize);\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n        emit WhitelistRestrictUpdated(false);\n    }\n\n    /**\n     * @notice if restrictToWhitelisted is true, then\n     * check if the sender is whitelisted\n     */\n    modifier onlyWhitelisted(address _address) {\n        require(\n            !restrictToWhitelisted || isWhitelisted(_address),\n            \"Not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if maxDrinkCount is defined, then\n     * check if the sender is already received token\n     */\n    modifier checkDrinkCount(address _address) {\n        require(\n            maxDrinkCount == 0 || withinDrinkLimit(_address),\n            \"Reached maximum drink count\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if token price is more than 0, then\n     * check the value\n     */\n    modifier validatePrice() {\n        require(msg.value <= maxAmountToPay, \"High value\");\n        require(msg.value >= tokenPrice, \"Low value\");\n        _;\n    }\n\n    /**\n     * @notice return true if the address is whitelisted, otherwise false\n     * @dev it helps when contract is restricted to whitelisted addresses\n     */\n    function isWhitelisted(address _account) public view returns (bool) {\n        return whitelistedAddresses[_account];\n    }\n\n    /**\n     * @notice return true if the user request counts are\n     * less than or equal to maxDrinkCount, otherwise returns false\n     * @dev it helps when contract is restricted to requests count.\n     */\n    function withinDrinkLimit(address _account) public view returns (bool) {\n        return drinkCount[_account] < maxDrinkCount;\n    }\n\n    /**\n     * @notice send tokens to `_to`\n     * @param _to the receiver addresss\n     * @dev if restrictToWhitelisted is true, then check if the\n     * sender is whitelisted.\n     * if the restrictToMaxReq is true, then check if the\n     * sender is already received token.\n     */\n    function drink(address _to)\n        external\n        payable\n        validatePrice\n        onlyWhitelisted(msg.sender)\n        checkDrinkCount(_to)\n    {\n        drinkCount[_to]++;\n\n        safeTransfer(token, _to, getCupSize(msg.value));\n    }\n\n    function getCupSize(uint256 _amountToPay) public view returns (uint256) {\n        return tokenPrice > 0 ? _amountToPay / tokenPrice : cupSize;\n    }\n\n    function safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(0xa9059cbb, _to, _value)\n        );\n        // solhint-enable avoid-low-level-calls\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    // Owner functions\n    /**\n     * @notice update restrictToWhitelisted\n     */\n    function updateRestrictToWhitelisted(bool isRestricted) external onlyOwner {\n        restrictToWhitelisted = isRestricted;\n        emit WhitelistRestrictUpdated(isRestricted);\n    }\n\n    /**\n     * @notice Add multiple addresses to the whitelisted list\n     * @param _whitelistedAddresses array of addresses to be added\n     * @param _whitelisted array of boolen values to be mapped to the addresses\n     */\n    function whitelistBatch(\n        address[] calldata _whitelistedAddresses,\n        bool[] calldata _whitelisted\n    ) external onlyOwner {\n        for (uint256 i = 0; i < _whitelistedAddresses.length; ) {\n            whitelistedAddresses[_whitelistedAddresses[i]] = _whitelisted[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice update the amount that can be received by users\n     * @param _cupSize the amount that can be received by users\n     */\n    function updateCupSize(uint256 _cupSize) external onlyOwner {\n        require(_cupSize > 0, \"invalid size\");\n        cupSize = _cupSize;\n        emit CupSizeUpdated(_cupSize);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _tokenPrice the price of each token\n     */\n    function updateTokenPrice(uint256 _tokenPrice) external onlyOwner {\n        tokenPrice = _tokenPrice;\n        emit TokenPriceUpdated(_tokenPrice);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _maxDrinkCount the maximum number of times the\n     * drink function can be called\n     */\n    function updateMaxDrinkCount(uint256 _maxDrinkCount) external onlyOwner {\n        maxDrinkCount = _maxDrinkCount;\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n    }\n\n    /**\n     * @notice whithdraws native or erc20 token from the contract\n     * @param _claimedToken The token address to claim\n     * @param _to the receiver address\n     * @param _amount the token amount to be withdrawn\n     * @dev The token address can be zero address in case the\n     * native token is going to be withdrawn.\n     */\n    function withdraw(\n        address _claimedToken,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        require(_to != address(0), \"recipient cannot be 0\");\n        require(_amount > 0, \"amount cannot be 0\");\n\n        if (_claimedToken == address(0)) {\n            // solhint-disable avoid-low-level-calls\n            // slither-disable-next-line low-level-calls\n            (bool sent, ) = _to.call{ value: _amount }(\"\");\n            // solhint-enable avoid-low-level-calls\n            require(sent, \"Failed to send native\");\n        } else {\n            _claimErc20(_claimedToken, _to, _amount);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}