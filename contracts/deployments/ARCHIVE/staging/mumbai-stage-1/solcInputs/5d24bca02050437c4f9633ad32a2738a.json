{
  "language": "Solidity",
  "sources": {
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Grant Types\n// bytes4(keccak('panther-onboarding-grantor'))\nbytes4 constant GT_ONBOARDING = 0x93b212ae;\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/PoseidonHashers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\nimport \"./Poseidon.sol\";\n\nlibrary PoseidonHashers {\n    string private constant ERR_INPUT_NOT_IN_FIELD =\n        \"PoseidonHasher: input not in field\";\n\n    function poseidonT3(bytes32[2] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE && uint256(input[1]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT3.poseidon(input);\n    }\n\n    function poseidonT4(bytes32[3] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT4.poseidon(input);\n    }\n\n    function poseidonT5(bytes32[4] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT5.poseidon(input);\n    }\n\n    function poseidonT6(bytes32[5] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE &&\n                uint256(input[4]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT6.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n"
    },
    "contracts/protocol/errMsgs/BusTreeErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"BT:E1\";\nstring constant ERR_INVALID_VK = \"BT:E2\";\nstring constant ERR_INVALID_BUS_TREE_ROOT = \"BT:E3\";\nstring constant ERR_INVALID_EXTRA_INP = \"BT:E4\";\nstring constant ERR_ZERO_MAGIC_CONSTR = \"BT:E5\";\nstring constant ERR_INVALID_REPLACE_INDEX = \"BT:E6\";\nstring constant ERR_INVALID_LEAFS_COMMIT = \"BT:E7\";\nstring constant ERR_INVALID_LEAFS_NUM = \"BT:E8\";\nstring constant ERR_FAILED_ZK_PROOF = \"BT:E9\";\n"
    },
    "contracts/protocol/errMsgs/PantherBusTreeErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_PBT_INIT = \"PBT:E1\";\nstring constant ERR_UNAUTHORIZED = \"PBT:E2\";\nstring constant ERR_ZERO_REWARD_PARAMS = \"PBT:E3\";\nstring constant ERR_EMPTY_UTXOS_ARRAY = \"PBT:E4\";\nstring constant ERR_TOO_SMALL_REWARD = \"PBT:E5\";\n"
    },
    "contracts/protocol/interfaces/IPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IPantherPoolV1 {\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        address zkpPayer,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256);\n\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/PantherBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IPantherPoolV1.sol\";\n\nimport \"./pantherForest/busTree/BusTree.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\nimport { ERC20_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\nimport \"./errMsgs/PantherBusTreeErrMsgs.sol\";\n\ncontract PantherBusTree is BusTree, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    // TODO: Remove perMinuteUtxosLimit after Testnet (required for Stage #0..2 only)\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address _pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId, _pantherPool) {\n        require(rewardToken != address(0), ERR_PBT_INIT);\n\n        // START_TIME = block.timestamp;\n        START_TIME = 1688987658;\n\n        REWARD_TOKEN = rewardToken;\n    }\n\n    modifier onlyPantherPool() {\n        require(msg.sender == PANTHER_POOL, ERR_UNAUTHORIZED);\n        _;\n    }\n\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate, minEmptyQueueAge);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            ERR_ZERO_REWARD_PARAMS\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3([left, right]);\n    }\n\n    // TODO: Remove getAllowedUtxosAt after Testnet (required for Stage #0..2 only)\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    // TODO: add `reward` as a param of `function addUtxoToBusQueue`\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        onlyPantherPool\n        returns (uint32 queueId, uint8 indexInQueue)\n    {\n        bytes32[] memory utxos = new bytes32[](1);\n        utxos[0] = utxo;\n\n        (queueId, indexInQueue) = addUtxos(utxos, basePerUtxoReward);\n    }\n\n    /// @return firstUtxoQueueId ID of the queue which `utxos[0]` was added to\n    /// @return firstUtxoIndexInQueue Index of `utxos[0]` in the queue\n    /// @dev If the current queue has no space left to add all UTXOs, a part of\n    /// UTXOs only are added to the current queue until it gets full, then the\n    /// remaining UTXOs are added to a new queue.\n    /// Index of any UTXO (not just the 1st one) may be computed as follows:\n    /// - index of UTXO in a queue increments by +1 with every new UTXO added,\n    ///   (from 0 for the 1st UTXO in a queue up to `QUEUE_MAX_SIZE - 1`)\n    /// - number of UTXOs added to the new queue (if there are such) equals to\n    ///   `firstUtxoIndexInQueue + utxos[0].length - QUEUE_MAX_SIZE`\n    /// - new queue (if created) has ID equal to `firstUtxoQueueId + 1`\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        external\n        onlyPantherPool\n        returns (uint32 firstUtxoQueueId, uint8 firstUtxoIndexInQueue)\n    {\n        require(utxos.length != 0, ERR_EMPTY_UTXOS_ARRAY);\n        _checkReward(reward, utxos.length);\n\n        (firstUtxoQueueId, firstUtxoIndexInQueue) = addUtxos(utxos, reward);\n    }\n\n    // TODO: Remove simulateAddUtxosToBusQueue after Testnet (required for Stage #0..2 only)\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxos(utxos, uint96(reward));\n    }\n\n    function _checkReward(uint96 reward, uint256 nUtxos) private view {\n        uint96 minReward = basePerUtxoReward * uint96(nUtxos);\n        require(reward >= minReward, ERR_TOO_SMALL_REWARD);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint40 remainingBlocks;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) internal _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 internal _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Minimum number of blocks an empty queue must pend processing.\n    uint16 private _minEmptyQueueAge;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate,\n        uint256 minEmptyQueueAge\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums or queue age limit, the `updateParams` call needed.\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    // @return minEmptyQueueAge Min number of blocks an empty queue must pend\n    // processing. For a partially filled queue, it declines linearly with the\n    // number of queue's UTXOs. Full queues are immediately processable.\n    function getParams()\n        external\n        view\n        returns (\n            uint16 reservationRate,\n            uint16 premiumRate,\n            uint16 minEmptyQueueAge\n        )\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n        minEmptyQueueAge = _minEmptyQueueAge;\n    }\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _getQueueRemainingBlocks(q),\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // @param maxLength Maximum number of queues to return\n    // @return queues Queues pending processing, starting from the oldest one\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].remainingBlocks = _getQueueRemainingBlocks(queue);\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    // @dev Refer to return values of the `getParam` function\n    function updateParams(\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        _minEmptyQueueAge = minEmptyQueueAge;\n        emit BusQueueRewardParamsUpdated(\n            reservationRate,\n            premiumRate,\n            minEmptyQueueAge\n        );\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxos(bytes32[] memory utxos, uint96 reward)\n        internal\n        returns (uint32 firstQueueId, uint8 firstIndexInFirstQueue)\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n        firstQueueId = queueId;\n        firstIndexInFirstQueue = queue.nUtxos;\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        require(_getQueueRemainingBlocks(queue) == 0, \"BQT:IMMATURE_QUEUE\");\n\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    // Returns the number of blocks to wait until a queue may be processed.\n    // Always returns 0 for a fully populated queue (immediately processable).\n    // For an empty queue it returns a meaningless value.\n    function _getQueueRemainingBlocks(BusQueue memory queue)\n        private\n        view\n        returns (uint40)\n    {\n        if (queue.nUtxos >= QUEUE_MAX_SIZE) return 0;\n\n        // Minimum \"age\" declines linearly to the number of UTXOs in the queue\n        uint256 nEmptySeats = uint256(QUEUE_MAX_SIZE - queue.nUtxos);\n        uint256 minAge = (nEmptySeats * _minEmptyQueueAge) / QUEUE_MAX_SIZE;\n\n        uint256 maturityBlock = minAge + queue.firstUtxoBlock;\n        return\n            block.number >= maturityBlock\n                ? 0 // Overflow risk ignored\n                : uint40(maturityBlock - block.number);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { FIELD_SIZE } from \"../../crypto/SnarkConstants.sol\";\nimport { TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\nimport { BUS_TREE_FOREST_LEAF_INDEX } from \"../Constants.sol\";\nimport \"../interfaces/ITreeRootUpdater.sol\";\nimport \"../../errMsgs/BusTreeErrMsgs.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n * Each time the Bus Tree root is updated, this contract MUST call PantherPoolV1\n * contract to trigger updates of that contract state (see PantherForest).\n */\nabstract contract BusTree is BusQueues, ITreeRootGetter {\n    // TODO: add gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    bytes32 internal constant EMPTY_BUS_TREE_ROOT =\n        TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT;\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(\n        address _verifier,\n        uint160 _circuitId,\n        address _pantherPool\n    ) {\n        require(_pantherPool != address(0), ERR_INIT);\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            ERR_INVALID_VK\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function getRoot` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n\n        PANTHER_POOL = _pantherPool;\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return _busTreeRoot == bytes32(0) ? EMPTY_BUS_TREE_ROOT : _busTreeRoot;\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    /// @dev ZK-circuit public signals:\n    /// @param inputs[0] - oldRoot (BusTree root before insertion)\n    /// @param inputs[1] - newRoot (BusTree root after insertion)\n    /// @param inputs[2] - replacedNodeIndex\n    /// @param inputs[3] - newLeafsCommitment (commitment to leafs in batch)\n    /// @param inputs[4] - nNonEmptyNewLeafs (non-empty leafs in batch number)\n    /// @param inputs[5] - batchRoot (Root of the batch to insert)\n    /// @param inputs[6] - branchRoot (BusTree branch root after insertion)\n    /// @param inputs[7] - extraInput (Hash of `miner` and `queueId`)\n    /// @param inputs[8] - magicalConstraint (non-zero random number)\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        uint256[] memory inputs,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        {\n            bytes32 oldRoot = bytes32(inputs[0]);\n            require(oldRoot == getRoot(), ERR_INVALID_BUS_TREE_ROOT);\n        }\n        {\n            bytes memory extraInput = abi.encodePacked(miner, queueId);\n            uint256 extraInputHash = inputs[7];\n            require(\n                extraInputHash == uint256(keccak256(extraInput)) % FIELD_SIZE,\n                ERR_INVALID_EXTRA_INP\n            );\n        }\n        {\n            uint256 magicalConstraint = inputs[8];\n            require(magicalConstraint != 0, ERR_ZERO_MAGIC_CONSTR);\n        }\n\n        uint32 nBatches = _numBatchesInBusTree;\n        {\n            uint256 replacedNodeIndex = inputs[2];\n            require(replacedNodeIndex == nBatches, ERR_INVALID_REPLACE_INDEX);\n        }\n\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n        {\n            uint256 newLeafsCommitment = inputs[3];\n            require(\n                newLeafsCommitment == uint256(commitment),\n                ERR_INVALID_LEAFS_COMMIT\n            );\n        }\n        {\n            uint256 nNonEmptyNewLeafs = inputs[4];\n            require(nNonEmptyNewLeafs == nUtxos, ERR_INVALID_LEAFS_NUM);\n        }\n\n        // Verify the proof\n        require(\n            VERIFIER.verify(CIRCUIT_ID, inputs, proof),\n            ERR_FAILED_ZK_PROOF\n        );\n\n        bytes32 busBranchNewRoot = bytes32(inputs[6]);\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        // Store updated Bus Tree params\n        bytes32 busTreeNewRoot = bytes32(inputs[1]);\n        _busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // Synchronize the sate of `PantherForest` contract\n        ITreeRootUpdater(PANTHER_POOL).updateRoot(\n            busTreeNewRoot,\n            BUS_TREE_FOREST_LEAF_INDEX\n        );\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n        bytes32 batchRoot = bytes32(inputs[5]);\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// `PantherForest` tree leafs indices (leafs store specific merkle trees roots)\nuint256 constant TAXI_TREE_FOREST_LEAF_INDEX = 0;\nuint256 constant BUS_TREE_FOREST_LEAF_INDEX = 1;\nuint256 constant FERRY_TREE_FOREST_LEAF_INDEX = 2;\nuint256 constant STATIC_TREE_FOREST_LEAF_INDEX = 3;\n\n// `PantherStaticTree` leafs indices (leafs store specific merkle trees roots)\nuint256 constant ZASSET_STATIC_LEAF_INDEX = 0;\nuint256 constant ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX = 1;\nuint256 constant ZNETWORK_STATIC_LEAF_INDEX = 2;\nuint256 constant ZZONE_STATIC_LEAF_INDEX = 3;\nuint256 constant PROVIDERS_KEYS_STATIC_LEAF_INDEX = 4;\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootGetter {\n    function getRoot() external view returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootUpdater {\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// The roots of empty trees follow.\n// An \"empty\" tree is a binary merkle tree of a given number of levels bellow\n// the root (depth), fully populated with ZERO_VALUE leafs, with the `poseidon`\n// hash function applied.\n// (computed by `../../../../lib/binaryMerkleZerosContractGenerator.ts`)\n\nuint256 constant SIX_LEVELS = 6;\n/// @dev Root of the binary merkle SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 0: ZERO_VALUE\n// Level 1: 0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n// Level 2: 0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n// Level 3: 0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n// Level 4: 0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n// Level 5: 0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\nbytes32 constant SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69)\n);\n\nuint256 constant SIXTEEN_LEVELS = 16;\n/// @dev Root of the binary merkle SIXTEEN_LEVELS tree with ZERO_VALUE leafs\n// Level 6:  SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 7:  0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n// Level 8:  0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7\n// Level 9:  0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718\n// Level 10: 0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58\n// Level 11: 0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f\n// Level 12: 0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6\n// Level 13: 0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d\n// Level 14: 0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55\n// Level 15: 0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\nbytes32 constant SIXTEEN_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x0a5e5ec37bd8f9a21a1c2192e7c37d86bf975d947c2b38598b00babe567191c9)\n);\n\nuint256 constant TWENTY_LEVELS = 20;\n/// @dev Root of the merkle binary TWENTY_LEVELS tree with ZERO_VALUE leafs\n// Level 16: SIXTEEN_LEVEL_EMPTY_TREE_ROOT\n// Level 17: 0x21fb04b171b68944c640020a3a464602ec8d02495c44f1e403d9be4a97128e49\n// Level 18: 0x19151c748859974805eb30feac7a301266dec9f67e23e285fe750f86448a2af9\n// Level 19: 0x18fb0b755218eaa809681eb87e45925faa9197507d368210d73b5836ebf139e4\nbytes32 constant TWENTY_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1e294375b42dfd97795e07e1fe8bd6cefcb16c3bbb71b30bed950f8965861244)\n);\n\nuint256 constant TWENTY_SIX_LEVELS = 26;\n/// @dev Root of the binary merkle TWENTY_SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 21: 0x0d3e4235db275d9bab0808dd9ade8789d46d0e1f1c9a99ce73fefca51dc92f4a\n// Level 22: 0x075ab2ca945c4dc5ea40a9f1c66d5bf3c367cef1e04e73aa17c2bc747eb5fc87\n// Level 23: 0x26f0f533a8ea2210001aeb8f8306c7c70656ba6afe145c6540bd4ed2c967a230\n// Level 24: 0x24be7e64f680326e6e3621e5862d7b6b1f31e9e183a0bf5dd04e823be84e6af9\n// Level 25: 0x212b13c9cbf421942ae3e3c62a3c072903c2a745a220cfb3c43cd520f55f44bf\nbytes32 constant TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n\nuint256 constant THIRTY_TWO_LEVELS = 32;\n/// @dev Root of the binary merkle THIRTY_TWO_LEVELS tree with ZERO_VALUE leafs\n// Level 26: TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 27: 0x038acf368a174e10c45a64161131c0f93faf2f045ff663acbef804eb5644aad7\n// Level 28: 0x1b3ecbe4131d8d52d60b91ec8e13d5fc82235232bb43007d54cda6b50d932d6f\n// Level 29: 0x1b0b9059f431d38a66c82317d9ed1b744c439f10193ae44bcf519fe6e1766b65\n// Level 30: 0x240867e8bb31d6b8057f5ab067dc0bd1c4ba64a42258963ec45b7b4773ce5838\n// Level 31: 0x2310e5b3543ea766ecaec53003d0e1b73f19a149409190d00561da7090a2c5cb\nbytes32 constant THIRTY_TWO_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x24ab16594d418ca2e66ca284f56a4cb7039c6d8f8e0c3c8f362cf18b5afa19d0)\n);\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}