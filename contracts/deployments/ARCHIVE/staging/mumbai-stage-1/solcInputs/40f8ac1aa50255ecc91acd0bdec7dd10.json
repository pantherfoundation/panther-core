{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/common/Claimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"./TransferHelper.sol\";\n\n/**\n * @title Claimable\n * @notice It withdraws accidentally sent tokens or ETH from this contract.\n */\nabstract contract Claimable {\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    function _claimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // withdraw ERC20\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function _claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (token == address(0)) {\n            // withdraw ETH\n            TransferHelper.safeTransferETH(to, amount);\n        } else {\n            // withdraw ERC20\n            TransferHelper.safeTransfer(token, to, amount);\n        }\n    }\n}\n"
    },
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/mocks/MockFxPortal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"../TransferHelper.sol\";\nimport \"../ImmutableOwnable.sol\";\n\nimport \"../../staking/interfaces/IFxStateSender.sol\";\nimport \"../../staking/interfaces/IFxMessageProcessor.sol\";\n\ninterface IPZkp {\n    function deposit(address user, bytes calldata depositData) external;\n}\n\ninterface IRootChainManager {\n    function depositFor(\n        address receiver,\n        address token,\n        bytes calldata depositData\n    ) external;\n}\n\ncontract MockFxPortal is ImmutableOwnable, IRootChainManager, IFxStateSender {\n    using TransferHelper for address;\n\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n    address public immutable PZKP_TOKEN;\n    address public immutable ZKP_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    event DepositForLog(address receiver, address token, bytes depositData);\n    event SendMessageToChildLog(address _receiver, bytes _data);\n    event ProcessMessageFromRootLog(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes data\n    );\n\n    constructor(\n        address _owner,\n        address _zkpToken,\n        address _pZkpToken\n    ) ImmutableOwnable(_owner) {\n        require(\n            _zkpToken != address(0) && _pZkpToken != address(0),\n            \"init: zero address\"\n        );\n\n        ZKP_TOKEN = _zkpToken;\n        PZKP_TOKEN = _pZkpToken;\n    }\n\n    // simulate message bridging\n    function sendMessageToChild(address receiver, bytes calldata data)\n        external\n    {\n        IFxMessageProcessor(receiver).processMessageFromRoot(\n            uint256(0), // stateId\n            msg.sender, // rootMessageSender\n            data // content\n        );\n\n        emit SendMessageToChildLog(receiver, data);\n    }\n\n    // simulate token bridging\n    function depositFor(\n        address receiver,\n        address token,\n        bytes calldata depositData\n    ) external {\n        require(token == ZKP_TOKEN, \"MOCKFX::depositFor: invalid token\");\n\n        uint256 amount = abi.decode(depositData, (uint256));\n        require(amount > 0, \"MOCKFX::depositFor: zero amount\");\n\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        IPZkp(PZKP_TOKEN).deposit(receiver, depositData);\n\n        emit DepositForLog(receiver, token, depositData);\n    }\n}\n"
    },
    "contracts/common/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title NonReentrant\n * @notice It provides reentrancy guard.\n * The code borrowed from openzeppelin-contracts.\n * Unlike original, this version requires neither `constructor` no `init` call.\n */\nabstract contract NonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    modifier nonReentrant() {\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\n        // it does not revert (which is expected behaviour)\n        require(_reentrancyStatus != _ENTERED, \"claimErc20: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/common/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title TransferHelper library\n/// @dev Helper methods for interacting with ERC20, ERC721, ERC1155 tokens and sending ETH\n/// Based on the Uniswap/solidity-lib/contracts/libraries/TransferHelper.sol\nlibrary TransferHelper {\n    /// @dev Throws if the deployed code of the `token` is empty.\n    // Low-level CALL to a non-existing contract returns `success` of 1 and empty `data`.\n    // It may be misinterpreted as a successful call to a deployed token contract.\n    // So, the code calling a token contract must insure the contract code exists.\n    modifier onlyDeployedToken(address token) {\n        uint256 codeSize;\n        // slither-disable-next-line assembly\n        assembly {\n            codeSize := extcodesize(token)\n        }\n        require(codeSize > 0, \"TransferHelper: zero codesize\");\n        _;\n    }\n\n    /// @dev Approve the `operator` to spend all of ERC720 tokens on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeSetApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('setApprovalForAll(address,bool)'));\n            abi.encodeWithSelector(0xa22cb465, operator, approved)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Get the ERC20 balance of `account`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeBalanceOf(address token, address account)\n        internal\n        returns (uint256 balance)\n    {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(bytes('balanceOf(address)')));\n            abi.encodeWithSelector(0x70a08231, account)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: balanceOff call failed\"\n        );\n\n        balance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Approve the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('approve(address,uint256)'));\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transfer(address,uint256)'));\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer an ERC721 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc721SafeTransferFrom(\n        address token,\n        uint256 tokenId,\n        address from,\n        address to\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x42842e0e, from, to, tokenId)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `amount` ERC1155 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc1155SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory _data\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'));\n            abi.encodeWithSelector(0xf242432a, from, to, tokenId, amount, _data)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` Ether from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferETH(address to, uint256 value) internal {\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"TransferHelper: ETH transfer failed\");\n    }\n\n    function _requireSuccess(bool success, bytes memory res) private pure {\n        require(\n            success && (res.length == 0 || abi.decode(res, (bool))),\n            \"TransferHelper: token contract call failed\"\n        );\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nabstract contract Utils {\n    // false positive\n    // slither-disable-next-line timestamp\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/protocol/crypto/BabyJubJub.sol": {
      "content": "// SPDX-License-Identifier: GPL\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// Implementer name - yondonfu\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\npragma solidity ^0.8.16;\nimport \"../../common/Types.sol\";\n\nlibrary BabyJubJub {\n    // Curve parameters\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\n    // A = 168700\n    uint256 public constant A = 0x292FC;\n    // D = 168696\n    uint256 public constant D = 0x292F8;\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    // slither-disable-next-line too-many-digits\n    uint256 public constant Q =\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\n\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\n    // That is, it generates the set of points of order l and origin O.\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_X =\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_Y =\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n    /**\n     * @dev Add 2 points on baby jubjub curve\n     * Formulae for adding 2 points on a twisted Edwards curve:\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\n     */\n    function pointAdd(G1Point memory g1, G1Point memory g2)\n        internal\n        view\n        returns (G1Point memory)\n    {\n        uint256 x3 = 0;\n        uint256 y3 = 0;\n        if (g1.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        if (g2.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\n\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\n        return G1Point(x3, y3);\n    }\n\n    /**\n     * @dev Perform modular subtraction\n     */\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        uint256 aNN = _a;\n\n        if (_a <= _b) {\n            aNN += _mod;\n        }\n\n        return addmod(aNN - _b, 0, _mod);\n    }\n\n    /**\n     * @dev Compute modular inverse of a number\n     */\n    function inverse(uint256 _a) internal view returns (uint256) {\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\n        return expmod(_a, Q - 2, Q);\n    }\n\n    /**\n     * @dev Helper function to call the bigModExp precompile\n     */\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20) // Length of base _b\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\n            mstore(add(memPtr, 0x60), _b) // Base _b\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\n\n            // The bigModExp precompile is at 0x05\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n        // solhint-enable no-inline-assembly\n    }\n\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        r.x = 0;\n        r.y = 1;\n\n        uint256 rem = scalar;\n        G1Point memory exp = point;\n\n        while (rem != uint256(0)) {\n            if ((rem & 1) == 1) {\n                r = pointAdd(r, exp);\n            }\n            exp = pointAdd(exp, exp);\n            rem = rem >> 1;\n        }\n        r.x = r.x % Q;\n        r.y = r.y % Q;\n\n        return r;\n    }\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/errMsgs/PantherPoolErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// CommitmentGenerator contract\nstring constant ERR_TOO_LARGE_PUBKEY = \"CG:E1\";\n\n// CommitmentsTrees contract\nstring constant ERR_TOO_LARGE_COMMITMENTS = \"CT:E1\"; // commitment exceeds maximum scalar field size\n\n// MerkleProofVerifier\nstring constant ERR_MERKLE_PROOF_VERIFICATION_FAILED = \"MP:E1\";\nstring constant ERR_TRIAD_INDEX_MIN_VALUE = \"MP:E2\";\nstring constant ERR_TRIAD_INDEX_MAX_VALUE = \"MP:E3\";\n\n// TriadIncrementalMerkleTrees contract\nstring constant ERR_ZERO_ROOT = \"TT:E1\"; // merkle tree root can not be zero\n\n// PantherPool contract\nstring constant ERR_DEPOSIT_OVER_LIMIT = \"PP:E1\";\nstring constant ERR_DEPOSIT_FROM_ZERO_ADDRESS = \"PP:E2\";\nstring constant ERR_EXITCOMMIT_EXISTS = \"PP:E32\";\nstring constant ERR_EXITCOMMIT_LOCKED = \"PP:E33\";\nstring constant ERR_EXITCOMMIT_MISSING = \"PP:E34\";\nstring constant ERR_EXPIRED_TX_TIME = \"PP:E3\";\nstring constant ERR_INVALID_JOIN_INPUT = \"PP:E4\";\nstring constant ERR_INVALID_PROOF = \"PP:E5\";\nstring constant ERR_MISMATCHED_ARR_LENGTH = \"PP:E6\";\nstring constant ERR_PLUGIN_FAILURE = \"PP:E7\";\nstring constant ERR_SPENT_NULLIFIER = \"PP:E8\";\nstring constant ERR_TOO_EARLY_CREATED_AT = \"PP:E9\";\nstring constant ERR_TOO_EARLY_EXIT = \"PP:E30\";\nstring constant ERR_TOO_LARGE_AMOUNT = \"PP:E10\";\nstring constant ERR_TOO_LARGE_COMMITMENT = \"PP:E11\";\nstring constant ERR_TOO_LARGE_NULLIFIER = \"PP:E12\";\nstring constant ERR_TOO_LARGE_LEAFID = \"PP:E27\";\nstring constant ERR_TOO_LARGE_PRIVKEY = \"PP:E28\";\nstring constant ERR_TOO_LARGE_ROOT = \"PP:E13\";\nstring constant ERR_TOO_LARGE_SCALED_AMOUNT = \"PP:E26\";\nstring constant ERR_TOO_LARGE_TIME = \"PP:E14\";\nstring constant ERR_UNCONFIGURED_EXIT_TIME = \"PP:E31\";\nstring constant ERR_UNKNOWN_MERKLE_ROOT = \"PP:E16\";\nstring constant ERR_WITHDRAW_OVER_LIMIT = \"PP:E17\";\nstring constant ERR_WITHDRAW_TO_ZERO_ADDRESS = \"PP:E18\";\nstring constant ERR_WRONG_ASSET = \"PP:E19\";\nstring constant ERR_WRONG_DEPOSIT = \"PP:E29\";\nstring constant ERR_WRONG_PRP_SUBID = \"PP:E25\";\nstring constant ERR_ZERO_DEPOSIT = \"PP:E21\";\nstring constant ERR_ZERO_FEE_PAYER = \"PP:E22\";\nstring constant ERR_ZERO_TOKEN_EXPECTED = \"PP:E23\";\nstring constant ERR_ZERO_TOKEN_UNEXPECTED = \"PP:E24\";\n"
    },
    "contracts/protocol/errMsgs/VaultErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INVALID_TOKEN_TYPE = \"VA:E1\";\nstring constant ERR_ZERO_LOCK_TOKEN_ADDR = \"VA:E2\";\nstring constant ERR_ZERO_EXT_ACCOUNT_ADDR = \"VA:E3\";\nstring constant ERR_ZERO_EXT_AMOUNT = \"VA:E4\";\n"
    },
    "contracts/protocol/errMsgs/ZAssetsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_ASSET_ALREADY_REGISTERED = \"AR:E1\";\nstring constant ERR_UNKNOWN_ASSET = \"AR:E2\";\nstring constant ERR_WRONG_ASSET_STATUS = \"AR:E3\";\nstring constant ERR_WRONG_ASSET_SCALE = \"AR:E4\";\nstring constant ERR_WRONG_ASSET_VER = \"AR:E5\";\nstring constant ERR_ZERO_SUBID_EXPECTED = \"AR:E6\";\nstring constant ERR_ZERO_TOKEN_ADDRESS = \"AR:E7\";\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IPrpGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @title IPrpGrantor\n * @notice Interface for the `PrpGrantor` contract\n * @dev Excluding `onlyOwner` functions\n */\ninterface IPrpGrantor {\n    /// @notice Return the address of the \"grant processor\"\n    /// @dev This account only is authorized to call `redeemGrant`\n    function grantProcessor() external view returns (address);\n\n    /// @notice Returns the total amount (in PRPs) of grants issued so far\n    /// (excluding burnt grants)\n    function totalGrantsIssued() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of grants redeemed so far\n    function totalGrantsRedeemed() external returns (uint256);\n\n    /// @notice Returns the total amount (in PRPs) of unused grants for the given grantee\n    function getUnusedGrantAmount(address grantee)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Returns the PRP amount of the grant specified by a given curator and type\n    function getGrantAmount(address curator, bytes4 grantType)\n        external\n        view\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// defined for the given \"grant type\"\n    /// @return prpAmount The amount (in PRPs) of the grant\n    /// @dev An authorized \"curator\" may call with the enabled (added) \"grant type\" only\n    function issueGrant(address grantee, bytes4 grantType)\n        external\n        returns (uint256 prpAmount);\n\n    /// @notice Increase the amount of \"unused\" grants for the given grantee, by the amount\n    /// specified.\n    /// @dev Only the owner may call.\n    function issueOwnerGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice Burn unused grants for the msg.sender in the specified PRP amount\n    function burnGrant(uint256 prpAmount) external;\n\n    /// @notice Account for redemption of grants in the given amount for the given grantee\n    /// @dev Only the account returned by `grantProcessor()` may call\n    function redeemGrant(address grantee, uint256 prpAmount) external;\n\n    /// @notice PRP grant issued\n    event PrpGrantIssued(\n        bytes4 indexed grantType,\n        address grantee,\n        uint256 prpAmount\n    );\n\n    /// @notice PRP grant redeemed (used)\n    event PrpGrantRedeemed(address grantee, uint256 prpAmount);\n\n    /// @notice PRP grant burnt\n    event PrpGrantBurnt(address grantee, uint256 prpAmount);\n\n    /// @notice New grant type added\n    event PrpGrantEnabled(address curator, bytes4 grantType, uint256 prpAmount);\n\n    /// @notice Existing grant type disabled\n    event PrpGrantDisabled(address curator, bytes4 grantType);\n}\n"
    },
    "contracts/protocol/interfaces/IRootsHistory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IRootsHistory {\n    /// @notice Returns `true` if the given root of the given tree is known\n    /// @param cacheIndexHint Index of the root in the cache, ignored if 0\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) external view returns (bool);\n}\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/interfaces/IZAssetsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZAsset } from \"../../common/Types.sol\";\n\ninterface IZAssetsRegistry {\n    /// @dev declared as view rather than pure to allow for protocol changes\n    function getZAssetId(address token, uint256 subId)\n        external\n        view\n        returns (uint160);\n\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        );\n\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        returns (ZAsset memory asset);\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        returns (bool);\n\n    event AssetAdded(uint160 indexed zAssetRecId, ZAsset asset);\n    event AssetStatusChanged(\n        uint160 indexed zAssetRecId,\n        uint8 newStatus,\n        uint8 oldStatus\n    );\n}\n"
    },
    "contracts/protocol/mocks/FakeVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\nimport \"../interfaces/IVault.sol\";\n\ncontract FakeVault is IVault {\n    event DebugData(LockData data);\n\n    function lockAsset(LockData calldata data) external override {\n        emit DebugData(data);\n    }\n\n    function unlockAsset(LockData memory data) external override {\n        emit DebugData(data);\n    }\n}\n"
    },
    "contracts/protocol/mocks/LocalDevEnv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { DEAD_CODE_ADDRESS } from \"../../common/Constants.sol\";\n\ncontract LocalDevEnv {\n    modifier onlyLocalDevEnv() {\n        // DEAD_CODE_ADDRESS is supposed (and must) be and unusable address,\n        // which eliminate risks of using tx.origin here.\n        // solhint-disable-next-line avoid-tx-origin\n        require(tx.origin == DEAD_CODE_ADDRESS, \"Only allowed in forked env\");\n        _;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\n\n// solhint-disable var-name-mixedcase\n// solhint-disable no-empty-blocks\n// solhint-disable func-name-mixedcase\n// solhint-disable event-name-camelcase\ncontract MockPantherPoolV0 is PantherPoolV0 {\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) PantherPoolV0(_owner, assetRegistry, vault) {}\n\n    event RESULT_processDepositedAsset(uint160 zAssetId, uint96 scaledAmount);\n\n    function internalProcessDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 extAmount\n    ) external {\n        (uint160 zAssetId, uint96 scaledAmount) = _processDepositedAsset(\n            token,\n            subId,\n            extAmount\n        );\n        emit RESULT_processDepositedAsset(zAssetId, scaledAmount);\n    }\n\n    function testGeneratePublicSpendingKey(uint256 privKey)\n        external\n        view\n        returns (uint256[2] memory xy)\n    {\n        G1Point memory p;\n        p = generatePubSpendingKey(privKey);\n        xy[0] = p.x;\n        xy[1] = p.y;\n    }\n\n    function testUpdateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n    {\n        this.updateExitTimes(newExitTime, newExitDelay);\n    }\n\n    function testExit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external {\n        this.exit(\n            token,\n            subId,\n            scaledAmount,\n            creationTime,\n            privSpendingKey,\n            leafId,\n            pathElements,\n            merkleRoot,\n            cacheIndexHint\n        );\n    }\n\n    function testGenerateCommitments(\n        uint256 pubSpendingKeyX,\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) external pure returns (uint256) {\n        return\n            uint256(\n                generateCommitment(\n                    pubSpendingKeyX,\n                    pubSpendingKeyY,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023s Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../interfaces/IVault.sol\";\nimport \"../../common/ImmutableOwnable.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IMockPantherPoolV1 {\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n\n// solhint-disable var-name-mixedcase\n// slither-disable shadowing-state\n// slither-disable unused-state\ncontract MockPantherPoolV1 is IMockPantherPoolV1, ImmutableOwnable {\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[500] private __gap;\n\n    address public immutable VAULT;\n\n    mapping(address => bool) public vaultAssetUnlockers;\n\n    constructor(address vault, address _owner) ImmutableOwnable(_owner) {\n        require(vault != address(0), \"init: zero address\");\n        VAULT = vault;\n    }\n\n    function updateVaultAssetUnlocker(address _unlocker, bool _status)\n        external\n        onlyOwner\n    {\n        vaultAssetUnlockers[_unlocker] = _status;\n    }\n\n    function unlockAssetFromVault(LockData calldata data) external {\n        require(vaultAssetUnlockers[msg.sender], \"mockPoolV1: unauthorized\");\n\n        IVault(VAULT).unlockAsset(data);\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryAndVaultTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"../Vault.sol\";\nimport \"../../common/Types.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistry.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n// import \"hardhat/console.sol\";\n\ncontract MyERC20 is ERC20 {\n    constructor(uint256 index, address owner)\n        ERC20(Strings.toString(index), Strings.toString(index))\n    {\n        uint256 totalSupply = 1024;\n        _mint(owner, totalSupply);\n    }\n    /*\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        console.logString(\" --- TOKEN --- \");\n        console.logString(\"msg.sender\");\n        console.log(msg.sender);\n        console.logString(\"Spender\");\n        console.log(spender);\n        console.logString(\"To\");\n        console.log(to);\n        console.logString(\"From\");\n        console.log(from);\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, scaledAmount);\n        return true;\n    }\n    */\n}\n\n// solhint-disable var-name-mixedcase\ncontract PantherPoolV0AndZAssetRegistryAndVaultTester is MockPantherPoolV0 {\n    address private registry;\n    MyERC20[OUT_UTXOs] private Tokens;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry and Vault\n            registry = address(new ZAssetsRegistry(address(this))),\n            address(new Vault(address(this)))\n        )\n    {\n        for (uint256 i = 0; i < OUT_UTXOs; ++i) {\n            Tokens[i] = new MyERC20(i, address(this)); // This mock is an owner of MyERC20\n            ZAsset memory z;\n            z.tokenType = ERC20_TOKEN_TYPE;\n            z.version = 0;\n            z.scale = 0;\n            z.token = address(Tokens[i]);\n            z.status = zASSET_ENABLED;\n            ZAssetsRegistry(registry).addZAsset(z);\n        }\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testGetZAssetId(uint256 token, uint256 tokenId)\n        external\n        view\n        returns (uint160)\n    {\n        return\n            ZAssetsRegistry(registry).getZAssetId(\n                address(uint160(token)),\n                tokenId\n            );\n    }\n\n    function getTokenAddress(uint256 index) external view returns (address) {\n        return address(Tokens[index]);\n    }\n\n    function approveVault(uint256 amount, uint256 index) external {\n        Tokens[index].approve(VAULT, amount);\n    }\n\n    function generateDepositsExtended(\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        uint256[OUT_UTXOs] memory tokenIds;\n        tokenIds[0] = 0;\n        tokenIds[1] = 0;\n        tokenIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        for (uint256 i = 0; i < OUT_UTXOs; i++) {\n            this.approveVault(extAmounts[i], i);\n        }\n\n        this.generateDeposits(\n            [address(Tokens[0]), address(Tokens[1]), address(Tokens[2])],\n            tokenIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "contracts/protocol/mocks/PantherPoolV0AndZAssetRegistryTester.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../PantherPoolV0.sol\";\nimport \"./FakeVault.sol\";\nimport \"./MockPantherPoolV0.sol\";\nimport \"../ZAssetsRegistry.sol\";\n\ncontract PantherPoolV0AndZAssetRegistryTester is MockPantherPoolV0 {\n    address private registry;\n\n    constructor()\n        MockPantherPoolV0(\n            address(this),\n            // This mock is the owner of ZAssetsRegistry\n            registry = address(new ZAssetsRegistry(address(this))),\n            address(new FakeVault())\n        )\n    {\n        ZAsset memory z1;\n        z1.tokenType = ERC20_TOKEN_TYPE;\n        z1.version = 0;\n        z1.scale = 0;\n        z1.token = address(uint160(111));\n        z1.status = zASSET_ENABLED;\n        ZAssetsRegistry(registry).addZAsset(z1);\n\n        exitTime = safe32TimeNow() + 1;\n    }\n\n    function testConvert(uint256 n) external pure returns (bytes32) {\n        return bytes32(n);\n    }\n\n    function testGenerateDepositsExtended(\n        address[OUT_UTXOs] calldata tokens,\n        uint256[OUT_UTXOs] calldata extAmounts,\n        uint256[2] calldata pubKeys,\n        uint256[CIPHERTEXT1_WORDS] calldata secrets,\n        uint32 createdAt\n    ) external {\n        address[OUT_UTXOs] memory tokenss;\n        tokenss[0] = tokens[0];\n        tokenss[1] = tokens[1];\n        tokenss[2] = tokens[2];\n\n        uint256[OUT_UTXOs] memory subIds;\n        subIds[0] = 0;\n        subIds[1] = 0;\n        subIds[2] = 0;\n\n        G1Point[OUT_UTXOs] memory pubKeyss;\n        pubKeyss[0] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[1] = G1Point(pubKeys[0], pubKeys[1]);\n        pubKeyss[2] = G1Point(pubKeys[0], pubKeys[1]);\n\n        uint256[CIPHERTEXT1_WORDS][OUT_UTXOs] memory secretss;\n        secretss[0][0] = secrets[0];\n        secretss[0][1] = secrets[1];\n        secretss[1][0] = secrets[0];\n        secretss[1][1] = secrets[1];\n        secretss[2][0] = secrets[0];\n        secretss[2][1] = secrets[1];\n\n        this.generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            pubKeyss,\n            secretss,\n            createdAt\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint40 remainingBlocks;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) private _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 private _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Minimum number of blocks an empty queue must pend processing.\n    uint16 private _minEmptyQueueAge;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate,\n        uint256 minEmptyQueueAge\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums or queue age limit, the `updateParams` call needed.\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    // @return minEmptyQueueAge Min number of blocks an empty queue must pend\n    // processing. For a partially filled queue, it declines linearly with the\n    // number of queue's UTXOs. Full queues are immediately processable.\n    function getParams()\n        external\n        view\n        returns (\n            uint16 reservationRate,\n            uint16 premiumRate,\n            uint16 minEmptyQueueAge\n        )\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n        minEmptyQueueAge = _minEmptyQueueAge;\n    }\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _getQueueRemainingBlocks(q),\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // @param maxLength Maximum number of queues to return\n    // @return queues Queues pending processing, starting from the oldest one\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].remainingBlocks = _getQueueRemainingBlocks(queue);\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    // @dev Refer to return values of the `getParam` function\n    function updateParams(\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        _minEmptyQueueAge = minEmptyQueueAge;\n        emit BusQueueRewardParamsUpdated(\n            reservationRate,\n            premiumRate,\n            minEmptyQueueAge\n        );\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        internal\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        require(_getQueueRemainingBlocks(queue) == 0, \"BQT:IMMATURE_QUEUE\");\n\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    // Returns the number of blocks to wait until a queue may be processed.\n    // Always returns 0 for a fully populated queue (immediately processable).\n    // For an empty queue it returns a meaningless value.\n    function _getQueueRemainingBlocks(BusQueue memory queue)\n        private\n        view\n        returns (uint40)\n    {\n        if (queue.nUtxos >= QUEUE_MAX_SIZE) return 0;\n\n        // Minimum \"age\" declines linearly to the number of UTXOs in the queue\n        uint256 nEmptySeats = uint256(QUEUE_MAX_SIZE - queue.nUtxos);\n        uint256 minAge = (nEmptySeats * _minEmptyQueueAge) / QUEUE_MAX_SIZE;\n\n        uint256 maturityBlock = minAge + queue.firstUtxoBlock;\n        return\n            block.number >= maturityBlock\n                ? 0 // Overflow risk ignored\n                : uint40(maturityBlock - block.number);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport { EMPTY_BUS_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\nimport { MAGICAL_CONSTRAINT } from \"../../crypto/SnarkConstants.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n */\nabstract contract BusTree is BusQueues {\n    // solhint-disable var-name-mixedcase\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 public busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(address _verifier, uint160 _circuitId) {\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            \"BT:INVALID_VK\"\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function onboardQueue` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        bytes32 busTreeNewRoot,\n        bytes32 batchRoot,\n        bytes32 busBranchNewRoot,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        uint32 nBatches = _numBatchesInBusTree;\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n\n        // Circuit public input signals\n        uint256[] memory input = new uint256[](9);\n        // `oldRoot` signal\n        input[0] = nBatches == 0\n            ? uint256(EMPTY_BUS_TREE_ROOT)\n            : uint256(busTreeRoot);\n        // `newRoot` signal\n        input[1] = uint256(busTreeNewRoot);\n        // `replacedNodeIndex` signal\n        input[2] = nBatches;\n        // `newLeafsCommitment` signal\n        input[3] = uint256(commitment);\n        // `nNonEmptyNewLeafs` signal\n        input[4] = uint256(nUtxos);\n        // `batchRoot` signal\n        input[5] = uint256(batchRoot);\n        // `branchRoot` signal\n        input[6] = uint256(busBranchNewRoot);\n        // `extraInput` signal (front-run protection)\n        input[7] = uint256(uint160(miner));\n        // magicalConstraint\n        input[8] = MAGICAL_CONSTRAINT;\n\n        // Verify the proof\n        require(VERIFIER.verify(CIRCUIT_ID, input, proof), \"BT:FAILED_PROOF\");\n\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        // Store updated Bus Tree params\n        busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryIncrementalTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstruct BinaryTree {\n    uint8 depth;\n    uint32 nLeafs;\n    bytes32 root;\n}\n\nabstract contract BinaryIncrementalTree {\n    function insertLeafs(BinaryTree storage tree, bytes32[] memory leafs)\n        internal\n        returns (uint256 firstLeafIndex, bytes32 newRoot)\n    {\n        // TODO: implement BinaryIncrementalTree::insertLeafs\n        return (0, 0);\n    }\n\n    function insertLeaf(BinaryTree storage tree, bytes32 leaf)\n        internal\n        returns (uint256 leafIndex, bytes32 newRoot)\n    {\n        // TODO: implement BinaryIncrementalTree::insertLeaf\n        return (0, 0);\n    }\n\n    function hash(bytes32[2] memory) internal view virtual returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryUpdatableTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BinaryIncrementalTree.sol\";\n\nabstract contract BinaryUpdatableTree is BinaryIncrementalTree {\n    function updateLeaf(\n        BinaryTree memory, /*tree*/\n        bytes32, /*newLeaf*/\n        bytes32, /*oldLeaf*/\n        uint256, /*leafInd*/\n        bytes32[] memory /*siblings*/\n    ) internal returns (bytes32 newRoot) {\n        // TODO: implement BinaryUpdatableTree::insertLeaf\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/mocks/MockBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { IMockPantherPoolV1 } from \"../../mocks/MockPantherPoolV1.sol\";\n\nimport \"../busTree/BusTree.sol\";\nimport { PoseidonT3 } from \"../../crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"../../crypto/SnarkConstants.sol\";\nimport { DEAD_CODE_ADDRESS, ERC20_TOKEN_TYPE } from \"../../../common/Constants.sol\";\nimport { LockData } from \"../../../common/Types.sol\";\nimport \"../../../common/ImmutableOwnable.sol\";\nimport \"../../mocks/LocalDevEnv.sol\";\n\ncontract MockBusTree is BusTree, LocalDevEnv, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n\n    // solhint-enable var-name-mixedcase\n\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId) {\n        require(\n            rewardToken != address(0) && pantherPool != address(0),\n            \"init: zero address\"\n        );\n\n        START_TIME = block.timestamp;\n\n        REWARD_TOKEN = rewardToken;\n        PANTHER_POOL = pantherPool;\n    }\n\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate, minEmptyQueueAge);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            \"updateParams: zero value\"\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IMockPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        require(\n            uint256(left) < FIELD_SIZE && uint256(right) < FIELD_SIZE,\n            \"BT:TOO_LARGE_LEAF_INPUT\"\n        );\n        return PoseidonT3.poseidon([left, right]);\n    }\n\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxosToBusQueue(utxos, uint96(reward));\n    }\n\n    function simulateAddGivenUtxosToBusQueue(\n        bytes32[] memory utxos,\n        uint96 reward\n    ) external onlyLocalDevEnv {\n        addUtxosToBusQueue(utxos, reward);\n    }\n\n    function simulateAddBusQueueReward(uint32 queueId, uint96 extraReward)\n        external\n        onlyLocalDevEnv\n    {\n        addBusQueueReward(queueId, extraReward);\n    }\n\n    function simulateSetBusQueueAsProcessed(uint32 queueId)\n        external\n        onlyLocalDevEnv\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        return setBusQueueAsProcessed(queueId);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/PantherForest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./busTree/BusTree.sol\";\nimport \"./rootHistory/RootHistory.sol\";\nimport \"./taxiTree/TaxiTree.sol\";\n\nabstract contract PantherForest is TaxiTree, BusTree, RootHistory {\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        override\n        returns (bytes32);\n\n    function hash(bytes32[4] memory) internal pure virtual returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/rootHistory/RootHistory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nabstract contract RootHistory {}\n"
    },
    "contracts/protocol/pantherForest/taxiTree/TaxiTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/BinaryUpdatableTree.sol\";\nimport \"../zeroTrees/SixLevelZeroTree.sol\";\n\n// is PantherTreesZeros\nabstract contract TaxiTree is BinaryUpdatableTree, SixLevelZeroTree {\n\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n// TODO: remove duplications of ZERO_LEAF across ../../\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// @dev Number of levels (bellow the root, but including leafs) in the BusTree\nuint256 constant BUS_TREE_LEVELS = 26;\n\n// @dev Root of the binary tree of BUS_TREE_LEVELS with leafs of ZERO_VALUE\n// Computed using `../../../../lib/binaryMerkleZerosContractGenerator.ts`\nbytes32 constant EMPTY_BUS_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/SixLevelZeroTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZERO_VALUE } from \"./Constants.sol\";\n\n// @notice The binary Merkle tree of six levels populated with zero leaf values\nabstract contract SixLevelZeroTree {\n    // @dev Number of levels in a tree excluding the root level\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 internal constant SIX_LEVELS = 6;\n\n    // @param level From 0 for the leaf up to SIX_LEVELS for the root\n    function getZeroNodeAtLevel(uint256 level) internal pure returns (bytes32) {\n        require(level < SIX_LEVELS + 1, \"SZT:E1\");\n\n        // Generated by `../../../../lib/binaryMerkleZerosContractGenerator.ts`\n        uint256 zeroNode = [\n            // Leaf with the zero value\n            uint256(ZERO_VALUE),\n            // Roots of branches containing zero leafs only, one root per level\n            0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4,\n            0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8,\n            0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c,\n            0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800,\n            0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f,\n            // Root of the tree fully populated with zero leafs only\n            0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n        ][level];\n\n        return bytes32(zeroNode);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/AmountConvertor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { MAX_EXT_AMOUNT, MAX_IN_CIRCUIT_AMOUNT } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_AMOUNT, ERR_TOO_LARGE_SCALED_AMOUNT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title AmountConvertor\n * @author Pantherprotocol Contributors\n * @notice Methods for scaling amounts for computations within/outside the\n * Panther Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\nabstract contract AmountConvertor {\n    // \"Scaled amounts\" - amounts ZK-circuits of the MASP operate with\n    // \"Unscaled amounts\" - amounts token contracts operate with\n    // Scaling is relevant for fungible tokens only - for ERC-721/ERC-1155\n    // tokens, scaled and unscaled amounts MUST be equal. For some ERC-20\n    // tokens, the \"scaling factor\" MAY be 1:1, i.e. scaled and unscaled\n    // amounts are equal.\n\n    // Conversion from the unscaled amount (aka amount) to the scaled one.\n    // Returns the scaled amount and the reminder.\n    function _scaleAmount(uint256 amount, uint8 scale)\n        internal\n        pure\n        returns (uint64 scaledAmount, uint256 change)\n    {\n        uint256 _scaledAmount;\n        if (scale == 0) {\n            // No scaling and no change for zero `scale`\n            _scaledAmount = amount;\n            change = 0;\n        } else {\n            unchecked {\n                uint256 factor = _getScalingFactor(scale);\n                // divider can't be zero, loss of precision assumed\n                // slither-disable-next-line divide-before-multiply\n                _scaledAmount = amount / factor;\n                // `restoredAmount` can not exceed the `amount`\n                uint256 restoredAmount = _scaledAmount * factor;\n                change = amount - restoredAmount;\n            }\n        }\n        scaledAmount = _sanitizeScaledAmount(_scaledAmount);\n    }\n\n    // Conversion from the scaled amount to unscaled one.\n    // Returns the unscaled amount.\n    function _unscaleAmount(uint64 scaledAmount, uint8 scale)\n        internal\n        pure\n        returns (uint96)\n    {\n        uint256 amount = scale == 0\n            ? scaledAmount // no scaling\n            : uint256(scaledAmount) * _getScalingFactor(scale);\n        return _sanitizeAmount(amount);\n    }\n\n    function _sanitizeAmount(uint256 amount) internal pure returns (uint96) {\n        require(amount < MAX_EXT_AMOUNT, ERR_TOO_LARGE_AMOUNT);\n        return uint96(amount);\n    }\n\n    function _sanitizeScaledAmount(uint256 scaledAmount)\n        internal\n        pure\n        returns (uint64)\n    {\n        require(\n            scaledAmount < MAX_IN_CIRCUIT_AMOUNT,\n            ERR_TOO_LARGE_SCALED_AMOUNT\n        );\n        return uint64(scaledAmount);\n    }\n\n    /// Private functions follow\n\n    // Note: implementation accepts 0..255 values for nonZeroScale\n    // It is responsibility of the caller check it is indeed less than 255 since 10^255 overflows uint256\n    // This overflow check not implemented here since caller will implement it in upper level\n    function _getScalingFactor(uint8 nonZeroScale)\n        private\n        pure\n        returns (uint256)\n    {\n        return 10**nonZeroScale;\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\nimport { ERR_TOO_LARGE_PUBKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract CommitmentGenerator {\n    /// Generate UTXOs, these UTXOs will be used later\n    /// @param pubSpendingKeyX Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param pubSpendingKeyY Public Spending Key for every UTXO - 256 bit - used in circom\n    /// @param scaledAmount 64 bit size - used in circom\n    /// @param zAssetId 160 bit size - used in circom\n    /// @param creationTime 32 bit size - used in circom\n    function generateCommitment(\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyX,\n        // slither-disable-next-line similar-names\n        uint256 pubSpendingKeyY,\n        uint64 scaledAmount,\n        uint160 zAssetId,\n        uint32 creationTime\n    ) internal pure returns (bytes32 commitment) {\n        require(\n            pubSpendingKeyX <= FIELD_SIZE && pubSpendingKeyY <= FIELD_SIZE,\n            ERR_TOO_LARGE_PUBKEY\n        );\n        // Being 160 bits and less, other input params can't exceed FIELD_SIZE\n        commitment = PoseidonT4.poseidon(\n            [\n                bytes32(pubSpendingKeyX),\n                bytes32(pubSpendingKeyY),\n                bytes32(\n                    (uint256(scaledAmount) << 192) |\n                        (uint256(zAssetId) << 32) |\n                        uint256(creationTime)\n                )\n            ]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/CommitmentsTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\nimport { OUT_MAX_UTXOs } from \"../../common/Constants.sol\";\nimport { ERR_TOO_LARGE_COMMITMENTS } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\n/**\n * @title CommitmentsTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees of commitments for the `PantherPool` contract\n */\nabstract contract CommitmentsTrees is TriadIncrementalMerkleTrees {\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * @notice Adds commitments to merkle tree(s) and emits events\n     * @param commitments Commitments (leaves hashes) to be inserted into merkle tree(s)\n     * @param msgTypes Types (i.e. formats) of the perUtxoData array elements\n     * @param perUtxoData opening values (encrypted and public) for every UTXO\n     * @return leftLeafId The `leafId` of the first leaf in the batch\n     */\n    function addAndEmitCommitments(\n        bytes32[OUT_MAX_UTXOs] memory commitments,\n        uint8 msgTypes,\n        bytes[OUT_MAX_UTXOs] memory perUtxoData,\n        uint256 timestamp\n    ) internal returns (uint256 leftLeafId) {\n        bytes memory utxoData = abi.encodePacked(msgTypes);\n\n        for (uint256 i = 0; i < OUT_MAX_UTXOs; i++) {\n            require(\n                uint256(commitments[i]) < FIELD_SIZE,\n                ERR_TOO_LARGE_COMMITMENTS\n            );\n            utxoData = bytes.concat(utxoData, perUtxoData[i]);\n        }\n\n        // Insert hashes into Merkle tree(s)\n        leftLeafId = insertBatch(commitments);\n\n        emit NewCommitments(leftLeafId, timestamp, commitments, utxoData);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/pantherPool/MerkleProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\nimport \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../triadTree/TriadIncrementalMerkleTrees.sol\";\n\nabstract contract MerkleProofVerifier {\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 private constant TREE_DEPTH = 15;\n\n    //t |bH  bL| Subtree\n    //--|------|------------\n    //0 | 0  0 | hash(C,L,R)\n    //1 | 0  1 | hash(L,C,R)\n    //2 | 1  0 | hash(L,R,C)\n    //3 | 1  1 | Not allowed\n    //--|------|------------\n    // Current leaf index in triad is (C,L,R)\n    uint256 private constant iTRIAD_INDEX_LEFT = 0x0;\n    // Current leaf index in triad is (L,C,R)\n    uint256 private constant iTRIAD_INDEX_MIDDLE = 0x1;\n    // Current leaf index in triad is (L,R,C)\n    uint256 private constant iTRIAD_INDEX_RIGHT = 0x2;\n    // Forbidden triad value in tria is `11`\n    uint256 private constant iTRIAD_INDEX_FORBIDDEN = 0x3;\n\n    /// @param merkleRoot - verify checked to this hash\n    /// @param triadIndex - index inside triad = { 0, 1, 2 }\n    /// @param triadNodeIndex - index of triad hash ( c0,c1,c2 ) in the tree - Triad contract insures its is in range\n    /// @param leaf - commitment leaf value\n    /// @param pathElements - TREE_DEPTH + 1 elements - c1,c2 & path-elements\n    /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n    /// @dev defined by `root`. For this, a `proof` must be provided, containing\n    /// @dev sibling hashes on the branch from the leaf to the root of the tree.\n    function verifyMerkleProof(\n        bytes32 merkleRoot,\n        uint256 triadIndex,\n        uint256 triadNodeIndex,\n        bytes32 leaf,\n        bytes32[TREE_DEPTH + 1] calldata pathElements\n    ) internal pure {\n        // [0] - Assumed it is computed by the TriadIncrementalMerkleTrees\n        //       using modulo operation, so no need to check lower range\n        //require(iTRIAD_INDEX_LEFT <= triadIndex, ERR_TRIAD_INDEX_MIN_VALUE);\n        require(triadIndex < iTRIAD_INDEX_FORBIDDEN, ERR_TRIAD_INDEX_MAX_VALUE);\n\n        // [1] - Compute zero level hash\n        // variable will be initialized inside the 'if' bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32 nodeHash;\n        // NOTE: no else-case needed since this code executed after require at step [0]\n        if (triadIndex == iTRIAD_INDEX_LEFT) {\n            nodeHash = PoseidonT4.poseidon(\n                [leaf, pathElements[0], pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_MIDDLE) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], leaf, pathElements[1]]\n            );\n        } else if (triadIndex == iTRIAD_INDEX_RIGHT) {\n            nodeHash = PoseidonT4.poseidon(\n                [pathElements[0], pathElements[1], leaf]\n            );\n        }\n\n        // [2] - Compute root\n        for (uint256 level = 2; level < pathElements.length; level++) {\n            bool isLeftNode;\n            unchecked {\n                // triadNodeIndex is actually a path to triad-node in merkle-tree\n                // each LSB bit of this number is left or right path\n                // it means for example: path = b111 , zero leaf will be from right size of hash\n                // and path element[2] will be from right side of hash, all other path elements [3,4] will be from\n                // left side of the next hashes till root.\n                isLeftNode = ((triadNodeIndex & (0x1 << (level - 2))) == 0);\n            }\n            if (isLeftNode) {\n                // computed node from left side\n                // Hash(left = nodeHash, right = pathElement)\n                nodeHash = PoseidonT3.poseidon([nodeHash, pathElements[level]]);\n            } else {\n                // computed node from right side\n                // Hash(left = pathElement, right = nodeHash)\n                nodeHash = PoseidonT3.poseidon([pathElements[level], nodeHash]);\n            }\n        }\n        // [3] - revert if verification fails\n        require(merkleRoot == nodeHash, ERR_MERKLE_PROOF_VERIFICATION_FAILED);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/NullifierGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3 } from \"../crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport { ERR_TOO_LARGE_LEAFID, ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\n\nabstract contract NullifierGenerator {\n    function generateNullifier(uint256 privSpendingKey, uint256 leafId)\n        internal\n        pure\n        returns (bytes32 nullifier)\n    {\n        require(privSpendingKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        require(leafId < FIELD_SIZE, ERR_TOO_LARGE_LEAFID);\n        nullifier = PoseidonT3.poseidon(\n            [bytes32(privSpendingKey), bytes32(leafId)]\n        );\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/PubKeyGenerator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { ERR_TOO_LARGE_PRIVKEY } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\nimport \"../crypto/BabyJubJub.sol\";\n\nabstract contract PubKeyGenerator {\n    function generatePubSpendingKey(uint256 privKey)\n        internal\n        view\n        returns (G1Point memory pubKey)\n    {\n        // [0] - Require\n        require(privKey < FIELD_SIZE, ERR_TOO_LARGE_PRIVKEY);\n        // [1] - Generate public key\n        G1Point memory base8 = G1Point({\n            x: BabyJubJub.BASE8_X,\n            y: BabyJubJub.BASE8_Y\n        });\n        pubKey = BabyJubJub.mulPointEscalar(base8, privKey);\n    }\n}\n"
    },
    "contracts/protocol/PantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../common/Constants.sol\";\nimport \"./errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/Utils.sol\";\nimport \"./interfaces/IPrpGrantor.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\nimport \"../common/Claimable.sol\";\nimport \"./pantherPool/AmountConvertor.sol\";\nimport \"./pantherPool/CommitmentGenerator.sol\";\nimport \"./pantherPool/CommitmentsTrees.sol\";\nimport \"./pantherPool/MerkleProofVerifier.sol\";\nimport \"./pantherPool/NullifierGenerator.sol\";\nimport \"./pantherPool/PubKeyGenerator.sol\";\n\n/**\n * @title PantherPool\n * @author Pantherprotocol Contributors\n * @notice Multi-Asset Shielded Pool main contract v0\n * @dev It is the \"version 0\" of the Panther Protocol Multi-Asset Shielded Pool (\"MASP\").\n * It locks assets (ERC-20, ERC-721 or ERC-1155 tokens) of a user with the `Vault` smart\n * contract and generates UTXO's in the MASP for the user (i.e. builds merkle trees of\n * UTXO's commitments).\n * This contract does not implement the functionality for spending UTXO's (other than the\n * `exit` described further) and is supposed to be upgraded with the new one.\n * The new contract, the \"v.1\" of the MASP, is planned to implement spending of UTXO's\n * using zero-knowledge proves.\n * To be upgradable, this contract is assumed to run as an \"implementation\" for a proxy\n * that DELEGATECALL's the implementation.\n * To protect holders against lost of assets in case this contract is not upgraded, it\n * exposes the `exit` function, through which users may withdraw their locked assets via\n * revealing preimages of commitments.\n */\ncontract PantherPoolV0 is\n    ImmutableOwnable,\n    NonReentrant,\n    Claimable,\n    CommitmentsTrees,\n    AmountConvertor,\n    CommitmentGenerator,\n    MerkleProofVerifier,\n    NullifierGenerator,\n    PubKeyGenerator,\n    Utils\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Address of the ZAssetRegistry contract\n    address public immutable ASSET_REGISTRY;\n\n    /// @notice Address of the Vault contract\n    address public immutable VAULT;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice (UNIX) Time since when the `exit` calls get enabled\n    uint32 public exitTime;\n\n    /// @notice Period (seconds) since `commitToExit` when `exit` opens\n    // Needed to mitigate front-run attacks on `exit`\n    uint24 public exitDelay;\n\n    // (rest of the storage slot) reserved for upgrades\n    // slither-disable-next-line unused-state,constable-states\n    uint200 private _reserved;\n\n    // @notice Seen (i.e. spent) commitment nullifiers\n    // nullifier hash => spent\n    mapping(bytes32 => bool) public isSpent;\n\n    /// @notice Unused registered commitments to exit\n    // hash(privSpendKey, recipient) => commitment timestamp\n    mapping(bytes32 => uint32) public exitCommitments;\n\n    /// @dev Emitted when exit time and/or exit delay updated\n    event ExitTimesUpdated(uint256 newExitTime, uint256 newExitDelay);\n\n    /// @dev New nullifier has been seen\n    event Nullifier(bytes32 nullifier);\n\n    /// @dev A tiny disowned token amount gets locked in the Vault\n    /// (as a result of imprecise scaling of deposited amounts)\n    event Change(address indexed token, uint256 change);\n\n    /// @dev New exit commitment registered\n    event ExitCommitment(uint256 timestamp);\n\n    /// @param _owner Address of the `OWNER` who may call `onlyOwner` methods\n    /// @param assetRegistry Address of the ZAssetRegistry contract\n    /// @param vault Address of the Vault contract\n    constructor(\n        address _owner,\n        address assetRegistry,\n        address vault\n    ) ImmutableOwnable(_owner) {\n        require(TRIAD_SIZE == OUT_UTXOs, \"E0\");\n\n        revertZeroAddress(assetRegistry);\n        revertZeroAddress(vault);\n\n        // As it runs behind the DELEGATECALL'ing proxy, initialization of\n        // immutable \"vars\" only is allowed in the constructor\n\n        ASSET_REGISTRY = assetRegistry;\n        VAULT = vault;\n    }\n\n    /// @notice Update the exit time and the exit delay\n    /// @dev Owner only may calls\n    function updateExitTimes(uint32 newExitTime, uint24 newExitDelay)\n        external\n        onlyOwner\n    {\n        require(\n            newExitTime >= exitTime &&\n                newExitTime < MAX_TIMESTAMP &&\n                newExitDelay != 0,\n            \"E1\"\n        );\n\n        exitTime = newExitTime;\n        exitDelay = newExitDelay;\n\n        emit ExitTimesUpdated(uint256(newExitTime), uint256(newExitDelay));\n    }\n\n    /// @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n    /// @param tokens Address of the token contract for every UTXO\n    /// @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n    /// @param amounts Token amounts (unscaled) to be deposited\n    /// @param pubSpendingKeys Public Spending Key for every UTXO\n    /// @param secrets Encrypted opening values for every UTXO\n    /// @param createdAt Optional, if 0 the network time used\n    /// @dev createdAt must be less (or equal) the network time\n    /// @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata amounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external nonReentrant returns (uint256 leftLeafId) {\n        require(exitTime > 0, ERR_UNCONFIGURED_EXIT_TIME);\n\n        uint32 timestamp = safe32TimeNow();\n        if (createdAt != 0) {\n            // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n            // slither-disable-next-line timestamp\n            require(createdAt <= timestamp, ERR_TOO_EARLY_CREATED_AT);\n            timestamp = createdAt;\n        }\n\n        // variables get initialized inside the loop bellow\n        // slither-disable-next-line uninitialized-local\n        bytes32[OUT_MAX_UTXOs] memory commitments;\n        // slither-disable-next-line uninitialized-local\n        bytes[OUT_MAX_UTXOs] memory perUtxoData;\n\n        // Types of UTXO data messages packed into one byte\n        uint8 msgTypes = uint8(0);\n\n        for (uint256 utxoIndex = 0; utxoIndex < OUT_MAX_UTXOs; utxoIndex++) {\n            // The next call can't trigger the \"calls loop\" since it triggers\n            // external calls to known contracts, which are trusted to handle\n            // reentrancy risk properly.\n            // Slither's \"disable calls-loop detector\" directives are inserted\n            // in lines (bellow) with external calls rather than here only (as\n            // otherwise slither reports false-positive issues).\n            (uint160 zAssetId, uint64 scaledAmount) = _processDepositedAsset(\n                tokens[utxoIndex],\n                tokenIds[utxoIndex],\n                amounts[utxoIndex]\n            );\n\n            if (utxoIndex != 0) msgTypes = msgTypes << 2;\n\n            if (scaledAmount == 0) {\n                // the zero UTXO\n                // At least the 1st deposited amount shall be non-zero\n                require(utxoIndex != 0, ERR_ZERO_DEPOSIT);\n\n                commitments[utxoIndex] = ZERO_VALUE;\n                perUtxoData[utxoIndex] = \"\";\n                // As UTXO_DATA_TYPE5 is 0, next statement may be skipped\n                // msgTypes |= UTXO_DATA_TYPE5;\n            } else {\n                // non-zero UTXO\n                commitments[utxoIndex] = generateCommitment(\n                    pubSpendingKeys[utxoIndex].x,\n                    pubSpendingKeys[utxoIndex].y,\n                    scaledAmount,\n                    zAssetId,\n                    timestamp\n                );\n\n                uint256 zAssetIdAndAmount = (uint256(zAssetId) << 96) |\n                    uint256(scaledAmount);\n\n                if (tokenIds[utxoIndex] != 0) {\n                    msgTypes |= UTXO_DATA_TYPE1;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount\n                    );\n                } else {\n                    msgTypes |= UTXO_DATA_TYPE3;\n                    perUtxoData[utxoIndex] = abi.encodePacked(\n                        secrets[utxoIndex],\n                        zAssetIdAndAmount,\n                        tokenIds[utxoIndex]\n                    );\n                }\n            }\n        }\n\n        leftLeafId = addAndEmitCommitments(\n            commitments,\n            msgTypes,\n            perUtxoData,\n            timestamp\n        );\n    }\n\n    /// @notice Register future `exit` to protect against front-run and DoS.\n    /// The `exit` is possible only after `exitDelay` since this function call.\n    /// @param exitCommitment Commitment to the UTXO spending key and the recipient address.\n    /// MUST be equal to keccak256(abi.encode(uint256(privSpendingKey), address(recipient)).\n    function commitToExit(bytes32 exitCommitment) external {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line incorrect-equality,timestamp\n        require(\n            exitCommitments[exitCommitment] == uint32(0),\n            ERR_EXITCOMMIT_EXISTS\n        );\n        uint32 timestamp = safe32TimeNow();\n        exitCommitments[exitCommitment] = timestamp;\n        emit ExitCommitment(timestamp);\n    }\n\n    /// @notice Spend an UTXO in the MASP and withdraw the asset from the Vault to the msg.sender.\n    /// This function call must be registered in advance with `commitToExit`.\n    /// @param token Address of the token contract\n    /// @param subId '_tokenId'/'_id' for ERC-721/1155, 0 for the \"default\" zAsset of an ERC-20 token,\n    // or `subId` for an \"alternative\" zAsset of an ERC-20 (see ZAssetRegistry.sol for details)\n    /// @param scaledAmount Token scaled amount\n    /// @param privSpendingKey UTXO's Private Spending Key\n    /// @param leafId Id of the leaf with the UTXO commitments in the Merkle Trees\n    /// @param pathElements Elements of the Merkle proof of inclusion\n    /// @param merkleRoot The root of the Merkle Tree the leaf is a part of\n    /// @param cacheIndexHint Index of the `merkleRoot` in the cache of roots, 0 by default\n    /// @dev `cacheIndexHint` needed for the \"current\" (partially populated) tree only\n    function exit(\n        address token,\n        uint256 subId,\n        uint64 scaledAmount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[TREE_DEPTH + 1] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external nonReentrant {\n        // if exitTime == 0 -> `exit` is not accepted since init phase is not finished yet\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            safe32TimeNow() >= exitTime && exitTime != 0,\n            ERR_TOO_EARLY_EXIT\n        );\n        _verifyExitCommitment(privSpendingKey, msg.sender);\n\n        {\n            bytes32 nullifier = generateNullifier(privSpendingKey, leafId);\n            require(!isSpent[nullifier], ERR_SPENT_NULLIFIER);\n            isSpent[nullifier] = true;\n            emit Nullifier(nullifier);\n        }\n        require(\n            isKnownRoot(getTreeId(leafId), merkleRoot, cacheIndexHint),\n            ERR_UNKNOWN_MERKLE_ROOT\n        );\n\n        ZAsset memory asset;\n        uint256 _tokenId;\n        {\n            bytes32 commitment;\n            {\n                uint160 zAssetId;\n                {\n                    (zAssetId, _tokenId, , asset) = IZAssetsRegistry(\n                        ASSET_REGISTRY\n                    ).getZAssetAndIds(token, subId);\n                    require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n                }\n                G1Point memory pubSpendingKey = generatePubSpendingKey(\n                    privSpendingKey\n                );\n                commitment = generateCommitment(\n                    pubSpendingKey.x,\n                    pubSpendingKey.y,\n                    scaledAmount,\n                    zAssetId,\n                    creationTime\n                );\n            }\n            verifyMerkleProof(\n                merkleRoot,\n                _getTriadIndex(leafId),\n                _getTriadNodeIndex(leafId),\n                commitment,\n                pathElements\n            );\n        }\n\n        uint96 amount = _unscaleAmount(scaledAmount, asset.scale);\n        IVault(VAULT).unlockAsset(\n            LockData(asset.tokenType, token, _tokenId, msg.sender, amount)\n        );\n    }\n\n    /// @notice Withdraw accidentally sent tokens or ETH from this contract\n    /// @dev The \"owner\" may call only\n    function claimEthOrErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        _claimEthOrErc20(token, to, amount);\n    }\n\n    /// Internal and private functions follow\n\n    // Declared `internal` rather than `private` to ease testing\n    function _processDepositedAsset(\n        address token,\n        uint256 subId,\n        uint256 amount\n    ) internal returns (uint160 zAssetId, uint64 scaledAmount) {\n        // Do nothing if it's the \"zero\" (or \"dummy\") deposit\n        if (amount == 0) {\n            // Both token and subId must be zeros for the \"zero\" deposit\n            require(token == address(0) && subId == 0, ERR_WRONG_DEPOSIT);\n            return (0, 0);\n        }\n        // amount can't be zero here and further\n\n        // At this point, a non-zero deposit of a real asset (token) expected\n        uint256 _tokenId;\n        ZAsset memory asset;\n\n        // Note comments on \"calls-loop\" in `function generateDeposits`\n        // slither-disable-next-line calls-loop\n        (zAssetId, _tokenId, , asset) = IZAssetsRegistry(ASSET_REGISTRY)\n            .getZAssetAndIds(token, subId);\n        require(asset.status == zASSET_ENABLED, ERR_WRONG_ASSET);\n\n        // Scale amount, if asset.scale provides for it (ERC-20 only)\n        uint256 change;\n        (scaledAmount, change) = _scaleAmount(amount, asset.scale);\n\n        // The `change` will remain locked in the Vault until it's claimed\n        // (when and if future upgrades implement change claiming)\n        if (change > 0) emit Change(token, change);\n\n        // slither-disable-next-line calls-loop\n        IVault(VAULT).lockAsset(\n            LockData(\n                asset.tokenType,\n                asset.token,\n                _tokenId,\n                msg.sender,\n                uint96(amount)\n            )\n        );\n\n        return (zAssetId, scaledAmount);\n    }\n\n    function _verifyExitCommitment(uint256 privSpendingKey, address recipient)\n        internal\n    {\n        bytes32 commitment = keccak256(abi.encode(privSpendingKey, recipient));\n\n        uint32 commitmentTime = exitCommitments[commitment];\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(commitmentTime != uint32(0), ERR_EXITCOMMIT_MISSING);\n\n        uint256 allowedTime = uint256(commitmentTime) + uint256(exitDelay);\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(timeNow() > allowedTime, ERR_EXITCOMMIT_LOCKED);\n\n        // Let's gain some gas back\n        exitCommitments[commitment] = uint32(0);\n        // No extra event emitted as spent UTXO and withdrawal events will fire\n    }\n}\n"
    },
    "contracts/protocol/triadTree/Hasher.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { PoseidonT3, PoseidonT4 } from \"../crypto/Poseidon.sol\";\n\n/*\n * @dev Poseidon hash functions\n */\nabstract contract Hasher {\n    function hash(bytes32 left, bytes32 right) internal pure returns (bytes32) {\n        bytes32[2] memory input;\n        input[0] = left;\n        input[1] = right;\n        return PoseidonT3.poseidon(input);\n    }\n\n    function hash(\n        bytes32 left,\n        bytes32 mid,\n        bytes32 right\n    ) internal pure returns (bytes32) {\n        bytes32[3] memory input;\n        input[0] = left;\n        input[1] = mid;\n        input[2] = right;\n        return PoseidonT4.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/triadTree/TriadIncrementalMerkleTrees.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./Hasher.sol\";\nimport \"./TriadMerkleZeros.sol\";\nimport { ERR_ZERO_ROOT } from \"../errMsgs/PantherPoolErrMsgs.sol\";\nimport \"../interfaces/IRootsHistory.sol\";\n\n/**\n * @title TriadIncrementalMerkleTrees\n * @author Pantherprotocol Contributors\n * @notice Incremental Merkle trees with batch insertion of 3 leaves at once\n * @dev Refer to {TriadMerkleZeros} for comments on \"triad trees\" used\n * Inspired by MACI project\n * https://github.com/appliedzkp/maci/blob/master/contracts/sol/IncrementalMerkleTree.sol\n */\ncontract TriadIncrementalMerkleTrees is\n    TriadMerkleZeros,\n    Hasher,\n    IRootsHistory\n{\n    /**\n     * @dev {treeId} is a consecutive number of trees, starting from 0.\n     * @dev {leafId} of a leaf is a \"modified\" number of leaves inserted in all\n     * tries before this leaf. It is unique across all trees, starts from 0 for\n     * the 1st leaf of the 1st tree, and constantly increments like this:\n     * 0,1,2,  4,5,6,  8,9,10,  12,13,14 ... (i.e. every 4th number is skipped)\n     * See comments to {TriadMerkleZeros}.\n     */\n\n    // `leafId` of the next leaf to insert\n    // !!! NEVER access it directly from child contracts: `internal` to ease testing only\n    uint256 internal _nextLeafId;\n\n    // Right-most elements (hashes) in the current tree per level\n    // level index => hash\n    mapping(uint256 => bytes32) private _filledSubtrees;\n\n    /// @notice Roots of fully populated trees\n    /// @dev treeId => root\n    mapping(uint256 => bytes32) public finalRoots;\n\n    // Recent roots of trees seen\n    // cacheIndex => root ^ treeId\n    mapping(uint256 => uint256) private _cachedRoots;\n\n    // @dev Root permanently added to the `finalRoots`\n    event AnchoredRoot(uint256 indexed treeId, bytes32 root);\n\n    // @dev Root temporarily saved in the `_cachedRoots`\n    event CachedRoot(uint256 indexed treeId, bytes32 root);\n\n    // NOTE: No `constructor` (initialization) function needed\n\n    // solhint-disable const-name-snakecase\n\n    // Max number of latest roots to cache (must be a power of 2)\n    uint256 internal constant CACHED_ROOTS_NUM = 256;\n\n    // Number of leaves in a modified triad used for leaf ID calculation\n    uint256 private constant iTRIAD_SIZE = 4;\n    // The number of leaves in a tree used for leaf ID calculation\n    uint256 private constant iLEAVES_NUM = 2**(TREE_DEPTH - 1) * iTRIAD_SIZE;\n\n    // Bitmasks and numbers of bits for \"cheaper\" arithmetics\n    uint256 private constant iTRIAD_SIZE_MASK = iTRIAD_SIZE - 1;\n    uint256 private constant iTRIAD_SIZE_BITS = 2;\n    uint256 private constant iLEAVES_NUM_MASK = iLEAVES_NUM - 1;\n    uint256 private constant iLEAVES_NUM_BITS =\n        TREE_DEPTH - 1 + iTRIAD_SIZE_BITS;\n    uint256 private constant CACHE_SIZE_MASK =\n        CACHED_ROOTS_NUM * iTRIAD_SIZE - 1;\n\n    // solhint-enable const-name-snakecase\n\n    /**\n     * @notice Returns the number of leaves inserted in all trees so far\n     */\n    function leavesNum() external view returns (uint256) {\n        return _nextLeafId2LeavesNum(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the current tree\n     */\n    function curTree() external view returns (uint256) {\n        return getTreeId(_nextLeafId);\n    }\n\n    /**\n     * @notice Returns `treeId` of the given leaf's tree\n     */\n    function getTreeId(uint256 leafId) public pure returns (uint256) {\n        // equivalent to `leafId / iLEAVES_NUM`\n        return leafId >> iLEAVES_NUM_BITS;\n    }\n\n    /**\n     * @notice Returns `leafIndex` (index in the tree) of the given leaf\n     */\n    function getLeafIndex(uint256 leafId) public pure returns (uint256) {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return iIndex - fullTriadsNum; // start index of first leaf in the triad\n        }\n    }\n\n    /**\n     * @notice Returns the root of the current tree and its index in cache\n     */\n    function curRoot()\n        external\n        view\n        returns (bytes32 root, uint256 cacheIndex)\n    {\n        // Return zero root and index if the current tree is empty\n        uint256 nextLeafId = _nextLeafId;\n        if (_isEmptyTree(nextLeafId)) return (ZERO_ROOT, 0);\n\n        // Return cached values otherwise\n        uint256 treeId = getTreeId(nextLeafId);\n        cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n        uint256 v = _cachedRoots[cacheIndex];\n        root = bytes32(v ^ treeId);\n    }\n\n    /// @inheritdoc IRootsHistory\n    function isKnownRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndexHint\n    ) public view override returns (bool) {\n        require(root != 0, ERR_ZERO_ROOT);\n\n        // if hint provided, use hint\n        if (cacheIndexHint != 0)\n            return _isCorrectCachedRoot(treeId, root, cacheIndexHint);\n\n        // then, check the history\n        if (finalRoots[treeId] == root) return true;\n\n        // finally, look in cache, starting from the current root\n        uint256 leafId = _nextLeafId;\n        unchecked {\n            uint256 i = CACHED_ROOTS_NUM;\n            while ((leafId >= iTRIAD_SIZE) && (i != 0)) {\n                i -= 1;\n                // Skip the last triad in a tree (i.e. the full tree root)\n                if (leafId & iLEAVES_NUM_MASK == 0) continue;\n                uint256 cacheIndex = _nextLeafId2CacheIndex(leafId);\n                if (_isCorrectCachedRoot(treeId, root, cacheIndex)) return true;\n                leafId -= iTRIAD_SIZE;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @dev Inserts 3 leaves into the current tree, or a new one, if that's full\n     * @param leaves The 3 leaves to insert (must be less than SNARK_SCALAR_FIELD)\n     * @return leftLeafId The `leafId` of the first leaf from 3 inserted\n     */\n    function insertBatch(bytes32[TRIAD_SIZE] memory leaves)\n        internal\n        returns (uint256 leftLeafId)\n    {\n        leftLeafId = _nextLeafId;\n\n        // here the variable is intentionally declared only ...\n        // slither-disable-next-line uninitialized-local\n        bytes32[TREE_DEPTH] memory zeros;\n        // ... and initialized in this call\n        populateZeros(zeros);\n\n        // index of a \"current\" node (0 for the leftmost node/leaf of a level)\n        uint256 nodeIndex;\n        // hash (value) of a \"current\" node\n        bytes32 nodeHash;\n        // index of a \"current\" level (0 for leaves, increments toward root)\n        uint256 level;\n\n        // subtree from 3 leaves being inserted on `level = 0`\n        nodeHash = hash(leaves[0], leaves[1], leaves[2]);\n        // ... to be placed under this index on `level = 1`\n        // (equivalent to `(leftLeafId % iLEAVES_NUM) / iTRIAD_SIZE`)\n        nodeIndex = (leftLeafId & iLEAVES_NUM_MASK) >> iTRIAD_SIZE_BITS;\n\n        bytes32 left;\n        bytes32 right;\n        for (level = 1; level < TREE_DEPTH; level++) {\n            // if `nodeIndex` is, say, 25, over the iterations it will be:\n            // 25, 12, 6, 3, 1, 0, 0 ...\n\n            if (nodeIndex % 2 == 0) {\n                left = nodeHash;\n                right = zeros[level];\n                _filledSubtrees[level] = nodeHash;\n            } else {\n                // for a new tree, \"than\" block always run before \"else\" block\n                // so `_filledSubtrees[level]` gets updated before its use\n                left = _filledSubtrees[level];\n                right = nodeHash;\n            }\n\n            nodeHash = hash(left, right);\n\n            // equivalent to `nodeIndex /= 2`\n            nodeIndex >>= 1;\n        }\n\n        uint256 nextLeafId = leftLeafId + iTRIAD_SIZE;\n        _nextLeafId = nextLeafId;\n\n        uint256 treeId = getTreeId(leftLeafId);\n        if (_isFullTree(leftLeafId)) {\n            // Switch to a new tree\n            // Ignore `_filledSubtrees` old values as they are never re-used\n            finalRoots[treeId] = nodeHash;\n            emit AnchoredRoot(treeId, nodeHash);\n        } else {\n            uint256 cacheIndex = _nextLeafId2CacheIndex(nextLeafId);\n            _cachedRoots[cacheIndex] = uint256(nodeHash) ^ treeId;\n            emit CachedRoot(treeId, nodeHash);\n        }\n    }\n\n    /// private functions follow (some of them made `internal` to ease testing)\n    function _isFullTree(uint256 leftLeafId) internal pure returns (bool) {\n        unchecked {\n            return\n                (iLEAVES_NUM - (leftLeafId & iLEAVES_NUM_MASK)) <= iTRIAD_SIZE;\n        }\n    }\n\n    function _isEmptyTree(uint256 nextLeafId) internal pure returns (bool) {\n        return (nextLeafId & iLEAVES_NUM_MASK) == 0;\n    }\n\n    function _nextLeafId2LeavesNum(\n        uint256 nextLeafId // declared as `internal` to facilitate testing\n    ) internal pure returns (uint256) {\n        // equiv to `nextLeafId / iTRIAD_SIZE * TRIAD_SIZE + nextLeafId % iTRIAD_SIZE`\n        unchecked {\n            return\n                (nextLeafId >> iTRIAD_SIZE_BITS) *\n                TRIAD_SIZE +\n                (nextLeafId & iTRIAD_SIZE_MASK);\n        }\n    }\n\n    // Returns `triadIndex` index in the triad-node of the given leaf = { 0, 1, 2 }\n    function _getTriadIndex(uint256 leafId) internal pure returns (uint256) {\n        return getLeafIndex(leafId) % TRIAD_SIZE;\n    }\n\n    // Returns `triadNodeIndex` index of the triad-node of the given leaf\n    // This index is the path to this node - used by anyone who needs the path\n    function _getTriadNodeIndex(uint256 leafId)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            // equiv to `leafId % LEAVES_NUM`\n            uint256 iIndex = leafId & iLEAVES_NUM_MASK; // throws away tree-id bits\n            uint256 fullTriadsNum = (iIndex + 1) >> iTRIAD_SIZE_BITS; // computes index of triad node in the tree\n            return fullTriadsNum;\n        }\n    }\n\n    // nextLeafId must be even\n    function _nextLeafId2CacheIndex(uint256 nextLeafId)\n        private\n        pure\n        returns (uint256)\n    {\n        // equiv to `nextLeafId % (CACHED_ROOTS_NUM * iTRIAD_SIZE) + 1`\n        return (nextLeafId & CACHE_SIZE_MASK) | 1;\n    }\n\n    function _isCorrectCachedRoot(\n        uint256 treeId,\n        bytes32 root,\n        uint256 cacheIndex\n    ) private view returns (bool) {\n        uint256 v = _cachedRoots[cacheIndex];\n        return v == (uint256(root) ^ treeId);\n    }\n\n    // NOTE: The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // For compatibility on upgrades, decrease `__gap` if new variables added.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/protocol/triadTree/TriadMerkleZeros.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\n// Content is autogenerated by `lib/triadMerkleZerosContractGenerator.ts`\n\n/**\n * @dev The \"triad binary tree\" is a modified Merkle (full) binary tree with:\n * - every node, from the root upto the level preceding leaves, excluding\n * that level, has 2 child nodes (i.e. this subtree is a full binary tree);\n * - every node of the layer preceding leaves has 3 child nodes (3 leaves).\n * Example:\n * [4]                                       0\n *                                           |\n * [3]                        0--------------------------------1\n *                            |                                |\n * [2]                0---------------1                 2--------------3\n *                    |               |                 |              |\n * [1]            0-------1       2-------3        4-------5       6-------7\n *               /|\\     /|\\     /|\\     /|\\      /|\\     /|\\     /|\\     /|\\\n * [0] index:   0..2    3..5    6..8    9...11  12..14  15..17  18..20  21..24\n *\n *   leaf ID:   0..2    4..6    8..10   12..14  16..18  20..23  24..27  28..30\n *\n * - Number in [] is the \"level index\" that starts from 0 for the leaves level.\n * - Numbers in node/leaf positions are \"node/leaf indices\" which starts from 0\n *   for the leftmost node/leaf of every level.\n * - Numbers bellow leaves are IDs of leaves.\n *\n * Arithmetic operations with multiples of 2 (i.e. shifting) is \"cheaper\" than\n * operations with multiples of 3 (both on-chain and in zk-circuits).\n * Therefore, IDs of leaves (but NOT hashes of nodes) are calculated as if the\n * tree would have 4 (not 3) leaves in branches, with every 4th leaf skipped.\n * In other words, there are no leaves with IDs 3, 7, 11, 15, 19...\n */\n\n// @notice The \"triad binary tree\" populated with zero leaf values\nabstract contract TriadMerkleZeros {\n    // solhint-disable var-name-mixedcase\n\n    // @dev Number of levels in a tree excluding the root level\n    // (also defined in scripts/generateTriadMerkleZeroesContracts.sh)\n    uint256 internal constant TREE_DEPTH = 15;\n\n    // Number of leaves in a branch with the root on the level 1\n    uint256 internal constant TRIAD_SIZE = 3;\n\n    // @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n    bytes32 internal constant ZERO_VALUE =\n        bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n\n    // Merkle root of a tree that contains zeros only\n    bytes32 internal constant ZERO_ROOT =\n        bytes32(\n            uint256(\n                0x20fc043586a9fcb416cdf2a3bc8a995f8f815d43f1046a20d1c588cf20482a55\n            )\n        );\n\n    // solhint-enable var-name-mixedcase\n\n    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {\n        zeros[0] = bytes32(\n            uint256(\n                0x667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d\n            )\n        );\n        zeros[1] = bytes32(\n            uint256(\n                0x1be18cd72ac1586de27dd60eba90654bd54383004991951bccb0f6bad02c67f6\n            )\n        );\n        zeros[2] = bytes32(\n            uint256(\n                0x7677e6102f0acf343edde864f79ef7652faa5a66d575b8b60bb826a4aa517e6\n            )\n        );\n        zeros[3] = bytes32(\n            uint256(\n                0x28a85866ab97bd65cc94b0d1f5c5986481f8a0d65bdd5c1e562659eebb13cf63\n            )\n        );\n        zeros[4] = bytes32(\n            uint256(\n                0x87321a66ea3af7780128ea1995d7fc6ec44a96a1b2d85d3021208cede68c15c\n            )\n        );\n        zeros[5] = bytes32(\n            uint256(\n                0x233b4e488f0aaf5faef4fc8ea4fefeadb6934eb882bc33b9df782fd1d83b41a0\n            )\n        );\n        zeros[6] = bytes32(\n            uint256(\n                0x1a0cefcf0c592da6426717d3718408c61af1d0a9492887f3faecefcba1a0a309\n            )\n        );\n        zeros[7] = bytes32(\n            uint256(\n                0x2cdf963150b321923dd07b2b52659aceb529516a537dfebe24106881dd974293\n            )\n        );\n        zeros[8] = bytes32(\n            uint256(\n                0x93a186bf9ec2cc874ceab26409d581579e1a431ecb6987d428777ceedfa15c4\n            )\n        );\n        zeros[9] = bytes32(\n            uint256(\n                0xcbfc07131ef4197a4b4e60153d43381520ec9ab4c9c3ed34d88883a881a4e07\n            )\n        );\n        zeros[10] = bytes32(\n            uint256(\n                0x17b31de43ba4c687cf950ad00dfbe33df40047e79245b50bd1d9f87e622bf2af\n            )\n        );\n        zeros[11] = bytes32(\n            uint256(\n                0x2f3328354bceaf5882a8cc88053e0dd0ae594009a4e84e9e75a4fefe8604a602\n            )\n        );\n        zeros[12] = bytes32(\n            uint256(\n                0x2b2e8defd4dad2404c6874918925fc1192123f45df0ee3e04b6c16ff22ca1cfd\n            )\n        );\n        zeros[13] = bytes32(\n            uint256(\n                0x1cbdc4065aa4137da01d64a090706267d65f425ea5e815673516d29d9aa14d38\n            )\n        );\n        zeros[14] = bytes32(\n            uint256(\n                0x13ca69f9fde4ece39e395bb55dd41ed7dd9dfaa26671e26bd9fd6f4f635fc872\n            )\n        );\n    }\n}\n"
    },
    "contracts/protocol/Vault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, ERC721_TOKEN_TYPE, ERC1155_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport \"./errMsgs/VaultErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/TransferHelper.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./vault/OnERC1155Received.sol\";\nimport \"./vault/OnERC721Received.sol\";\n\n/**\n * @title Vault\n * @author Pantherprotocol Contributors\n * @notice Holder of assets (tokens) for `PantherPool` contract\n * @dev It transfers assets from user to itself (Lock) and vice versa (Unlock).\n * `PantherPool` is assumed to be the `owner` that is authorized to trigger\n * locking/unlocking assets.\n */\ncontract Vault is\n    ImmutableOwnable,\n    OnERC721Received,\n    OnERC1155Received,\n    IVault\n{\n    using TransferHelper for address;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function lockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // Owner, who only may call this code, is trusted to protect\n            // against \"Arbitrary from in transferFrom\" vulnerability\n            // slither-disable-next-line arbitrary-send-erc20,reentrancy-benign,reentrancy-events\n            data.token.safeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.extAmount\n            );\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                data.extAccount,\n                address(this)\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                data.extAccount,\n                address(this),\n                data.tokenId,\n                uint256(data.extAmount),\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Locked(data);\n    }\n\n    // The caller (i.e. the owner) is supposed to apply reentrancy guard.\n    // If an adversarial \"token\", being called by this function, re-enters it\n    // directly, `onlyOwner` will revert as `msg.sender` won't be `owner`.\n    function unlockAsset(LockData calldata data)\n        external\n        override\n        onlyOwner\n        checkLockData(data)\n    {\n        if (data.tokenType == ERC20_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.safeTransfer(data.extAccount, data.extAmount);\n        } else if (data.tokenType == ERC721_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc721SafeTransferFrom(\n                data.tokenId,\n                address(this),\n                data.extAccount\n            );\n        } else if (data.tokenType == ERC1155_TOKEN_TYPE) {\n            // slither-disable-next-line reentrancy-benign,reentrancy-events\n            data.token.erc1155SafeTransferFrom(\n                address(this),\n                data.extAccount,\n                data.tokenId,\n                data.extAmount,\n                new bytes(0)\n            );\n        } else {\n            revert(ERR_INVALID_TOKEN_TYPE);\n        }\n\n        emit Unlocked(data);\n    }\n\n    modifier checkLockData(LockData calldata data) {\n        require(data.token != address(0), ERR_ZERO_LOCK_TOKEN_ADDR);\n        require(data.extAccount != address(0), ERR_ZERO_EXT_ACCOUNT_ADDR);\n        require(data.extAmount > 0, ERR_ZERO_EXT_AMOUNT);\n        _;\n    }\n}\n"
    },
    "contracts/protocol/vault/OnERC1155Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of ERC1155:onERC1155Received interface\nabstract contract OnERC1155Received {\n    // It accepts all tokens\n    function onERC1155Received(\n        address, /* operator */\n        address, /* from */\n        uint256, /* id */\n        uint256, /* value */\n        bytes calldata /* data */\n    ) external pure virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))\n        return 0xf23a6e61;\n    }\n}\n"
    },
    "contracts/protocol/vault/OnERC721Received.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Implementation of the ERC721TokenReceiver interface\nabstract contract OnERC721Received {\n    // It accepts all tokens\n    function onERC721Received(\n        address, // operator\n        address, // from\n        uint256, // tokenId\n        bytes memory // data\n    ) external virtual returns (bytes4) {\n        // bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n        return 0x150b7a02;\n    }\n}\n"
    },
    "contracts/protocol/ZAssetsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport { ERC20_TOKEN_TYPE, zASSET_ENABLED, zASSET_UNKNOWN } from \"../common/Constants.sol\";\nimport \"./errMsgs/ZAssetsRegistryErrMsgs.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport { ZAsset } from \"../common/Types.sol\";\nimport \"./interfaces/IZAssetsRegistry.sol\";\n\n/**\n * @title ZAssetsRegistry\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of assets (tokens) supported by the Panther\n * Protocol Multi-Asset Shielded Pool (aka \"MASP\")\n */\ncontract ZAssetsRegistry is ImmutableOwnable, IZAssetsRegistry {\n    /**\n    \"zAsset\" - abstraction of a token for representation in the MASP.\n    ZK-circuits \"treat\" each zAsset as a unique (independent) token.\n    `zAssetId` - ID of a zAsset.\n    Circuits \"know\" a token by its zAssetID rather than the token addresses or\n    its _tokenId/_id.\n    Each distinguishable token supported by the MASP must be represented by its\n    \"own\" zAsset. zAsset must never  \"represent\" two (or more) different tokens.\n    An ERC-721/ERC-1155 token, with its unique _tokenId/_id, must \"have\" its own\n    zAsset, different from zAssets of other tokens on the same contract.\n    An ERC-20 token should be represented by at least one zAsset (further\n    referred to as the \"default\" zAsset). A few other zAssets (aka \"alternative\"\n    zAssets) may exist for the same ERC-20 token, with each zAsset having a\n    different \"scaling factor\" (`ZAsset.scale`).\n\n    `ZAsset` - a record on the Registry with parameters of zAsset(s).\n    `zAssetRecId` - ID of a ZAsset record.\n    Not every zAsset has its \"own\" ZAsset record, but each ZAsset keeps params\n    of at least one zAsset. It groups all zAssets, which share the same token\n    contract and the \"scaling factor\".\n    There is just one ZAsset record for all zAssets representing tokens on an\n    ERC-721/1155 contract. Thus, for any such supported contract there must be\n    EXACTLY one ZAsset record on the Registry.\n    Every zAsset representing an ERC-20 token must have its own ZAsset record.\n    So, the Registry must have at LEAST one ZAsset (for the default zAsset) for\n    an ERC-20 contract. However, other ZAsset records (for alternative zAssets)\n    may exist for the same ERC-20 token.\n\n    `subId` - additional ID which, coupled with the token contract address, let\n    deterministically compute `zAssetId` and `zAssetRecId`.\n\n    This code is written with the following specs in mind:\n    - If at least one token on an ERC-721/ERC-1155 contract is whitelisted, any\n      token on the contract is implicitly whitelisted w/o further configuration\n    - Registry must have one ZAsset record only for all tokens of an ERC-721/\n      ERC-1155 contract\n    - ZAsset record of any zAsset, w/ exception of extremely rare cases, should\n      be obtained with just a single SLOAD\n    - Backward compatible upgrades should be able to implement ..\n    -- .. separate whitelists of zAssets allowed for deposits and withdrawals\n       (e.g. via extension of ZAsset.status)\n    -- .. blacklist for some tokens on a whitelisted ERC-721/ERC-1155 contract\n       (e.g. by extending ZAsset.tokenType and introducing a blacklist)\n    -- .. limits per a zAsset for max allowed amounts of deposits/withdrawals\n       (e.g. with \"alternative\" zAssets and re-defining ZAsset._unused)\n    */\n\n    uint8 private constant MAX_SCALE = 32; // min scale is 0\n    uint8 private constant NO_SCALING = 0;\n    uint256 private constant DEFAULT_VER = 0;\n\n    // Mapping from `zAssetRecId` to ZAsset (i.e. params of an zAsset)\n    mapping(uint160 => ZAsset) private _registry;\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _owner) ImmutableOwnable(_owner) {\n        // Proxy-friendly: no storage initialization\n    }\n\n    function getZAssetId(address token, uint256 subId)\n        public\n        pure\n        override\n        returns (uint160)\n    {\n        // Being uint160, it is surely less then the FIELD_SIZE\n        return\n            uint160(\n                uint256(\n                    keccak256(abi.encode(uint256(uint160(token)), subId))\n                ) >> 96\n            );\n    }\n\n    /// @notice Returns ZAsset record for the given record ID\n    function getZAsset(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (ZAsset memory asset)\n    {\n        asset = _registry[zAssetRecId];\n    }\n\n    /// @notice Returns zAsset IDs and ZAsset record for the given token\n    /// @param token Address of the token contract\n    /// @param subId Extra ID to identify zAsset (0 by default)\n    /// @dev For ERC-721/ERC-1155 token, `subId` is the _tokenId/_id. For  the\n    // \"default\" zAsset of an ERC-20 token it is 0. For an \"alternative\" zAsset\n    // it is the `defaultZAssetRecId XOR ver`, where `defaultZAssetRecId` is the\n    // `zAssetRecId` of the default zAsset for this token, and `ver` is a unique\n    // int in the range [1..31].\n    /// @return zAssetId\n    /// @return _tokenId ERC-721/1155 _tokenId/_id, if it's an NFT, or 0 for ERC-20\n    /// @return zAssetRecId ID of the ZAsset record\n    /// @return asset ZAsset record for the token\n    function getZAssetAndIds(address token, uint256 subId)\n        external\n        view\n        override\n        returns (\n            uint160 zAssetId,\n            uint256 _tokenId,\n            uint160 zAssetRecId,\n            ZAsset memory asset\n        )\n    {\n        require(token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n\n        // Gas optimized based on assumptions:\n        // - most often, this code is called for the default zAsset of ERC-20\n        // - if `ver` is in [1..MAX_SCALE], likely it's an alternative zAsset\n        _tokenId = subId;\n        if (subId != 0) {\n            // Risk of zAssetRecId collision attack (see further) ignored since\n            // `subId` variant space is small (less than MAX_SCALE of ~5 bits).\n            // Therefore `require(asset.token == token)` omitted here.\n\n            // For an \"alternative\" zAsset, `subId` must be none-zero...\n            uint256 ver = uint256(uint160(token)) ^ subId;\n            // ... and `ver` must be in [1..MAX_SCALE]\n            if (ver < MAX_SCALE && ver != DEFAULT_VER) {\n                // Likely, it's the alternative zAsset w/ `zAssetRecId = subId`\n                asset = _registry[uint160(subId)];\n\n                if (asset.version == uint8(ver)) {\n                    // Surely, it's the alternative zAsset of the ERC-20 token\n                    // as `.version` must be 0 for NFTs and default zAssets.\n                    // As `.version != 0`, `.status` can't be zASSET_UNKNOWN.\n                    // Check `asset.tokenType == ERC20_TOKEN_TYPE` is skipped\n                    // as the code registering ZAssets is assumed to ensure it.\n                    zAssetId = getZAssetId(token, subId);\n                    zAssetRecId = uint160(subId);\n                    _tokenId = DEFAULT_VER;\n                    return (zAssetId, _tokenId, zAssetRecId, asset);\n                }\n            }\n        }\n        // The zAsset can't be an alternative zAsset of an ERC-20 token here.\n        // It's either an NFT (`subId` is _tokenId), or the default zAsset of\n        // an ERC-20 token (`subId` is 0). In both cases `asset.version == 0`.\n\n        zAssetRecId = uint160(token); // same as `uint160(token) ^ 0`\n        asset = _registry[zAssetRecId];\n        if (asset.status == zASSET_UNKNOWN) {\n            // Unknown token - return zero IDs, and empty ZAsset\n            return (0, 0, 0, asset);\n        }\n\n        require(\n            // `subId` of an ERC-20 token's default zAsset must be 0\n            (subId == 0 || asset.tokenType != ERC20_TOKEN_TYPE) &&\n                // zAssetReqId collision attack protection:\n                // attacker may vary token id of a fake NFT to make zAssetReqId\n                // (i.e. `token ^ subId`) equal to zAssetReqId of another token\n                asset.token == token,\n            ERR_ZERO_SUBID_EXPECTED\n        );\n        zAssetId = getZAssetId(token, _tokenId);\n        return (zAssetId, _tokenId, zAssetRecId, asset);\n    }\n\n    function isZAssetWhitelisted(uint160 zAssetRecId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        ZAsset memory asset = _registry[zAssetRecId];\n        return asset.status == zASSET_ENABLED;\n    }\n\n    /// @notice Register with the MASP a new asset with given params\n    /// @param asset Params of the asset (including its `ZAsset.status`)\n    /// @dev The \"owner\" may call only\n    function addZAsset(ZAsset memory asset) external onlyOwner {\n        require(asset.token != address(0), ERR_ZERO_TOKEN_ADDRESS);\n        require(asset.status != zASSET_UNKNOWN, ERR_WRONG_ASSET_STATUS);\n        require(\n            // ERC-20 zAsset only may be \"alternative\" ones\n            asset.version == 0 ||\n                (asset.tokenType == ERC20_TOKEN_TYPE &&\n                    asset.version < MAX_SCALE),\n            ERR_WRONG_ASSET_VER\n        );\n        _checkScaleIsInRange(asset);\n\n        // note, `x ^ 0 == x`\n        uint160 zAssetRecId = uint160(asset.token) ^ uint160(asset.version);\n\n        ZAsset memory existingAsset = _registry[zAssetRecId];\n        require(\n            existingAsset.status == zASSET_UNKNOWN,\n            ERR_ASSET_ALREADY_REGISTERED\n        );\n        _registry[zAssetRecId] = asset;\n        emit AssetAdded(zAssetRecId, asset);\n    }\n\n    /// @notice Updates the status of the existing asset\n    /// @param zAssetRecId ID of the ZAsset record\n    /// @param newStatus Status to be set\n    /// @dev The \"owner\" may call only\n    function changeZAssetStatus(uint160 zAssetRecId, uint8 newStatus)\n        external\n        onlyOwner\n    {\n        require(_registry[zAssetRecId].token != address(0), ERR_UNKNOWN_ASSET);\n        uint8 oldStatus = _registry[zAssetRecId].status;\n        // New status value restrictions relaxed to allow for protocol updates.\n        require(\n            newStatus != zASSET_UNKNOWN && oldStatus != newStatus,\n            ERR_WRONG_ASSET_STATUS\n        );\n        _registry[zAssetRecId].status = newStatus;\n        emit AssetStatusChanged(zAssetRecId, newStatus, oldStatus);\n    }\n\n    function _checkScaleIsInRange(ZAsset memory asset) private pure {\n        // Valid range for ERC-20 is [0..31]\n        // Valid range for ERC-721/ERC-1155 is 0\n        require(\n            (asset.scale == NO_SCALING ||\n                ((asset.scale < MAX_SCALE) &&\n                    (asset.tokenType == ERC20_TOKEN_TYPE))),\n            ERR_WRONG_ASSET_SCALE\n        );\n    }\n}\n"
    },
    "contracts/staking/actions/AdvancedStakingDataDecoder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { CIPHERTEXT1_WORDS, OUT_RWRD_UTXOs, PUBKEY_WORDS } from \"../../common/Constants.sol\";\nimport { G1Point } from \"../../common/Types.sol\";\n\n/***\n * @title AdvancedStakingDataDecoder\n * @dev It decodes (unpack) `bytes data` of the 'STAKED' message for \"advanced staking\"\n */\nabstract contract AdvancedStakingDataDecoder {\n    // in bytes\n    uint256 private constant DATA_LENGTH =\n        OUT_RWRD_UTXOs * (PUBKEY_WORDS + CIPHERTEXT1_WORDS) * 32;\n    // in 32-byte memory slots\n    uint256 private constant NUM_DATA_SLOTS =\n        (DATA_LENGTH / 32) + ((DATA_LENGTH % 32) & 1);\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function unpackStakingData(bytes memory data)\n        internal\n        pure\n        returns (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        )\n    {\n        require(data.length == DATA_LENGTH, \"SMP: unexpected msg length\");\n\n        // Let's read bytes as uint256 values\n        uint256[NUM_DATA_SLOTS + 1] memory words;\n        // the 1st slot is `data.length`, then slots with values follow\n        for (uint256 i = 1; i <= NUM_DATA_SLOTS; ++i) {\n            // solhint-disable no-inline-assembly\n            // slither-disable-next-line assembly\n            assembly {\n                let offset := mul(i, 0x20)\n                let word := mload(add(data, offset))\n                mstore(add(words, offset), word)\n            }\n            // solhint-enable no-inline-assembly\n        }\n        /*\n            `bytes memory sample = 0x00010203..1f2021` stored in the memory like this:\n            slot #0: 0x22 - length (34 bytes)\n            slot #1: 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n            slot #2: 0x2021000000000000000000000000000000000000000000000000000000000000\n\n            If `OUT_RWRD_UTXOs == 2` and `CIPHERTEXT1_WORDS == 2`,\n            `bytes memory data` expected to be:\n            concatenate( // each element is 32-byte long\n                pubSpendingKeys[0].x, pubSpendingKeys[0].y,\n                pubSpendingKeys[1].x, pubSpendingKeys[1].y,\n                (secrets[0])[0], (secrets[0])[1],\n                (secrets[1])[0], (secrets[1])[1]\n            )\n        */\n        for (uint256 i = 0; i < OUT_RWRD_UTXOs; i++) {\n            pubSpendingKeys[i].x = words[i * PUBKEY_WORDS + 1];\n            pubSpendingKeys[i].y = words[i * PUBKEY_WORDS + 2];\n            for (uint256 k = 0; k < CIPHERTEXT1_WORDS; k++) {\n                secrets[i][k] = words[\n                    PUBKEY_WORDS *\n                        OUT_RWRD_UTXOs +\n                        CIPHERTEXT1_WORDS *\n                        i +\n                        k +\n                        1\n                ];\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/actions/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// solhint-disable var-name-mixedcase\n\n// The \"stake type\" for the \"classic staking\"\n// bytes4(keccak256(\"classic\"))\nbytes4 constant CLASSIC_STAKE_TYPE = 0x4ab0941a;\n\n// STAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_STAKE = 0x1e4d02b5;\n\n// UNSTAKE \"action type\" for the \"classic staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), CLASSIC_STAKE_TYPE)))\nbytes4 constant CLASSIC_UNSTAKE = 0x493bdf45;\n\n// The \"stake type\" for the \"advance staking\"\n// bytes4(keccak256(\"advanced\"))\nbytes4 constant ADVANCED_STAKE_TYPE = 0x7ec13a06;\n\n// STAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_STAKE = 0xcc995ce8;\n\n// UNSTAKE \"action type\" for the \"advanced staking\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), ADVANCED_STAKE_TYPE)))\nbytes4 constant ADVANCED_UNSTAKE = 0xb8372e55;\n\n// The \"stake type\" for the \"advance staking\"\n// bytes4(keccak256(\"advanced-v2\"))\nbytes4 constant ADVANCED_STAKE_V2_TYPE = 0x8496de05;\n\n// STAKE \"action type\" for the \"advanced staking V2\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"stake\"), ADVANCED_STAKE_V2_TYPE)))\nbytes4 constant ADVANCED_STAKE_V2 = 0x1954e321;\n\n// UNSTAKE \"action type\" for the \"advanced staking v2\"\n// bytes4(keccak256(abi.encodePacked(bytes4(keccak256(\"unstake\"), ADVANCED_STAKE_V2_TYPE)))\nbytes4 constant ADVANCED_UNSTAKE_V2 = 0x6a8ecb81;\n\n// PRP grant type for the \"advanced\" stake\n// bytes4(keccak256(\"forAdvancedStakeGrant\"))\nbytes4 constant FOR_ADVANCED_STAKE_GRANT = 0x31a180d4;\n\n// solhint-enable var-name-mixedcase\n"
    },
    "contracts/staking/actions/StakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IStakingTypes.sol\";\n\nabstract contract StakingMsgProcessor {\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\"stake\"));\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\"unstake\"));\n\n    function _encodeStakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\n    }\n\n    function _encodeUnstakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\n    }\n\n    function _packStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                staker, // address\n                stake.amount, // uint96\n                stake.id, // uint32\n                stake.stakedAt, // uint32\n                stake.lockedTill, // uint32\n                stake.claimedAt, // uint32\n                data // bytes\n            );\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _unpackStakingActionMsg(bytes memory message)\n        internal\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\n        // (`data` may be of zero length)\n        require(message.length >= 48, \"SMP: unexpected msg length\");\n\n        uint256 stakerAndAmount;\n        uint256 idAndStamps;\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n            // .. and (16 bytes of) the 3rd word\n            idAndStamps := mload(add(message, 0x40))\n        }\n        // solhint-enable no-inline-assembly\n\n        staker = address(uint160(stakerAndAmount >> 96));\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\n\n        uint256 dataLength = message.length - 48;\n        data = new bytes(dataLength);\n        for (uint256 i = 0; i < dataLength; i++) {\n            data[i] = message[i + 48];\n        }\n    }\n}\n"
    },
    "contracts/staking/AdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./actions/AdvancedStakingDataDecoder.sol\";\nimport \"./actions/Constants.sol\";\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IERC721Receiver.sol\";\nimport \"./interfaces/INftGrantor.sol\";\nimport \"./interfaces/IPantherPoolV0.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/NonReentrant.sol\";\nimport \"../common/Utils.sol\";\nimport \"../common/TransferHelper.sol\";\n\n/**\n * @title AdvancedStakeRewardController\n * @notice It generates UTXOs in the MASP as rewards to stakers for the \"Advanced Staking\"\n * @dev This contract is supposed to run on the Polygon. Unless otherwise mentioned, other smart\n * contracts are supposed to run on the Polygon also.\n * As the \"Reward Adviser\" on the \"advanced\" stakes, every time a new stake is being created, it\n * receives the `getRewardAdvice` call from the `RewardMaster` contract with the `STAKE` action\n * type and the stake data (the `message`) being the call parameters.\n * On the `getRewardAdvice` call received, this contract:\n * - computes the amounts of the $ZKP reward and the optional NFT reward\n * - if the `NFT_TOKEN` is non-zero address, it calls `grantOneToken` on the NFT_TOKEN, and gets\n * the `tokenId` of the minted NFT token\n * - calls `generateDeposits` of the PantherPoolV0, providing amounts/parameters of $ZKP, and\n *   optional NFT as \"deposits\", as well as \"spending pubKeys\" and \"secrets\" (explained below)\n * - returns the \"zero reward advice\" (with zero `sharesToCreate`) to the RewardMaster.\n *\n * On the \"zero\" advice, the RewardMaster skips creating \"treasure shares\" for the staker. This way\n * rewarding gets orchestrated by this contract rather than the RewardMaster.\n *\n * Being called `generateDeposits`, the PantherPoolV0:\n * - requests the `Vault` to take (`transferFrom`) the $ZKP and NFT tokens from this contract\n * - generates \"UTXOs\" with the \"spending pubKeys\" and \"secrets\" provided (see bellow).\n *\n * Creating a new stake (i.e. calling the `stake`), the staker generates and provides the \"pubKeys\"\n * and \"secrets\" to the Staking. Both the Staking on the mainnet and the Staking on the Polygon\n * encodes them into the STAKE message and passes to the RewardMaster, which passes the message to\n * this contract with the `getRewardAdvice` call. So this contracts get pubKeys and secrets needed\n * for the `generateDeposits`.\n * For stakes on the Polygon, when all contracts (i.e. Staking, RewardMaster and this contract) run\n * on the same network, the RewardMaster on the Polygon calls this contract directly.\n * For stakes made on the mainnet, where the Staking and the RewardMaster run, but this contract is\n * on the Polygon, the RewardMaster on the mainnet sends the STAKE message to the RewardMaster on\n * the Polygon via the PoS bridge and mediator contracts. The RewardMaster on the Polygon handles a\n * bridged STAKE message (calling the `getRewardAdvice`) as if the message had been sent by the\n * Staking on the Polygon.\n *\n * As a prerequisite:\n * - this contract shall:\n * -- be authorized as the \"RewardAdviser\" with the RewardMaster on the Polygon for advanced stakes\n * -- be authorized as \"Minter\" (aka \"grantor\") with the NFT_TOKEN contract\n * -- hold enough $ZKP to reward stakers\n * - the Vault contract shall be approved to transfer $ZKPs and the NFT tokens from this contract\n * - the $ZKP and the NFT tokens shall be registered as zAssets on the PantherPoolV0.\n */\ncontract AdvancedStakeRewardController is\n    ImmutableOwnable,\n    NonReentrant,\n    StakingMsgProcessor,\n    AdvancedStakingDataDecoder,\n    Utils,\n    Claimable,\n    IERC721Receiver,\n    IRewardAdviser\n{\n    using TransferHelper for address;\n\n    /// @dev Total amount of $ZKP and NFTs (ever) rewarded and staked\n    struct Totals {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n        // Accumulated amount of $ZKP (ever) staked, scaled (divided) by 1e15\n        uint40 scZkpStaked;\n    }\n\n    /// @dev Maximum amounts of $ZKPs and NFTs which may be rewarded\n    struct Limits {\n        uint96 zkpRewards;\n        uint24 nftRewards;\n    }\n\n    /// @dev Reward Timestamps and APYs\n    struct RewardParams {\n        /// @param (UNIX) Time when $ZKP rewards start to accrue\n        uint32 startTime;\n        /// @param (UNIX) Time when $ZKP rewards accruals end\n        uint32 endTime;\n        /// @param $ZKP reward APY at startTime (APY declines from this value)\n        uint8 startZkpApy;\n        /// @param $ZKP reward APY at endTime (APY declines to this value)\n        uint8 endZkpApy;\n    }\n\n    // solhint-disable var-name-mixedcase\n    // These three constants used to align with IPantherPool::generateDeposits API\n    uint256 private constant ZERO_AMOUNT = 0;\n    uint256 private constant ZERO_TOKEN_ID = 0;\n    address private constant ZERO_TOKEN = address(0);\n\n    /// @notice RewardMaster contract instance\n    address public immutable REWARD_MASTER;\n    /// @notice PantherPoolV0 contract instance\n    address public immutable PANTHER_POOL;\n\n    // Address of the $ZKP token contract\n    address private immutable ZKP_TOKEN;\n    // Address of the NFT token contract\n    address private immutable NFT_TOKEN;\n\n    /// @notice Block when this contract is deployed\n    uint256 public immutable START_BLOCK;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice Amounts of $ZKP and NFT allocated for rewards\n    Limits public limits;\n\n    /// @notice Total amounts of $ZKP and NFT rewarded so far\n    Totals public totals;\n\n    /// @notice Reward parameters (start and end point for time and APY)\n    RewardParams public rewardParams;\n\n    /// @dev Emitted when new amounts are allocated to reward stakers\n    event RewardLimitUpdated(Limits newLimits);\n\n    /// @dev Emitted when rewarding params updated\n    event RewardParamsUpdated(RewardParams newRewardParams);\n\n    /// @dev Emitted when the reward for a stake is generated\n    event RewardGenerated(\n        address indexed staker,\n        uint256 firstLeafId,\n        uint256 zkp,\n        uint256 nft\n    );\n\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    ) ImmutableOwnable(_owner) {\n        require(\n            // nftToken may be zero address\n            rewardMaster != address(0) &&\n                pantherPool != address(0) &&\n                zkpToken != address(0),\n            \"ARC:E1\"\n        );\n\n        REWARD_MASTER = rewardMaster;\n        PANTHER_POOL = pantherPool;\n\n        ZKP_TOKEN = zkpToken;\n        NFT_TOKEN = nftToken;\n\n        START_BLOCK = block.number;\n    }\n\n    /// @dev To be called by the {RewardMaster} contract on \"advanced\" `STAKE` and `UNSTAKE` actions.\n    /// The caller is trusted to never call w/ the STAKE acton:\n    /// - twice for the same stake\n    /// - after the rewarded period has ended\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        override\n        returns (Advice memory)\n    {\n        require(msg.sender == REWARD_MASTER, \"ARC: unauthorized\");\n\n        if (action == ADVANCED_STAKE) {\n            _generateRewards(message);\n        } else {\n            require(action == ADVANCED_UNSTAKE, \"ARC: unsupported action\");\n        }\n\n        // Return \"zero\" advice\n        return\n            Advice(\n                address(0), // createSharesFor\n                0, // sharesToCreate\n                address(0), // redeemSharesFrom\n                0, // sharesToRedeem\n                address(0) // sendRewardTo\n            );\n    }\n\n    /// @notice Return the APY for the $ZKP reward at a given time\n    function getZkpApyAt(uint256 time) external view returns (uint256) {\n        RewardParams memory _rewardParams = rewardParams;\n        if (time < _rewardParams.startTime || time > _rewardParams.endTime)\n            return 0;\n\n        return _getZkpApyWithinRewardedPeriod(_rewardParams, time);\n    }\n\n    function updateRewardParams(RewardParams memory _newParams)\n        external\n        onlyOwner\n    {\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            _newParams.startTime != 0 &&\n                _newParams.endTime > _newParams.startTime &&\n                _newParams.endTime > timeNow(),\n            \"ARC: invalid time\"\n        );\n        require(\n            _newParams.startZkpApy >= _newParams.endZkpApy,\n            \"ARC: invalid APY\"\n        );\n\n        rewardParams = _newParams;\n        emit RewardParamsUpdated(_newParams);\n    }\n\n    /// @notice Allocate NFT rewards and approve the Vault to transfer them\n    /// @dev Only owner may call it.\n    function setNftRewardLimit(uint256 _desiredNftRewardsLimit)\n        external\n        onlyOwner\n    {\n        if (NFT_TOKEN == address(0)) return;\n\n        Limits memory _limits = limits;\n\n        require(\n            _desiredNftRewardsLimit > totals.nftRewards,\n            \"ARC: low nft rewards limit\"\n        );\n\n        // known contract - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        bool isUpdated = _updateNftRewardsLimitAndAllowance(\n            _desiredNftRewardsLimit,\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Allocate for rewards the entire $ZKP balance\n    /// this contract has and approve the Vault to transfer $ZKP from this contract.\n    /// @dev Anyone may call it.\n    function updateZkpRewardsLimit() external {\n        Limits memory _limits = limits;\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        address vault = IPantherPoolV0(PANTHER_POOL).VAULT();\n\n        // Updating the rewards limits\n        bool isUpdated = _updateZkpRewardsLimitAndAllowance(\n            _limits,\n            totals,\n            vault\n        );\n\n        if (isUpdated) {\n            limits = _limits;\n            emit RewardLimitUpdated(_limits);\n        }\n    }\n\n    /// @notice Withdraws unclaimed rewards or accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function rescueErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external nonReentrant {\n        RewardParams memory _rewardParams = rewardParams;\n\n        require(OWNER == msg.sender, \"ARC: unauthorized\");\n        // Time comparison is acceptable in this case since block time accuracy is enough for this scenario\n        // slither-disable-next-line timestamp\n        require(\n            (token != ZKP_TOKEN) || (block.timestamp > _rewardParams.endTime),\n            \"ARC: too early withdrawal\"\n        );\n\n        _claimErc20(token, to, amount);\n    }\n\n    // Implementation of the {IERC721Receiver}. It accepts NFT_TOKEN transfers only.\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external view override returns (bytes4) {\n        return\n            msg.sender == NFT_TOKEN\n                ? this.onERC721Received.selector // accepted\n                : bytes4(0); // rejected\n    }\n\n    // Private functions follow\n    // Some of them declared `internal` rather than `private` to ease testing\n\n    function _generateRewards(bytes memory message) internal {\n        // (stakeId and claimedAt are irrelevant)\n        (\n            address staker,\n            uint96 stakeAmount,\n            ,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            ,\n            bytes memory data\n        ) = _unpackStakingActionMsg(message);\n\n        require(stakeAmount != 0, \"ARC: unexpected zero stakeAmount\");\n        require(lockedTill > stakedAt, \"ARC: unexpected lockedTill\");\n\n        uint256 zkpAmount = 0;\n        uint256 nftAmount = 0;\n        uint256 nftTokenId = 0;\n        {\n            Totals memory _totals = totals;\n            Limits memory _limits = limits;\n            RewardParams memory _rewardParams = rewardParams;\n\n            // Compute amount of the $ZKP reward  and check the limit\n            {\n                zkpAmount = _computeZkpReward(\n                    stakeAmount,\n                    lockedTill,\n                    stakedAt,\n                    _rewardParams\n                );\n\n                if (zkpAmount > 0) {\n                    uint256 newTotalZkpReward = uint256(_totals.zkpRewards) +\n                        zkpAmount;\n                    require(\n                        _limits.zkpRewards >= newTotalZkpReward,\n                        \"ARC: too less rewards available\"\n                    );\n                    // Can't exceed uint96 here due to the `require` above\n                    _totals.zkpRewards = uint96(newTotalZkpReward);\n                }\n                // update scSkpStaked in any case when stakeAmount > 0 which already been required\n                uint256 newScZkpStaked = uint256(_totals.scZkpStaked) +\n                    uint256(stakeAmount) /\n                    1e15;\n                // Overflow risk ignored as $ZKP max total supply is 1e9 tokens\n                _totals.scZkpStaked = uint40(newScZkpStaked);\n            }\n\n            if (_totals.nftRewards < _limits.nftRewards) {\n                // `_limits.nftRewards > 0` therefore `NFT_TOKEN != address(0)`\n                // trusted contract called - no reentrancy guard needed\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth\n                nftTokenId = INftGrantor(NFT_TOKEN).grantOneToken(\n                    address(this)\n                );\n\n                nftAmount = 1;\n                _totals.nftRewards += 1;\n            }\n\n            totals = _totals;\n        }\n\n        // Extract public spending keys and \"secrets\"\n        (\n            G1Point[OUT_RWRD_UTXOs] memory pubSpendingKeys,\n            uint256[CIPHERTEXT1_WORDS][OUT_RWRD_UTXOs] memory secrets\n        ) = unpackStakingData(data);\n\n        // Finally, generate deposits (i.e. UTXOs in the MASP)\n        address[OUT_MAX_UTXOs] memory tokens = [\n            // PantherPool reverts if non-zero address provided for zero amount\n            zkpAmount == 0 ? address(0) : ZKP_TOKEN,\n            nftAmount == 0 ? address(0) : NFT_TOKEN,\n            ZERO_TOKEN\n        ];\n\n        uint256[OUT_MAX_UTXOs] memory subIds = [0, nftTokenId, ZERO_TOKEN_ID];\n        uint256[OUT_MAX_UTXOs] memory extAmounts = [\n            zkpAmount,\n            nftAmount,\n            ZERO_AMOUNT\n        ];\n\n        uint32 createdAt = safe32TimeNow();\n        // known contract call - no reentrancy guard needed\n        // slither-disable-next-line reentrancy-benign,reentrancy-events\n        uint256 leftLeafId = IPantherPoolV0(PANTHER_POOL).generateDeposits(\n            tokens,\n            subIds,\n            extAmounts,\n            [\n                pubSpendingKeys[0],\n                pubSpendingKeys[1],\n                pubSpendingKeys[1] // dummy public key - reused\n            ],\n            [\n                secrets[0],\n                secrets[1],\n                secrets[1] // dummy secret - reused\n            ],\n            createdAt\n        );\n\n        emit RewardGenerated(staker, leftLeafId, zkpAmount, nftAmount);\n    }\n\n    // The calling code is assumed to ensure `lockedTill > stakedAt`\n    function _computeZkpReward(\n        uint256 stakeAmount,\n        uint256 lockedTill,\n        uint256 stakedAt,\n        RewardParams memory _rewardParams\n    ) internal pure returns (uint256 zkpAmount) {\n        // No rewarding after `endTime`\n        if (stakedAt >= _rewardParams.endTime) return 0;\n        // No rewarding before `startTime`\n        if (lockedTill <= _rewardParams.startTime) return 0;\n\n        uint256 rewardedSince = _rewardParams.startTime > stakedAt\n            ? _rewardParams.startTime\n            : stakedAt;\n\n        uint256 rewardedTill = lockedTill > _rewardParams.endTime\n            ? _rewardParams.endTime\n            : lockedTill;\n\n        uint256 period = rewardedTill - rewardedSince;\n        uint256 apy = _getZkpApyWithinRewardedPeriod(\n            _rewardParams,\n            rewardedSince\n        );\n\n        // 3153600000 = 365 * 24 * 3600 seconds * 100 percents\n        // slither-disable-next-line too-many-digits\n        zkpAmount = (stakeAmount * apy * period) / 3153600000;\n        // round to 2nd digits after decimal point: X.YZ{0..0} x 1e18\n        unchecked {\n            // rounding (accuracy loss is assumed)\n            // slither-disable-next-line divide-before-multiply\n            zkpAmount = (zkpAmount / 1e16) * (1e16);\n        }\n    }\n\n    // The calling code is assumed to ensure that\n    // `startTime < time < endTime` and `startZkpApy >= endZkpApy`\n    function _getZkpApyWithinRewardedPeriod(\n        RewardParams memory _rewardParams,\n        uint256 time\n    ) private pure returns (uint256 apy) {\n        unchecked {\n            uint256 fullDrop = uint256(\n                _rewardParams.startZkpApy - _rewardParams.endZkpApy\n            );\n            apy = uint256(_rewardParams.startZkpApy);\n\n            if (fullDrop > 0) {\n                uint256 dropDuration = time - _rewardParams.startTime;\n                uint256 fullDuration = uint256(\n                    _rewardParams.endTime - _rewardParams.startTime\n                );\n                uint256 apyDrop = (fullDrop * dropDuration) / fullDuration;\n\n                apy -= apyDrop;\n            }\n        }\n    }\n\n    // Allocate for rewards the entire $ZKP balance this contract holds,\n    // and update allowance for the VAULT to spend for $ZKP from the balance\n    function _updateZkpRewardsLimitAndAllowance(\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        // Reentrancy guard unneeded for the trusted contract call\n        // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n        uint256 balance = ZKP_TOKEN.safeBalanceOf(address(this));\n\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            balance,\n            _limits.zkpRewards,\n            _totals.zkpRewards\n        );\n\n        if (isUpdated) {\n            _limits.zkpRewards = newLimit;\n\n            // Approve the vault to transfer tokens from this contract\n            // Reentrancy guard unneeded for the trusted contract call\n            // slither-disable-next-line reentrancy-benign,reentrancy-events,reentrancy-no-eth\n            ZKP_TOKEN.safeApprove(vault, uint256(newLimit));\n        }\n    }\n\n    // Allocate for rewards the entire NFT amount this contract can mint,\n    // and update allowance for the VAULT to spend that NFT\n    function _updateNftRewardsLimitAndAllowance(\n        uint256 _desiredNftRewardsLimit,\n        Limits memory _limits,\n        Totals memory _totals,\n        address vault\n    ) private returns (bool isUpdated) {\n        uint96 newLimit;\n        (isUpdated, newLimit) = _getUpdatedLimit(\n            _desiredNftRewardsLimit,\n            _limits.nftRewards,\n            _totals.nftRewards\n        );\n\n        if (isUpdated) {\n            bool isAllowanceToBeUpdated = _limits.nftRewards == 0;\n\n            // Overflow is unrealistic and therefore ignored\n            _limits.nftRewards = uint24(newLimit);\n\n            if (isAllowanceToBeUpdated)\n                // Approve the vault to transfer tokens from this contract\n                // Reentrancy guard unneeded for the trusted contract call\n                // slither-disable-next-line reentrancy-benign,reentrancy-no-eth,reentrancy-events\n                NFT_TOKEN.safeSetApprovalForAll(vault, true);\n        }\n    }\n\n    // Calculates and returns the updated reward limit\n    function _getUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) internal pure returns (bool isUpdated, uint96 limit) {\n        uint256 unusedLimit = uint256(currentLimit) - uint256(usedLimit);\n\n        if (available == unusedLimit) return (false, currentLimit);\n\n        isUpdated = true;\n        // underflow is impossible due to `if` checks\n        unchecked {\n            if (available > unusedLimit) {\n                // new tokens for rewarding have been provided\n                uint256 newAllocation = available - unusedLimit;\n                limit = safe96(newAllocation + currentLimit);\n            } else {\n                // gracefully handle this unexpected situation\n                uint96 shortage = safe96(unusedLimit - available);\n                limit = currentLimit > shortage ? currentLimit - shortage : 0;\n            }\n        }\n    }\n}\n"
    },
    "contracts/staking/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient,\n     * the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/staking/interfaces/IFxMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev A receiver on the Polygon (or Mumbai) network of a message sent over the\n * \"Fx-Portal\" must implement this interface.\n * The \"Fx-Portal\" is the PoS bridge run by the Polygon team.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxMessageProcessor {\n    function processMessageFromRoot(\n        uint256 stateId,\n        address rootMessageSender,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/staking/interfaces/IFxStateSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n/***\n * @dev An interface of the `FxRoot` contract\n * `FxRoot` is the contract of the \"Fx-Portal\" (a PoS bridge run by the Polygon team) on the\n * mainnet/Goerli network. It passes data to s user-defined contract on the Polygon/Mumbai.\n * See https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal\n */\ninterface IFxStateSender {\n    function sendMessageToChild(address _receiver, bytes calldata _data)\n        external;\n}\n"
    },
    "contracts/staking/interfaces/INftGrantor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\ninterface INftGrantor {\n    function grantOneToken(address to) external returns (uint256 tokenId);\n}\n"
    },
    "contracts/staking/interfaces/IPantherPoolV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\nimport { G1Point } from \"../../common/Types.sol\";\nimport { CIPHERTEXT1_WORDS, OUT_MAX_UTXOs, PATH_ELEMENTS_NUM } from \"../../common/Constants.sol\";\n\n/**\n * @notice (Truncated) Interface of the PantherPoolV0\n * @dev Only those functions and events included which the `AdvancedStakeRewardController` contract uses\n */\ninterface IPantherPoolV0 {\n    /**\n     * @notice Transfer assets from the msg.sender to the VAULT and generate UTXOs in the MASP\n     * @param tokens Address of the token contract for every UTXO\n     * @dev For PRP granted the address ot this contract (proxy) is supposed to be used\n     * @param tokenIds For ERC-721 and ERC-1155 - token ID or subId of the token, 0 for ERC-20\n     * @param extAmounts Token amounts (external) to be deposited\n     * @param pubSpendingKeys Public Spending Key for every UTXO\n     * @param secrets Encrypted opening values for every UTXO\n     * @param  createdAt Optional, if 0 network time used\n     * @dev createdAt must be less (or equal) the network time\n     * @return leftLeafId The `leafId` of the first UTXO (leaf) in the batch\n     */\n    function generateDeposits(\n        address[OUT_MAX_UTXOs] calldata tokens,\n        uint256[OUT_MAX_UTXOs] calldata tokenIds,\n        uint256[OUT_MAX_UTXOs] calldata extAmounts,\n        G1Point[OUT_MAX_UTXOs] calldata pubSpendingKeys,\n        uint256[CIPHERTEXT1_WORDS][OUT_MAX_UTXOs] calldata secrets,\n        uint32 createdAt\n    ) external returns (uint256 leftLeafId);\n\n    function exit(\n        address token,\n        uint256 tokenId,\n        uint256 amount,\n        uint32 creationTime,\n        uint256 privSpendingKey,\n        uint256 leafId,\n        bytes32[PATH_ELEMENTS_NUM] calldata pathElements,\n        bytes32 merkleRoot,\n        uint256 cacheIndexHint\n    ) external;\n\n    /**\n     * @return Address of the Vault\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function VAULT() external view returns (address);\n\n    /**\n     * @dev Emitted on a new batch of Commitments\n     * @param leftLeafId The `leafId` of the first leaf in the batch\n     * @dev `leafId = leftLeafId + 1` for the 2nd leaf (`leftLeafId + 2` for the 3rd leaf)\n     * @param commitments Commitments hashes\n     * @param utxoData opening values (encrypted and public) for UTXOs\n     */\n    event NewCommitments(\n        uint256 indexed leftLeafId,\n        uint256 creationTime,\n        bytes32[OUT_MAX_UTXOs] commitments,\n        bytes utxoData\n    );\n\n    /**\n     * Nullifier is seen (i.e. UTXO is spent)\n     */\n    event Nullifier(bytes32 nullifier);\n}\n"
    },
    "contracts/staking/interfaces/IRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IRewardAdviser {\n    struct Advice {\n        // advice on new \"shares\" (in the reward pool) to create\n        address createSharesFor;\n        uint96 sharesToCreate;\n        // advice on \"shares\" to redeem\n        address redeemSharesFrom;\n        uint96 sharesToRedeem;\n        // advice on address the reward against redeemed shares to send to\n        address sendRewardTo;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        returns (Advice memory);\n}\n"
    },
    "contracts/staking/interfaces/IStakingTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\ninterface IStakingTypes {\n    // Stake type terms\n    struct Terms {\n        // if stakes of this kind allowed\n        bool isEnabled;\n        // if messages on stakes to be sent to the {RewardMaster}\n        bool isRewarded;\n        // limit on the minimum amount staked, no limit if zero\n        uint32 minAmountScaled;\n        // limit on the maximum amount staked, no limit if zero\n        uint32 maxAmountScaled;\n        // Stakes not accepted before this time, has no effect if zero\n        uint32 allowedSince;\n        // Stakes not accepted after this time, has no effect if zero\n        uint32 allowedTill;\n        // One (at least) of the following three params must be non-zero\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\n        uint32 lockedTill;\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\n        uint32 exactLockPeriod;\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\n        uint32 minLockPeriod;\n    }\n\n    struct Stake {\n        // index in the `Stake[]` array of `stakes`\n        uint32 id;\n        // defines Terms\n        bytes4 stakeType;\n        // time this stake was created at\n        uint32 stakedAt;\n        // time this stake can be claimed at\n        uint32 lockedTill;\n        // time this stake was claimed at (unclaimed if 0)\n        uint32 claimedAt;\n        // amount of tokens on this stake (assumed to be less 1e27)\n        uint96 amount;\n        // address stake voting power is delegated to\n        address delegatee;\n    }\n}\n"
    },
    "contracts/staking/mocks/MockAdvancedStakeRewardController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.16;\n\nimport \"../AdvancedStakeRewardController.sol\";\n\ncontract MockAdvancedStakeRewardController is AdvancedStakeRewardController {\n    constructor(\n        address _owner,\n        address rewardMaster,\n        address pantherPool,\n        address zkpToken,\n        address nftToken\n    )\n        AdvancedStakeRewardController(\n            _owner,\n            rewardMaster,\n            pantherPool,\n            zkpToken,\n            nftToken\n        )\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function internalComputeZkpReward(\n        uint256 stakeAmount,\n        uint32 lockedTill,\n        uint32 stakedAt,\n        RewardParams memory _rewardParams\n    ) external pure returns (uint256 zkpAmount) {\n        return\n            _computeZkpReward(stakeAmount, lockedTill, stakedAt, _rewardParams);\n    }\n\n    function internalGenerateRewards(bytes calldata message) external {\n        _generateRewards(message);\n    }\n\n    function internalGetUpdatedLimit(\n        uint256 available,\n        uint96 currentLimit,\n        uint96 usedLimit\n    ) external pure returns (bool isUpdated, uint96 limit) {\n        return _getUpdatedLimit(available, currentLimit, usedLimit);\n    }\n\n    function fakeTotals(Totals memory _totals) external {\n        totals = _totals;\n    }\n}\n"
    },
    "contracts/staking/mocks/MockClaimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nimport \"../../common/Claimable.sol\";\n\ncontract MockClaimable is Claimable {\n    function internalClaimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        _claimErc20(token, to, amount);\n    }\n}\n"
    },
    "contracts/staking/ZkpFaucet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../common/Claimable.sol\";\nimport \"../common/ImmutableOwnable.sol\";\n\n// When called `drink`, it sends tokens to the `_to`\n// As a prerequisite, it shall get enough tokens on the balance\ncontract ZkpFaucet is Claimable, ImmutableOwnable {\n    address public immutable token;\n    uint256 public cupSize;\n    uint256 public tokenPrice;\n    uint256 public maxAmountToPay;\n    uint256 public maxDrinkCount;\n\n    // @notice  store the whitelisted addresses who can drink\n    mapping(address => bool) public whitelistedAddresses;\n    // @notice store the number of times each user has drank\n    mapping(address => uint256) public drinkCount;\n\n    // @notice enabling/disabling check for whitelisted addresses\n    bool public restrictToWhitelisted;\n\n    event CupSizeUpdated(uint256 newCupSice);\n    event TokenPriceUpdated(uint256 newTokenPrice);\n    event MaxDrinkCountUpdated(uint256 newMaxDrinkCount);\n    event WhitelistRestrictUpdated(bool newIsRestricted);\n\n    constructor(\n        address _owner,\n        address _token,\n        uint256 _tokenPrice,\n        uint256 _maxAmountToPay,\n        uint256 _cupSize,\n        uint256 _maxDrinkCount\n    ) ImmutableOwnable(_owner) {\n        require(_cupSize > 0, \"invalid cup size\");\n        require(_token != address(0), \"invalid token address\");\n\n        token = _token;\n        tokenPrice = _tokenPrice;\n        cupSize = _cupSize;\n        maxAmountToPay = _maxAmountToPay;\n        maxDrinkCount = _maxDrinkCount;\n\n        emit TokenPriceUpdated(_tokenPrice);\n        emit CupSizeUpdated(_cupSize);\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n        emit WhitelistRestrictUpdated(false);\n    }\n\n    /**\n     * @notice if restrictToWhitelisted is true, then\n     * check if the sender is whitelisted\n     */\n    modifier onlyWhitelisted(address _address) {\n        require(\n            !restrictToWhitelisted || isWhitelisted(_address),\n            \"Not whitelisted\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if maxDrinkCount is defined, then\n     * check if the sender is already received token\n     */\n    modifier checkDrinkCount(address _address) {\n        require(\n            maxDrinkCount == 0 || withinDrinkLimit(_address),\n            \"Reached maximum drink count\"\n        );\n        _;\n    }\n\n    /**\n     * @notice if token price is more than 0, then\n     * check the value\n     */\n    modifier validatePrice() {\n        require(msg.value <= maxAmountToPay, \"High value\");\n        require(msg.value >= tokenPrice, \"Low value\");\n        _;\n    }\n\n    /**\n     * @notice return true if the address is whitelisted, otherwise false\n     * @dev it helps when contract is restricted to whitelisted addresses\n     */\n    function isWhitelisted(address _account) public view returns (bool) {\n        return whitelistedAddresses[_account];\n    }\n\n    /**\n     * @notice return true if the user request counts are\n     * less than or equal to maxDrinkCount, otherwise returns false\n     * @dev it helps when contract is restricted to requests count.\n     */\n    function withinDrinkLimit(address _account) public view returns (bool) {\n        return drinkCount[_account] < maxDrinkCount;\n    }\n\n    /**\n     * @notice send tokens to `_to`\n     * @param _to the receiver addresss\n     * @dev if restrictToWhitelisted is true, then check if the\n     * sender is whitelisted.\n     * if the restrictToMaxReq is true, then check if the\n     * sender is already received token.\n     */\n    function drink(address _to)\n        external\n        payable\n        validatePrice\n        onlyWhitelisted(msg.sender)\n        checkDrinkCount(_to)\n    {\n        drinkCount[_to]++;\n\n        safeTransfer(token, _to, getCupSize(msg.value));\n    }\n\n    function getCupSize(uint256 _amountToPay) public view returns (uint256) {\n        return tokenPrice > 0 ? _amountToPay / tokenPrice : cupSize;\n    }\n\n    function safeTransfer(\n        address _token,\n        address _to,\n        uint256 _value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        // solhint-disable avoid-low-level-calls\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = _token.call(\n            abi.encodeWithSelector(0xa9059cbb, _to, _value)\n        );\n        // solhint-enable avoid-low-level-calls\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper::safeTransfer: transfer failed\"\n        );\n    }\n\n    // Owner functions\n    /**\n     * @notice update restrictToWhitelisted\n     */\n    function updateRestrictToWhitelisted(bool isRestricted) external onlyOwner {\n        restrictToWhitelisted = isRestricted;\n        emit WhitelistRestrictUpdated(isRestricted);\n    }\n\n    /**\n     * @notice Add multiple addresses to the whitelisted list\n     * @param _whitelistedAddresses array of addresses to be added\n     * @param _whitelisted array of boolen values to be mapped to the addresses\n     */\n    function whitelistBatch(\n        address[] calldata _whitelistedAddresses,\n        bool[] calldata _whitelisted\n    ) external onlyOwner {\n        for (uint256 i = 0; i < _whitelistedAddresses.length; ) {\n            whitelistedAddresses[_whitelistedAddresses[i]] = _whitelisted[i];\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice update the amount that can be received by users\n     * @param _cupSize the amount that can be received by users\n     */\n    function updateCupSize(uint256 _cupSize) external onlyOwner {\n        require(_cupSize > 0, \"invalid size\");\n        cupSize = _cupSize;\n        emit CupSizeUpdated(_cupSize);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _tokenPrice the price of each token\n     */\n    function updateTokenPrice(uint256 _tokenPrice) external onlyOwner {\n        tokenPrice = _tokenPrice;\n        emit TokenPriceUpdated(_tokenPrice);\n    }\n\n    /**\n     * @notice update the token price.\n     * @param _maxDrinkCount the maximum number of times the\n     * drink function can be called\n     */\n    function updateMaxDrinkCount(uint256 _maxDrinkCount) external onlyOwner {\n        maxDrinkCount = _maxDrinkCount;\n        emit MaxDrinkCountUpdated(_maxDrinkCount);\n    }\n\n    /**\n     * @notice whithdraws native or erc20 token from the contract\n     * @param _claimedToken The token address to claim\n     * @param _to the receiver address\n     * @param _amount the token amount to be withdrawn\n     * @dev The token address can be zero address in case the\n     * native token is going to be withdrawn.\n     */\n    function withdraw(\n        address _claimedToken,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        require(_to != address(0), \"recipient cannot be 0\");\n        require(_amount > 0, \"amount cannot be 0\");\n\n        if (_claimedToken == address(0)) {\n            // solhint-disable avoid-low-level-calls\n            // slither-disable-next-line low-level-calls\n            (bool sent, ) = _to.call{ value: _amount }(\"\");\n            // solhint-enable avoid-low-level-calls\n            require(sent, \"Failed to send native\");\n        } else {\n            _claimErc20(_claimedToken, _to, _amount);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}