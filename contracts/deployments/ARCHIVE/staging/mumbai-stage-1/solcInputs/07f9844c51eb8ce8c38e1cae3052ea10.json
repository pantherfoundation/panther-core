{
  "language": "Solidity",
  "sources": {
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nabstract contract Utils {\n    // false positive\n    // slither-disable-next-line timestamp\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/protocol/PrpVoucherGrantor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n\npragma solidity 0.8.16;\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/Utils.sol\";\n\n// TODO: Remove this interface once the pool contract is updated.\ninterface PoolContract {\n    function increasePRPBalance(uint256 amount, bytes calldata proof) external;\n}\n\n/// @title PrpVoucherGrantor\n/// @notice The PRPGrantor smart contract is designed to facilitate rewarding\n/// users with Panther Protocol rewards (nominated in PRPs) other than rewards\n/// generated by/within MASP transactions. Reward claims to be generated and\n/// utilised by users. The contract maintains a mapping of claimable PRP\n/// balances  associated with individual secrets. It accumulates generated\n/// claims associated with the same secret. A claim “utilisation” results in\n/// increasing the PRP balance inside the zAccount of a user by the amount\n/// of the claim. To utilise a claim (it’s entire balance) associated with a\n/// secret, a user must provide proof of zAccount ownership and knowledge of\n/// the secret. The contract owner has the authority to update the terms, and\n/// the smart contract is upgradable to extend the action list as needed upon\n/// DAO voting.\ncontract PrpVoucherGrantor is ImmutableOwnable, Utils {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable-next-line\n    PoolContract public immutable POOL_CONTRACT;\n    // solhint-disable-next-line\n    uint64 private ZERO_VALUE = 1;\n\n    mapping(bytes32 => uint256) public balance;\n    mapping(address => mapping(bytes4 => VoucherTerms)) public voucherTerms;\n\n    /// @dev Struct for storing voucher terms.\n\n    /// @param rewardsGranted The total amount (accumulator) of rewards granted\n    /// for this voucher\n    /// @param limit The rewards limit of the reward voucher. rewardsGranted <=\n    //limit\n    /// @param amount The amount of the reward that voucher generates.\n    /// @param enabled The status of the voucher terms.\n    struct VoucherTerms {\n        uint64 rewardsGranted;\n        uint64 limit;\n        uint64 amount;\n        bool enabled;\n        // rest of the storage slot (uint120) are available for upgrades\n        uint56 _reserved;\n    }\n\n    /// @dev Emitted when a new reward voucher is generated.\n    /// @param secretHash The secret hash for the reward voucher.\n    event RewardVoucherGenerated(bytes32 indexed secretHash, uint256 prpAmount);\n\n    /// @dev Emitted when a reward voucher is successfully claimed.\n    /// @param secretHash The secret hash for the claimed reward voucher.\n    event RewardClaimed(bytes32 indexed secretHash);\n\n    /// @dev Emitted when the voucher terms are updated.\n    /// @param allowedContract The address of the contract allowed to generate\n    /// reward vouchers.\n    /// @param voucherType The type of the reward voucher.\n    /// @param limit The limit of the reward voucher.\n    /// @param amount The amount of the reward voucher.\n    event VoucherTermsUpdated(\n        address allowedContract,\n        bytes4 voucherType,\n        uint64 limit,\n        uint64 amount\n    );\n\n    /// @notice Constructor that sets the initial owner, pool contract and\n    /// verifier contract.\n    /// @param _owner The owner of the PrpVoucherGrantor contract.\n    /// @param _poolContract The address of the pool contract.\n    constructor(address _owner, address _poolContract)\n        ImmutableOwnable(_owner)\n    {\n        revertZeroAddress(_poolContract);\n        POOL_CONTRACT = PoolContract(_poolContract);\n    }\n\n    modifier onlyValidVoucherTypes(bytes4 _voucherType) {\n        require(\n            voucherTerms[msg.sender][_voucherType].enabled,\n            \"PrpVoucherGrantor: Inactive or invalid voucher type\"\n        );\n        _;\n    }\n\n    /// @notice Generates a reward voucher for a given secret hash and voucher\n    /// type.\n    /// @param _secretHash The secret hash for the reward voucher.\n    /// @param _amount The amount of the reward voucher.\n    /// @param _voucherType The type of the reward voucher.\n    /// @return The prp amount which has be granted.\n    function generateRewards(\n        bytes32 _secretHash,\n        uint64 _amount,\n        bytes4 _voucherType\n    ) external onlyValidVoucherTypes(_voucherType) returns (uint256) {\n        VoucherTerms memory voucherTerm = voucherTerms[msg.sender][\n            _voucherType\n        ];\n\n        // If amount in the voucher is not set, then the amount is specified\n        // by the calling smart contract, otherwise it is specified by the\n        uint64 prpToGrant = _amount > 0 ? _amount : voucherTerm.amount;\n\n        if (voucherTerm.rewardsGranted + prpToGrant > voucherTerm.limit)\n            return 0;\n\n        // we are setting the balance to non-zero to save gas\n        if (balance[_secretHash] > ZERO_VALUE) {\n            balance[_secretHash] += prpToGrant;\n        } else {\n            balance[_secretHash] = ZERO_VALUE + prpToGrant;\n        }\n\n        voucherTerms[msg.sender][_voucherType].rewardsGranted += prpToGrant;\n\n        emit RewardVoucherGenerated(_secretHash, prpToGrant);\n\n        return prpToGrant;\n    }\n\n    /// @notice Claims a rewards collected for the given secret hash.\n    /// @param secretHash The secret hash for the reward voucher.\n    /// @param proof A proof associated with the zAccount and a secret.\n    function claimRewards(\n        bytes32 secretHash,\n        // solhint-disable-next-line\n        bytes calldata proof\n    ) external {\n        uint256 rewardAmount = balance[secretHash];\n        require(\n            rewardAmount > ZERO_VALUE,\n            \"PrpVoucherGrantor: No reward to claim\"\n        );\n\n        // we are setting the balance to non-zero to save gas for the next\n        // rearward generation\n        balance[secretHash] = ZERO_VALUE;\n\n        // TODO: implement the rest of the logic in the Pool contract\n        // POOL_CONTRACT.increasePRPBalance(\n        //     rewardAmount,\n        //     secretHash,\n        //     _secretAndzAccountProof\n        //     // zAccountTree root\n        //     // commitmentHash\n        //     // newZAccountUTXOCommitment\n        //     // and a couple of other things\n        // );\n        emit RewardClaimed(secretHash);\n    }\n\n    /// @notice Sets the terms for action rewards for a given voucher type.\n    /// @param _allowedContract The address of the contract allowed to generate\n    /// reward vouchers.\n    /// @param _voucherType The type of the reward voucher.\n    /// @param _limit The limit for the voucher grants.\n    /// @param _amount The amount of PRP to grant for the voucher.\n    /// @param _enabled The status of the voucher type.\n    function updateVoucherTerms(\n        address _allowedContract,\n        bytes4 _voucherType,\n        uint64 _limit,\n        uint64 _amount,\n        bool _enabled\n    ) external onlyOwner {\n        revertZeroAddress(_allowedContract);\n        uint64 rewardsGenerated = voucherTerms[_allowedContract][_voucherType]\n            .rewardsGranted;\n\n        require(\n            _limit + _amount >= rewardsGenerated,\n            \"PrpVoucherGrantor: Limit cannot be less than rewards generated\"\n        );\n\n        voucherTerms[_allowedContract][_voucherType] = VoucherTerms(\n            rewardsGenerated,\n            _limit,\n            _amount,\n            _enabled,\n            uint56(0) // reserved\n        );\n        emit VoucherTermsUpdated(\n            _allowedContract,\n            _voucherType,\n            _limit,\n            _amount\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}