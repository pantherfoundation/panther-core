{
  "language": "Solidity",
  "sources": {
    "contracts/common/EIP712SignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nabstract contract EIP712SignatureVerifier {\n    bytes private constant EIP191_VERSION = \"\\x19\\x01\";\n\n    string public constant EIP712_NAME = \"Panther Protocol\";\n    string public constant EIP712_VERSION = \"1\";\n\n    // keccak256(bytes(\"PANTHER_EIP712_DOMAIN_SALT\"));\n    bytes32 public constant EIP712_SALT =\n        0x44b818e3e3a12ecf805989195d8f38e75517386006719e2dbb1443987a34db7b;\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n            )\n        );\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(bytes(EIP712_NAME)),\n                    keccak256(bytes(EIP712_VERSION)),\n                    block.chainid,\n                    address(this),\n                    EIP712_SALT\n                )\n            );\n    }\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address signer) {\n        signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA invalid signature\");\n    }\n\n    function toTypedDataHash(bytes32 structHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    EIP191_VERSION,\n                    getDomainSeperator(),\n                    structHash\n                )\n            );\n    }\n}\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/common/UtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.16;\n\nlibrary UtilsLib {\n    function safe24(uint256 n) internal pure returns (uint24) {\n        require(n < 2**24, \"UNSAFE24\");\n        return uint24(n);\n    }\n\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        uint256 t = block.timestamp;\n        require(t < 2**32, \"UNSAFE32TIME\");\n        return uint32(t);\n    }\n\n    function safe32BlockNow() internal view returns (uint32) {\n        uint256 b = block.number;\n        require(b < 2**32, \"UNSAFE32BLOCK\");\n        return uint32(b);\n    }\n\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/protocol/crypto/BabyJubJub.sol": {
      "content": "// SPDX-License-Identifier: GPL\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// Implementer name - yondonfu\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\npragma solidity ^0.8.16;\nimport \"../../common/Types.sol\";\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\n\nlibrary BabyJubJub {\n    // Curve parameters\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\n    // A = 168700\n    uint256 public constant A = 0x292FC;\n    // D = 168696\n    uint256 public constant D = 0x292F8;\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    // slither-disable-next-line too-many-digits\n    uint256 public constant Q =\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\n\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\n    // That is, it generates the set of points of order l and origin O.\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_X =\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_Y =\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n    // pm1d2 = (SNARK_FIELD - 1) >> 1 // same as `negative_one / 2\n    // slither-disable-next-line too-many-digits\n    uint256 public constant PM1D2 =\n        10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n    // TODO: remove dependency on BabyJubJub as a standalone contract\n    function pointPack(G1Point memory point)\n        internal\n        pure\n        returns (bytes32 _packed)\n    {\n        _packed = bytes32(point.y);\n\n        if (point.x > PM1D2) {\n            _packed = bytes32(\n                point.y |\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n            );\n        }\n    }\n\n    /**\n     * @dev Add 2 points on baby jubjub curve\n     * Formulae for adding 2 points on a twisted Edwards curve:\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\n     */\n    function pointAdd(G1Point memory g1, G1Point memory g2)\n        internal\n        view\n        returns (G1Point memory)\n    {\n        uint256 x3 = 0;\n        uint256 y3 = 0;\n        if (g1.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        if (g2.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\n\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\n        return G1Point(x3, y3);\n    }\n\n    /**\n     * @dev Perform modular subtraction\n     */\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        uint256 aNN = _a;\n\n        if (_a <= _b) {\n            aNN += _mod;\n        }\n\n        return addmod(aNN - _b, 0, _mod);\n    }\n\n    /**\n     * @dev Compute modular inverse of a number\n     */\n    function inverse(uint256 _a) internal view returns (uint256) {\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\n        return expmod(_a, Q - 2, Q);\n    }\n\n    /**\n     * @dev Helper function to call the bigModExp precompile\n     */\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20) // Length of base _b\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\n            mstore(add(memPtr, 0x60), _b) // Base _b\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\n\n            // The bigModExp precompile is at 0x05\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n        // solhint-enable no-inline-assembly\n    }\n\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        r.x = 0;\n        r.y = 1;\n\n        uint256 rem = scalar;\n        G1Point memory exp = point;\n\n        while (rem != uint256(0)) {\n            if ((rem & 1) == 1) {\n                r = pointAdd(r, exp);\n            }\n            exp = pointAdd(exp, exp);\n            rem = rem >> 1;\n        }\n        r.x = r.x % Q;\n        r.y = r.y % Q;\n\n        return r;\n    }\n\n    function isG1PointLowerThanFieldSize(uint256[2] memory point)\n        internal\n        pure\n        returns (bool)\n    {\n        return point[0] <= FIELD_SIZE && point[1] <= FIELD_SIZE;\n    }\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/PoseidonHashers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\nimport \"./Poseidon.sol\";\n\nlibrary PoseidonHashers {\n    string private constant ERR_INPUT_NOT_IN_FIELD =\n        \"PoseidonHasher: input not in field\";\n\n    function poseidonT3(bytes32[2] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE && uint256(input[1]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT3.poseidon(input);\n    }\n\n    function poseidonT4(bytes32[3] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT4.poseidon(input);\n    }\n\n    function poseidonT5(bytes32[4] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT5.poseidon(input);\n    }\n\n    function poseidonT6(bytes32[5] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE &&\n                uint256(input[4]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT6.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// FIXME: make MAGICAL_CONSTRAINT the public input (var, not const) - it MUST have random value on every invocation\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/errMsgs/CachedRootsErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_EMPTY_CACHE = \"CR:E1\";\nstring constant ERR_INDEX_NOT_IN_RANGE = \"CR:E2\";\n"
    },
    "contracts/protocol/errMsgs/PantherPoolV1ErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"PP:E1\";\nstring constant ERR_UNAUTHORIZED = \"PP:E2\";\nstring constant ERR_UNDEFINED_CIRCUIT = \"PP:E3\";\nstring constant ERR_INVALID_FOREST_ROOT = \"PP:E4\";\nstring constant ERR_FAILED_ZK_PROOF = \"PP:E5\";\nstring constant ERR_INVALID_CREATE_TIME = \"PP:E6\";\nstring constant ERR_ZERO_ZACCOUNT_NULLIFIER = \"PP:E7\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"PP:E8\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"PP:E9\";\nstring constant ERR_ZERO_SALT_HASH = \"PP:E10\";\nstring constant ERR_ZERO_MAGIC_CONSTR = \"PP:E11\";\nstring constant ERR_NOT_WELLFORMED_SECRETS = \"PP:E12\";\n"
    },
    "contracts/protocol/errMsgs/ZAccountsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT_CONTRACT = \"ZAR:init\";\n\nstring constant ERR_BLACKLIST_ZACCOUNT_ID = \"ZAR:E1\";\nstring constant ERR_BLACKLIST_MASTER_EOA = \"ZAR:E2\";\nstring constant ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY = \"ZAR:E3\";\n\nstring constant ERR_DUPLICATED_MASTER_EOA = \"ZAR:E4\";\nstring constant ERR_DUPLICATED_NULLIFIER = \"ZAR:E5\";\n\nstring constant ERR_UNKNOWN_ZACCOUNT = \"ZAR:E6\";\n\nstring constant ERR_MISMATCH_ARRAYS_LENGTH = \"ZAR:E7\";\nstring constant ERR_REPETITIVE_STATUS = \"ZAR:E8\";\n\nstring constant ERR_INVALID_ZACCOUNT_FLAG_POSITION = \"ZAR:E9\";\nstring constant ERR_TOO_LARGE_LEAF_INPUTS = \"ZAR:E10\";\n\nstring constant ERR_INVALID_EXTRA_INPUT_HASH = \"ZAR:E11\";\nstring constant ERR_UNEXPECTED_ZKP_AMOUNT = \"ZAR:E12\";\nstring constant ERR_UNEXPECTED_PRP_AMOUNT = \"ZAR:E13\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"ZAR:E14\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"ZAR:E15\";\n"
    },
    "contracts/protocol/interfaces/IBusTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IBusTree {\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue);\n}\n"
    },
    "contracts/protocol/interfaces/IOnboardingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\n\ninterface IOnboardingController {\n    function grantRewards(\n        address _user,\n        uint8 prevStatus,\n        uint8 newStatus,\n        bytes memory _data\n    ) external returns (uint256 _userZkpRewardAlloc);\n}\n"
    },
    "contracts/protocol/interfaces/IPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IPantherPoolV1 {\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256);\n\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/mocks/MockZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../ZAccountsRegistry.sol\";\n\ncontract MockZAccountsRegistry is ZAccountsRegistry {\n    uint256 public nextId;\n\n    constructor(\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingRewardController\n    )\n        ZAccountsRegistry(\n            msg.sender,\n            _zAccountVersion,\n            pantherPool,\n            pantherStaticTree,\n            onboardingRewardController\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    function mockZAccountIdTracker(uint256 _zAccountIdTracker) external {\n        zAccountIdTracker = _zAccountIdTracker;\n    }\n\n    function internalGetNextZAccountId() external {\n        nextId = _getNextZAccountId();\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/cachedRoots/CachedRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../../errMsgs/CachedRootsErrMsgs.sol\";\n\n/// @dev It caches roots in a ring buffer and checks if a root is in the cache\nabstract contract CachedRoots {\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // Must be a power of 2\n    uint256 private constant CACHE_SIZE = 2**8;\n    uint256 private constant CACHE_INDEX_MASK = CACHE_SIZE - 1;\n\n    uint256 public constant UNDEFINED_CACHE_INDEX = 0xFFFF;\n    // solhint-enable var-name-mixedcase\n\n    // Initial value of all storage params is 0.\n    // So, no initialization in `constructor` required.\n\n    /// @dev Mapping from cache \"index\" to cached root value\n    mapping(uint256 => bytes32) private _cachedRoots;\n    // Total number of roots cached so far\n    uint64 private _cachedRootsCounter;\n    // Value of _cachedRootsCounter after the latest cache reset\n    uint64 private _cacheStartPos;\n\n    function getCacheStats()\n        external\n        view\n        returns (uint256 numRootsCached, uint256 latestCacheIndex)\n    {\n        uint256 nextInd = _getCacheNextIndex(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n        require(nextInd != 0, ERR_EMPTY_CACHE);\n\n        latestCacheIndex = --nextInd;\n        numRootsCached = _getCachedRootsNum(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n    }\n\n    function isCachedRoot(bytes32 root, uint256 cacheIndex)\n        public\n        view\n        returns (bool isCached)\n    {\n        uint256 nextPos = _cachedRootsCounter;\n        // Definitely NOT in the cache, if no roots have been cached yet\n        if (nextPos == 0) return false;\n\n        isCached = false;\n        uint256 startPos = _cacheStartPos;\n        uint256 rootsNum = _getCachedRootsNum(nextPos, startPos);\n\n        if (cacheIndex == UNDEFINED_CACHE_INDEX) {\n            // Iterate through cached roots, starting from the newest one\n            uint256 endPos = nextPos - rootsNum;\n            while (!isCached && nextPos > endPos) {\n                unchecked {\n                    nextPos--;\n                }\n                if (\n                    _cachedRoots[_getCacheNextIndex(nextPos, startPos)] == root\n                ) {\n                    isCached = true;\n                }\n            }\n        } else {\n            // Check against the value cached at the given index\n            require(cacheIndex < rootsNum, ERR_INDEX_NOT_IN_RANGE);\n            isCached = _cachedRoots[cacheIndex] == root;\n        }\n    }\n\n    function cacheNewRoot(bytes32 root) internal returns (uint256 cacheIndex) {\n        cacheIndex = _addRootToCache(root);\n    }\n\n    function resetThenCacheNewRoot(bytes32 root)\n        internal\n        returns (uint256 cacheIndex)\n    {\n        _cacheStartPos = _cachedRootsCounter;\n        cacheIndex = _addRootToCache(root);\n    }\n\n    /// Private functions follow\n\n    function _addRootToCache(bytes32 root)\n        private\n        returns (uint256 cacheIndex)\n    {\n        uint64 counter = _cachedRootsCounter;\n        uint64 startPos = _cacheStartPos;\n\n        cacheIndex = _getCacheNextIndex(counter, startPos);\n        _cachedRoots[cacheIndex] = root;\n\n        _cachedRootsCounter = ++counter;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCachedRootsNum(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 nSinceStart = counter - startPos;\n        return (nSinceStart > CACHE_SIZE) ? CACHE_SIZE : nSinceStart;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCacheNextIndex(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        return (counter - startPos) & CACHE_INDEX_MASK;\n    }\n\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private _trailingGap;\n}\n"
    },
    "contracts/protocol/pantherForest/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// `PantherForest` tree leafs indices (leafs store specific merkle trees roots)\nuint256 constant TAXI_TREE_FOREST_LEAF_INDEX = 0;\nuint256 constant BUS_TREE_FOREST_LEAF_INDEX = 1;\nuint256 constant FERRY_TREE_FOREST_LEAF_INDEX = 2;\nuint256 constant STATIC_TREE_FOREST_LEAF_INDEX = 3;\n\n// `PantherStaticTree` leafs indices (leafs store specific merkle trees roots)\nuint256 constant ZASSET_STATIC_LEAF_INDEX = 0;\nuint256 constant ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX = 1;\nuint256 constant ZNETWORK_STATIC_LEAF_INDEX = 2;\nuint256 constant ZZONE_STATIC_LEAF_INDEX = 3;\nuint256 constant PROVIDERS_KEYS_STATIC_LEAF_INDEX = 4;\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootGetter {\n    function getRoot() external view returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootUpdater {\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryUpdatableTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n// @notice The \"binary binary tree\" populated with zero leaf values\n\n/**\n * @title BinaryIncrementalUpdatableMerkleTree\n * @notice\n * @dev\n */\nabstract contract BinaryUpdatableTree {\n    /**\n     * @dev Update an existing leaf\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param newLeaf New leaf.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return _newRoot The new root after updating the tree\n     */\n    function update(\n        bytes32 curRoot,\n        bytes32 leaf,\n        bytes32 newLeaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bytes32 _newRoot) {\n        require(newLeaf != leaf, \"BIUT: New leaf cannot be equal the old one\");\n        require(\n            verify(curRoot, leaf, leafIndex, proofSiblings),\n            \"BIUT: Leaf is not part of the tree\"\n        );\n\n        _newRoot = newLeaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _newRoot = hash([_newRoot, proofSiblings[i]]);\n            } else {\n                _newRoot = hash([proofSiblings[i], _newRoot]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Verify if the path is correct and the leaf is part of the tree.\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return True or false.\n     */\n    function verify(\n        bytes32 curRoot,\n        bytes32 leaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bool) {\n        // equal to 2**proofSiblings.length\n        uint256 leavesNum = 1 << proofSiblings.length;\n        require(leafIndex < leavesNum, \"BIUT: invalid leaf index\");\n\n        bytes32 _hash = leaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _hash = hash([_hash, proofSiblings[i]]);\n            } else {\n                _hash = hash([proofSiblings[i], _hash]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return curRoot == 0 ? _hash == zeroRoot() : _hash == curRoot;\n    }\n\n    function zeroRoot() internal pure virtual returns (bytes32);\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/PantherForest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITreeRootGetter.sol\";\nimport \"./interfaces/ITreeRootUpdater.sol\";\n\nimport \"./cachedRoots/CachedRoots.sol\";\n\nimport \"../../common/ImmutableOwnable.sol\";\nimport \"../crypto/PoseidonHashers.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title PantherForest\n * @notice It stores and updates leafs and the root of the Panther Forest Tree.\n * @dev \"Panther Forest Tree\" is a merkle tree with a single level (leafs) under\n * the root. It has 4 leafs, which are roots of 4 other merkle trees -\n * the \"Taxi Tree\", the \"Bus Tree\", the \"Ferry Tree\" and the \"Static Tree\"\n * (essentially, these 4 trees are subtree of the Panther Forest tree):\n *\n *          Forest Root\n *               |\n *     +------+--+---+------+\n *     |      |      |      |\n *     0      1      2      3\n *   Taxi   Bus    Ferry  Static\n *   Tree   Tree   Tree   Tree\n *   root   root   root   root\n *\n * Every of 4 trees are controlled by \"tree\" smart contracts. A \"tree\" contract\n * must call this contract to update the value of the leaf and the root of the\n * Forest Tree every time the \"controlled\" tree is updated.\n * It supports a \"history\" of recent roots, so that users may refer not only to\n * the latest root, but on former roots cached in the history.\n */\nabstract contract PantherForest is\n    CachedRoots,\n    ImmutableOwnable,\n    ITreeRootGetter,\n    ITreeRootUpdater\n{\n    bytes32[10] private _startGap;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant NUM_LEAFS = 4;\n    uint256 private constant STATIC_TREE_LEAF = 3;\n\n    address public immutable TAXI_TREE_CONTROLLER;\n    address public immutable BUS_TREE_CONTROLLER;\n    address public immutable FERRY_TREE_CONTROLLER;\n    address public immutable STATIC_TREE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _forestRoot;\n\n    bytes32[NUM_LEAFS] public leafs;\n\n    event RootUpdated(\n        uint256 indexed leafIndex,\n        bytes32 updatedLeaf,\n        bytes32 updatedRoot,\n        uint256 cacheIndex\n    );\n\n    bytes32[10] private _endGap;\n\n    constructor(\n        address _owner,\n        address _taxiTreeController,\n        address _busTreeController,\n        address _ferryTreeController,\n        address _staticTreeController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _taxiTreeController != address(0) &&\n                _busTreeController != address(0) &&\n                _ferryTreeController != address(0) &&\n                _staticTreeController != address(0),\n            \"init: zero address\"\n        );\n\n        TAXI_TREE_CONTROLLER = _taxiTreeController;\n        BUS_TREE_CONTROLLER = _busTreeController;\n        FERRY_TREE_CONTROLLER = _ferryTreeController;\n        STATIC_TREE_CONTROLLER = _staticTreeController;\n    }\n\n    function initialize() external onlyOwner {\n        require(_forestRoot == bytes32(0), \"PF: Already initialized\");\n\n        for (uint8 i; i < NUM_LEAFS; ) {\n            leafs[i] = ITreeRootGetter(_getLeafController(i)).getRoot();\n            unchecked {\n                ++i;\n            }\n        }\n\n        _forestRoot = hash(leafs);\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _forestRoot;\n    }\n\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external {\n        require(msg.sender == _getLeafController(leafIndex), \"unauthorized\");\n\n        leafs[leafIndex] = updatedLeaf;\n        bytes32 forestRoot = hash(leafs);\n        uint256 cacheIndex;\n        if (leafIndex == STATIC_TREE_LEAF) {\n            cacheIndex = resetThenCacheNewRoot(forestRoot);\n        } else {\n            cacheIndex = cacheNewRoot(forestRoot);\n        }\n\n        _forestRoot = forestRoot;\n        emit RootUpdated(leafIndex, updatedLeaf, forestRoot, cacheIndex);\n    }\n\n    function _getLeafController(uint256 leafIndex)\n        internal\n        view\n        returns (address leafController)\n    {\n        require(leafIndex < NUM_LEAFS, \"PF: INVALID_LEAF_IND\");\n        if (leafIndex == TAXI_TREE_FOREST_LEAF_INDEX)\n            leafController = TAXI_TREE_CONTROLLER;\n\n        if (leafIndex == BUS_TREE_FOREST_LEAF_INDEX)\n            leafController = BUS_TREE_CONTROLLER;\n\n        if (leafIndex == FERRY_TREE_FOREST_LEAF_INDEX)\n            leafController = FERRY_TREE_CONTROLLER;\n\n        if (leafIndex == STATIC_TREE_FOREST_LEAF_INDEX)\n            leafController = STATIC_TREE_CONTROLLER;\n    }\n\n    function hash(bytes32[NUM_LEAFS] memory _leafs)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT5(_leafs);\n    }\n}\n"
    },
    "contracts/protocol/pantherPool/TransactionNoteEmitter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/***\n * @dev Every MASP transaction is accompanied by the \"Transaction Note\" - data\n * needed to process the transaction (think of opening UTXOs), reconstruct user\n * operations history (think of \"wallet cold start\"), or send a private message\n * to a user in extraordinary cases (think of a \"subpoena\").\n * `PantherPool` smart contract publishes Transaction Notes as \"events\" (logs).\n * The Transaction Note contains one or a few \"messages\", which may be \"public\"\n * or \"private\".\n * Public messages contain publicly seen on-chain data. Smart contracts, rather\n * than user (the DApp), compose public messages.\n * As the name assumes, private messages contain private data, and user (DApp)\n * prepares and encrypts these messages to pass them to smart contracts.\n * Every private message is encrypted with the reading key of a receiver, who\n * may be a recipient af an UTXO, or the user that spends UTXOs (\"messages to\n * the future\"), or even a user not involved in spending/creating UTXOs.\n * Smart contracts don't parse private messages but rather copy private messages\n * \"as is\" into Transaction Notes.\n * Every message belongs to a certain \"message type\". The message type defines\n * the exact message length and the content.\n * For \"fixed-content\" messages, the message type defines all data fields - i.e.\n * data interpretation, formats/size, and the sequence the fields must follow in.\n * Data fields of the \"free-content\" are unspecified, unlike the content size.\n * Public messages always have fixed content. Private messages may have fixed or\n * free content.\n * For fixed-content private messages, the protocol specifies also the content\n * of the preimage and the cipher to apply.\n * Every MASP transaction belongs to one of a few \"transaction types\".\n * For every transaction type, the protocol specifies \"mandatory\" messages, which\n * MUST be included into the Transaction Note. Users (DApp) may append \"optional\"\n * messages to mandatory messages in the Transaction Note.\n * There is also a special \"void\" message w/o content. It MAY replace mandatory\n * message when on-chain data is undefined/irrelevant, if public knowledge that\n * data is missing/undefined/irrelevant does not leak privacy.\n */\nabstract contract TransactionNoteEmitter {\n    // @notice Transaction Note, emitted with every MASP transaction\n    event TransactionNote(uint8 txType, bytes content);\n\n    // **** `bytes content`\n\n    /* START of pseudo-code\n    bytes content = abi.packed(messages[0], ..., messages[numMessages - 1]);\n    numMessages = for_txType_num_of_mandatory_mssgs + num_of_opt_mssgs;\n\n    // For \"void\" message type:\n    bytes messages[i] = abi.packed(byte msgType);\n\n    // For messages of types other than \"void\":\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes[for_msgType_length] msgContainer\n    );\n\n    // Public fixed-content messages:\n    // Smart contract MUST compose `msgContainer` as defined by `msgType`\n    // (no `ephemeralKey` needed as data is publicly seen)\n    bytes msgContainer = avi.packed(<abi.packed on-chain data>)\n\n    // Private fixed-content messages:\n    // DApp MUST compose the `ciphertext` as defined by the `msgType`\n    bytes msgContainer = avi.packed(\n        bytes32(ephemeralKey),\n        bytes[for_msgType_ciphertext_length] ciphertext\n    )\n\n    // Private free-data messages:\n    // nBlocks - number of 16-byte blocks the `msgContent` occupies\n    require(nBlocks >= 1 && nBlocks =< 16)\n    msgType = 0x2F + nBlocks;\n    // DApp is not limited in composing (structuring) `msgContainer`\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes32(ephemeralKey),\n        bytes[nBlocks*16] msgContainer\n    )\n    END of pseudo-code */\n\n    // **** Transaction Types\n\n    // The range for `uint8 txType` divided into sub-ranges:\n    //  - 0x00 .. 0x1F allowed\n    //  - 0x20 .. 0xFF reserved (unused)\n\n    // solhint-disable var-name-mixedcase\n\n    uint8 internal constant TT_ZACCOUNT_ACTIVATION = 0x01;\n\n    // **** Message Types\n\n    // The range for `uint8 msgType` divided into sub-ranges:\n    //  - 0x00 - the \"void\" (empty) message\n    //  - 0x01 .. 0x2F for fixed-content private messages\n    //  - 0x30 .. 0x3F for free-content private messages\n    //  - 0x40 .. 0x5F reserved (unused)\n    //  - 0x60 .. 0x7F for fixed-content public messages\n    //  - 0x80 .. 0xFF reserved (unused)\n\n    // \"Void\" type messages contain just this single byte:\n    uint8 internal constant MT_VOID = 0x00;\n    // Length in bytes\n    uint256 internal constant LMT_VOID = 1;\n\n    // zAccount UTXO opening values:\n    uint8 internal constant MT_UTXO_ZACCOUNT = 0x06;\n    // `msgContainer` MUST include the following data:\n    // - bytes[64] cypherText\n    // Length in bytes (msgType, ephemeralKey, msgContainer)\n    uint256 internal constant LMT_UTXO_ZACCOUNT = 1 + 32 + 64;\n    // Preimage of `cipherText` MUST contain (512 bit):\n    // - random (256 bit)\n    // - networkId (6 bit)\n    // - zoneId (16 bit)\n    // - nonce (24 bit)\n    // - expiryTime (32 bit)\n    // - amountZkp (64 bit)\n    // - amountPrp (50 bit)\n    // - totalAmountPerTimePeriod (64 bit)\n\n    // Creation time of UTXO:\n    uint8 internal constant MT_UTXO_CREATE_TIME = 0x60;\n    // `msgContainer` MUST include the following data:\n    // - uint32 creationTime\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_CREATE_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_SPEND_TIME = 0x61;\n    // `msgContainer` MUST include the following data:\n    // - uint32 spendType\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_SPEND_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_BUSTREE_IDS = 0x62;\n    // `msgContainer` MUST include the following data:\n    // - bytes32 commitment\n    // - uint32 queueId\n    // - uint8 indexInQueue\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_BUSTREE_IDS = 1 + 37;\n\n    // solhint-enable var-name-mixedcase\n}\n"
    },
    "contracts/protocol/PantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023s Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IPantherVerifier.sol\";\nimport \"./interfaces/IBusTree.sol\";\nimport \"./../common/ImmutableOwnable.sol\";\nimport { LockData } from \"./../common/Types.sol\";\nimport \"./errMsgs/PantherPoolV1ErrMsgs.sol\";\nimport \"./pantherForest/PantherForest.sol\";\nimport \"./pantherPool/TransactionNoteEmitter.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\n\ncontract PantherPoolV1 is\n    PantherForest,\n    TransactionNoteEmitter,\n    IPantherPoolV1\n{\n    // initialGap - PantherForest slots - CachedRoots slots => 500 - 22 - 25\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[453] private __gap;\n\n    // solhint-disable var-name-mixedcase\n    IVault public immutable VAULT;\n    IBusTree public immutable BUS_TREE;\n    IPantherVerifier public immutable VERIFIER;\n    address public immutable ZACCOUNT_REGISTRY;\n    // solhint-enable var-name-mixedcase\n\n    mapping(address => bool) public vaultAssetUnlockers;\n\n    uint160 public zAccountRegistrationCircuitId;\n\n    constructor(\n        address _owner,\n        address taxiTree,\n        address busTree,\n        address ferryTree,\n        address staticTree,\n        address vault,\n        address zAccountRegistry,\n        address verifier\n    ) PantherForest(_owner, taxiTree, busTree, ferryTree, staticTree) {\n        require(\n            vault != address(0) &&\n                verifier != address(0) &&\n                zAccountRegistry != address(0),\n            ERR_INIT\n        );\n\n        VAULT = IVault(vault);\n        BUS_TREE = IBusTree(busTree);\n        VERIFIER = IPantherVerifier(verifier);\n        ZACCOUNT_REGISTRY = zAccountRegistry;\n    }\n\n    function updateVaultAssetUnlocker(address _unlocker, bool _status)\n        external\n        onlyOwner\n    {\n        vaultAssetUnlockers[_unlocker] = _status;\n    }\n\n    function updateZAccountRegistrationCircuitId(uint160 _circuitId)\n        external\n        onlyOwner\n    {\n        zAccountRegistrationCircuitId = _circuitId;\n    }\n\n    function unlockAssetFromVault(LockData calldata data) external {\n        require(vaultAssetUnlockers[msg.sender], ERR_UNAUTHORIZED);\n\n        // Trusted contract - no reentrancy guard needed\n        VAULT.unlockAsset(data);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot\n    /// @param inputs[13] - saltHash\n    /// @param inputs[14] - magicalConstraint\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory privateMessages,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        require(msg.sender == ZACCOUNT_REGISTRY, ERR_UNAUTHORIZED);\n        require(zAccountRegistrationCircuitId != 0, ERR_UNDEFINED_CIRCUIT);\n        {\n            uint256 zAccountNullifier = inputs[9];\n            require(zAccountNullifier != 0, ERR_ZERO_ZACCOUNT_NULLIFIER);\n        }\n        uint256 zAccountCommitment;\n        {\n            zAccountCommitment = inputs[10];\n            require(zAccountCommitment != 0, ERR_ZERO_ZACCOUNT_COMMIT);\n        }\n        {\n            uint256 kycSignedMessageHash = inputs[11];\n            require(kycSignedMessageHash != 0, ERR_ZERO_KYC_MSG_HASH);\n        }\n        {\n            uint256 saltHash = inputs[13];\n            require(saltHash != 0, ERR_ZERO_SALT_HASH);\n        }\n        {\n            uint256 magicalConstraint = inputs[14];\n            require(magicalConstraint != 0, ERR_ZERO_MAGIC_CONSTR);\n        }\n        require(\n            uint8(privateMessages[0]) == MT_UTXO_ZACCOUNT &&\n                privateMessages.length >= LMT_UTXO_ZACCOUNT,\n            ERR_NOT_WELLFORMED_SECRETS\n        );\n        // Must be less than 32 bits and NOT in the past\n        uint32 createTime = uint32(inputs[5]);\n        require(\n            uint256(createTime) == inputs[5] && createTime >= block.timestamp,\n            ERR_INVALID_CREATE_TIME\n        );\n\n        require(\n            isCachedRoot(bytes32(inputs[12]), cachedForestRootIndex),\n            ERR_INVALID_FOREST_ROOT\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        require(\n            VERIFIER.verify(zAccountRegistrationCircuitId, inputs, proof),\n            ERR_FAILED_ZK_PROOF\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        (uint32 queueId, uint8 indexInQueue) = BUS_TREE.addUtxoToBusQueue(\n            bytes32(zAccountCommitment)\n        );\n        utxoBusQueuePos = (uint256(queueId) << 8) | uint256(indexInQueue);\n\n        bytes memory transactionNoteContent = abi.encodePacked(\n            // First public message\n            MT_UTXO_CREATE_TIME,\n            createTime,\n            // Seconds public message\n            MT_UTXO_BUSTREE_IDS,\n            inputs[11], // zAccountCommitment\n            queueId,\n            indexInQueue,\n            // Private message(s)\n            privateMessages\n        );\n\n        emit TransactionNote(TT_ZACCOUNT_ACTIVATION, transactionNoteContent);\n    }\n}\n"
    },
    "contracts/protocol/ZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./interfaces/IOnboardingController.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\n\nimport \"./crypto/BabyJubJub.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\n\nimport \"./zAccountsRegistry/BlacklistedZAccountIdsTree.sol\";\nimport \"./zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/UtilsLib.sol\";\nimport { ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX } from \"./pantherForest/Constants.sol\";\n\n/**\n * @title ZAccountsRegistry\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of zAccounts allowed to interact with MASP.\n */\n\n// solhint-disable contract-name-camelcase\ncontract ZAccountsRegistry is\n    ImmutableOwnable,\n    BlacklistedZAccountIdsTree,\n    ZAccountsRegeistrationSignatureVerifier\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    enum ZACCOUNT_STATUS {\n        UNDEFINED,\n        REGISTERED,\n        ACTIVATED\n    }\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant ZACCOUNT_ID_COUNTER_JUMP = 2;\n\n    IPantherPoolV1 public immutable PANTHER_POOL;\n    ITreeRootUpdater public immutable PANTHER_STATIC_TREE;\n    IOnboardingController public immutable ONBOARDING_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    struct ZAccount {\n        uint224 _unused; // reserved\n        uint24 id; // the ZAccount id, starts from 0\n        uint8 version; // ZAccount version\n        bytes32 pubRootSpendingKey;\n        bytes32 pubReadingKey;\n    }\n\n    uint256 public zAccountIdTracker;\n\n    mapping(bytes32 => uint256) public zoneZAccountNullifiers;\n    mapping(address => ZACCOUNT_STATUS) public zAccountStatus;\n    mapping(address => bool) public isMasterEoaBlacklisted;\n    mapping(bytes32 => bool) public isPubRootSpendingKeyBlacklisted;\n    mapping(uint24 => bool) public isZAccountIdBlacklisted;\n\n    // Mapping from `MasterEoa` to ZAccount (i.e. params of an ZAccount)\n    mapping(address => ZAccount) public zAccounts;\n\n    // Mapping from zAccount Id to Master Eoa\n    mapping(uint24 => address) public masterEOAs;\n\n    event ZAccountRegistered(address masterEoa, ZAccount zAccount);\n    event ZAccountActivated(uint24 id);\n    event BlacklistForZAccountIdUpdated(uint24 zAccountId, bool isBlackListed);\n    event BlacklistForMasterEoaUpdated(address masterEoa, bool isBlackListed);\n    event BlacklistForPubRootSpendingKeyUpdated(\n        bytes32 packedPubRootSpendingKey,\n        bool isBlackListed\n    );\n\n    constructor(\n        address _owner,\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingController\n    )\n        ImmutableOwnable(_owner)\n        ZAccountsRegeistrationSignatureVerifier(_zAccountVersion)\n    {\n        require(\n            pantherPool != address(0) &&\n                pantherStaticTree != address(0) &&\n                onboardingController != address(0),\n            ERR_INIT_CONTRACT\n        );\n\n        PANTHER_POOL = IPantherPoolV1(pantherPool);\n        PANTHER_STATIC_TREE = ITreeRootUpdater(pantherStaticTree);\n        ONBOARDING_CONTROLLER = IOnboardingController(onboardingController);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function isZAccountWhitelisted(address _masterEOA)\n        external\n        view\n        returns (bool isWhitelisted)\n    {\n        ZAccount memory _zAccount = zAccounts[_masterEOA];\n\n        bool isZAccountExists = masterEOAs[_zAccount.id] != address(0);\n\n        (bool isBlacklisted, ) = _isBlacklisted(\n            _zAccount.id,\n            _masterEOA,\n            _zAccount.pubRootSpendingKey\n        );\n\n        return isZAccountExists && !isBlacklisted;\n    }\n\n    /* ========== EXTERNAL FUNCTIONS ========== */\n\n    function registerZAccount(\n        G1Point memory _pubRootSpendingKey,\n        G1Point memory _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 pubRootSpendingKeyPacked = BabyJubJub.pointPack(\n            _pubRootSpendingKey\n        );\n        bytes32 pubReadingKeyPacked = BabyJubJub.pointPack(_pubReadingKey);\n\n        require(\n            !isPubRootSpendingKeyBlacklisted[pubRootSpendingKeyPacked],\n            ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n        );\n\n        address masterEoa = recoverMasterEoa(\n            pubRootSpendingKeyPacked,\n            pubReadingKeyPacked,\n            v,\n            r,\n            s\n        );\n\n        require(!isMasterEoaBlacklisted[masterEoa], ERR_BLACKLIST_MASTER_EOA);\n        require(\n            zAccountStatus[masterEoa] == ZACCOUNT_STATUS.UNDEFINED,\n            ERR_DUPLICATED_MASTER_EOA\n        );\n\n        uint24 zAccountId = uint24(_getNextZAccountId());\n\n        ZAccount memory _zAccount = ZAccount({\n            _unused: uint224(0),\n            id: zAccountId,\n            version: uint8(ZACCOUNT_VERSION),\n            pubRootSpendingKey: pubRootSpendingKeyPacked,\n            pubReadingKey: pubReadingKeyPacked\n        });\n\n        masterEOAs[zAccountId] = masterEoa;\n        zAccounts[masterEoa] = _zAccount;\n        zAccountStatus[masterEoa] = ZACCOUNT_STATUS.REGISTERED;\n\n        emit ZAccountRegistered(masterEoa, _zAccount);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange (passed w/o checks)\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime (passed w/o checks)\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot (passed w/o checks)\n    /// @param inputs[13] - saltHash (passed w/o checks)\n    /// @param inputs[14] - magicalConstraint (passed w/o checks)\n    function activateZAccount(\n        uint256[] calldata inputs,\n        bytes memory privateMessages,\n        SnarkProof calldata proof,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        {\n            uint256 extraInputsHash = inputs[0];\n            bytes memory extraInp = abi.encodePacked(\n                privateMessages,\n                cachedForestRootIndex\n            );\n            require(\n                extraInputsHash == uint256(keccak256(extraInp)) % FIELD_SIZE,\n                ERR_INVALID_EXTRA_INPUT_HASH\n            );\n        }\n        {\n            uint256 zAccountPrpAmount = inputs[4];\n            // No PRP rewards provided on zAccount activation\n            require(zAccountPrpAmount == 0, ERR_UNEXPECTED_PRP_AMOUNT);\n        }\n\n        uint24 zAccountId = UtilsLib.safe24(inputs[3]);\n        address zAccountMasterEOA = address(uint160(inputs[8]));\n\n        require(\n            masterEOAs[zAccountId] == zAccountMasterEOA,\n            ERR_UNKNOWN_ZACCOUNT\n        );\n\n        {\n            bytes32 zAccountRootSpendPubKey = BabyJubJub.pointPack(\n                G1Point({ x: inputs[6], y: inputs[7] })\n            );\n            (bool isBlacklisted, string memory errMsg) = _isBlacklisted(\n                zAccountId,\n                zAccountMasterEOA,\n                zAccountRootSpendPubKey\n            );\n            require(!isBlacklisted, errMsg);\n        }\n        {\n            // Prevent double-activation for the same zone and network\n            bytes32 zAccountNullifier = bytes32(inputs[9]);\n            require(\n                zoneZAccountNullifiers[zAccountNullifier] == 0,\n                ERR_DUPLICATED_NULLIFIER\n            );\n\n            zoneZAccountNullifiers[zAccountNullifier] = block.number;\n        }\n\n        ZACCOUNT_STATUS userPrevStatus = zAccountStatus[zAccountMasterEOA];\n\n        // if the status is registered, then change it to activate.\n        // If status is already activated, it means  Zaccount is activated at least in 1 zone.\n        if (userPrevStatus == ZACCOUNT_STATUS.REGISTERED) {\n            zAccountStatus[zAccountMasterEOA] = ZACCOUNT_STATUS.ACTIVATED;\n        }\n\n        {\n            uint256 _zkpRewards = _notifyOnboardingController(\n                zAccountMasterEOA,\n                uint8(userPrevStatus),\n                uint8(ZACCOUNT_STATUS.ACTIVATED),\n                new bytes(0)\n            );\n            uint256 zkpAmount = inputs[1];\n            require(_zkpRewards == zkpAmount, ERR_UNEXPECTED_ZKP_AMOUNT);\n        }\n\n        utxoBusQueuePos = _createZAccountUTXO(\n            inputs,\n            proof,\n            privateMessages,\n            cachedForestRootIndex\n        );\n\n        emit ZAccountActivated(zAccountId);\n    }\n\n    // /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    function batchUpdateBlacklistForMasterEoa(\n        address[] calldata masterEoas,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            masterEoas.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < masterEoas.length; ) {\n            require(\n                isMasterEoaBlacklisted[masterEoas[i]] != isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isMasterEoaBlacklisted[masterEoas[i]] = isBlackListed[i];\n\n            emit BlacklistForMasterEoaUpdated(masterEoas[i], isBlackListed[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function batchUpdateBlacklistForPubRootSpendingKey(\n        bytes32[] calldata packedPubRootSpendingKeys,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            packedPubRootSpendingKeys.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < packedPubRootSpendingKeys.length; ) {\n            require(\n                isPubRootSpendingKeyBlacklisted[packedPubRootSpendingKeys[i]] !=\n                    isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isPubRootSpendingKeyBlacklisted[\n                packedPubRootSpendingKeys[i]\n            ] = isBlackListed[i];\n\n            emit BlacklistForPubRootSpendingKeyUpdated(\n                packedPubRootSpendingKeys[i],\n                isBlackListed[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateBlacklistForZAccountId(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] calldata proofSiblings,\n        bool isBlacklisted\n    ) public onlyOwner {\n        require(masterEOAs[zAccountId] != address(0), ERR_UNKNOWN_ZACCOUNT);\n        require(\n            isZAccountIdBlacklisted[zAccountId] != isBlacklisted,\n            ERR_REPETITIVE_STATUS\n        );\n\n        bytes32 blacklistedZAccountIdsTreeRoot;\n\n        if (isBlacklisted) {\n            blacklistedZAccountIdsTreeRoot = _addZAccountIdToBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        } else {\n            blacklistedZAccountIdsTreeRoot = _removeZAccountIdFromBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        }\n\n        isZAccountIdBlacklisted[zAccountId] = isBlacklisted;\n\n        // Trusted contract - no reentrancy guard needed\n        PANTHER_STATIC_TREE.updateRoot(\n            blacklistedZAccountIdsTreeRoot,\n            ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX\n        );\n\n        emit BlacklistForZAccountIdUpdated(zAccountId, isBlacklisted);\n    }\n\n    // /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _getNextZAccountId() internal returns (uint256 curId) {\n        curId = zAccountIdTracker;\n        zAccountIdTracker = curId & 0xFF < 254\n            ? curId + 1\n            : curId + ZACCOUNT_ID_COUNTER_JUMP;\n    }\n\n    function _createZAccountUTXO(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory privateMessages,\n        uint256 cachedForestRootIndex\n    ) private returns (uint256 utxoBusQueuePos) {\n        utxoBusQueuePos = 0;\n        // Pool is supposed to revert in case of any error\n        try\n            // Trusted contract - no reentrancy guard needed\n            PANTHER_POOL.createZAccountUtxo(\n                inputs,\n                proof,\n                privateMessages,\n                cachedForestRootIndex\n            )\n        returns (uint256 result) {\n            utxoBusQueuePos = result;\n        } catch Error(string memory reason) {\n            revert(reason);\n        }\n    }\n\n    function _notifyOnboardingController(\n        address _user,\n        uint8 _prevStatus,\n        uint8 _newStatus,\n        bytes memory _data\n    ) private returns (uint256 _zkpRewards) {\n        // Trusted contract - no reentrancy guard needed\n        _zkpRewards = ONBOARDING_CONTROLLER.grantRewards(\n            _user,\n            _prevStatus,\n            _newStatus,\n            _data\n        );\n    }\n\n    function _isBlacklisted(\n        uint24 id,\n        address _masterEOA,\n        bytes32 pubRootSpendingKey\n    ) private view returns (bool isBlaklisted, string memory err) {\n        if (isZAccountIdBlacklisted[id]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_ZACCOUNT_ID);\n        }\n        if (isMasterEoaBlacklisted[_masterEOA]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_MASTER_EOA);\n        }\n        if (isPubRootSpendingKeyBlacklisted[pubRootSpendingKey]) {\n            err = _formatBlackListError(\n                err,\n                ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n            );\n        }\n\n        return (isBlaklisted = bytes(err).length > 0 ? true : false, err);\n    }\n\n    function _formatBlackListError(\n        string memory currentErrMsg,\n        string memory errToBeAdded\n    ) private pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(currentErrMsg).length > 0\n                        ? string(abi.encodePacked(currentErrMsg, \",\"))\n                        : \"\",\n                    errToBeAdded\n                )\n            );\n    }\n\n    /// @dev Concatenate the strings together and returns the result\n    function formatBlackListError(\n        string memory content,\n        string memory contentToBeAdded,\n        string memory separator\n    ) internal pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(content).length > 0\n                        ? string(abi.encodePacked(content, separator))\n                        : \"\",\n                    contentToBeAdded\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/BlacklistedZAccountIdsTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../pantherForest/interfaces/ITreeRootGetter.sol\";\n\nimport \"../pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport \"../errMsgs/ZAccountsRegistryErrMsgs.sol\";\n\nimport \"../crypto/PoseidonHashers.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract BlacklistedZAccountIdsTree is\n    BinaryUpdatableTree,\n    ITreeRootGetter\n{\n    // The current root of merkle tree.\n    // If it's undefined, the `zeroRoot()` shall be called.\n    bytes32 private _currentRoot;\n\n    function getRoot() external view returns (bytes32) {\n        return _currentRoot == bytes32(0) ? zeroRoot() : _currentRoot;\n    }\n\n    function _getZAccountFlagAndLeafIndexes(uint24 zAccountId)\n        internal\n        pure\n        returns (uint256 flagIndex, uint256 leafIndex)\n    {\n        // getting index which is between 0 and 253\n        flagIndex = zAccountId & 0xFF;\n\n        require(\n            flagIndex >= 0 && flagIndex < 254,\n            ERR_INVALID_ZACCOUNT_FLAG_POSITION\n        );\n\n        // getting the 16 MSB from uint24\n        leafIndex = zAccountId >> 8;\n    }\n\n    function _addZAccountIdToBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) | (1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function _removeZAccountIdFromBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) & ~(1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3(input);\n    }\n\n    //@dev returns the root of tree with depth 16 where each leaf is 0\n    function zeroRoot() internal pure override returns (bytes32) {\n        /**\n        '0x0000000000000000000000000000000000000000000000000000000000000000'   Level 0\n        '0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864'   Level 1\n        '0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1'   Level 2\n        '0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238'   Level 3\n        '0x07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a'   Level 4\n        '0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55'   Level 5\n        '0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78'   Level 6\n        '0x078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d'   Level 7\n        '0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61'   Level 8\n        '0x0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747'   Level 9\n        '0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2'   Level 10\n        '0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636'   Level 11\n        '0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a'   Level 12\n        '0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0'   Level 13\n        '0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c'   Level 14\n        '0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92'   Level 15\n         */\n        return\n            bytes32(\n                uint256(\n                    0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../../common/EIP712SignatureVerifier.sol\";\n\nabstract contract ZAccountsRegeistrationSignatureVerifier is\n    EIP712SignatureVerifier\n{\n    // solhint-disable var-name-mixedcase\n\n    bytes32 internal constant REGISTRATION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"Registration(bytes32 pubRootSpendingKey,bytes32 pubReadingKey,uint256 version)\"\n            )\n        );\n\n    uint8 public immutable ZACCOUNT_VERSION;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(uint8 zAccountVersion) {\n        ZACCOUNT_VERSION = zAccountVersion;\n    }\n\n    function getRegistrationDataHash(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    REGISTRATION_TYPEHASH,\n                    _pubRootSpendingKey,\n                    _pubReadingKey,\n                    uint256(ZACCOUNT_VERSION)\n                )\n            );\n    }\n\n    function recoverMasterEoa(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 registrationDataHash = getRegistrationDataHash(\n            _pubRootSpendingKey,\n            _pubReadingKey\n        );\n\n        bytes32 typedDataHash = toTypedDataHash(registrationDataHash);\n\n        return recover(typedDataHash, v, r, s);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}