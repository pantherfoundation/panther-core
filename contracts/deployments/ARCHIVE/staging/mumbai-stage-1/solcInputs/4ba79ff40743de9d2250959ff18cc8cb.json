{
  "language": "Solidity",
  "sources": {
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/PoseidonHashers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\nimport \"./Poseidon.sol\";\n\nlibrary PoseidonHashers {\n    string private constant ERR_INPUT_NOT_IN_FIELD =\n        \"PoseidonHasher: input not in field\";\n\n    function poseidonT3(bytes32[2] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE && uint256(input[1]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT3.poseidon(input);\n    }\n\n    function poseidonT4(bytes32[3] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT4.poseidon(input);\n    }\n\n    function poseidonT5(bytes32[4] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT5.poseidon(input);\n    }\n\n    function poseidonT6(bytes32[5] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE &&\n                uint256(input[4]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT6.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// FIXME: make MAGICAL_CONSTRAINT the public input (var, not const) - it MUST have random value on every invocation\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/errMsgs/CachedRootsErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_EMPTY_CACHE = \"CR:E1\";\nstring constant ERR_INDEX_NOT_IN_RANGE = \"CR:E2\";\n"
    },
    "contracts/protocol/errMsgs/PantherBusTreeErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"PBT:E1\";\nstring constant ERR_UNAUTHORIZED = \"PBT:E2\";\nstring constant ERR_ZERO_REWARD_PARAMS = \"PBT:E3\";\n"
    },
    "contracts/protocol/errMsgs/PantherPoolV1ErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT = \"PP:E1\";\nstring constant ERR_UNAUTHORIZED = \"PP:E2\";\nstring constant ERR_UNDEFINED_CIRCUIT = \"PP:E3\";\nstring constant ERR_INVALID_FOREST_ROOT = \"PP:E4\";\nstring constant ERR_FAILED_ZK_PROOF = \"PP:E5\";\nstring constant ERR_INVALID_CREATE_TIME = \"PP:E6\";\nstring constant ERR_ZERO_ZACCOUNT_NULLIFIER = \"PP:E7\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"PP:E8\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"PP:E9\";\nstring constant ERR_ZERO_SALT_HASH = \"PP:E10\";\nstring constant ERR_ZERO_MAGIC_CONSTR = \"PP:E11\";\nstring constant ERR_NOT_WELLFORMED_SECRETS = \"PP:E12\";\n"
    },
    "contracts/protocol/interfaces/IBusTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface IBusTree {\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue);\n}\n"
    },
    "contracts/protocol/interfaces/IPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IPantherPoolV1 {\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256);\n\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/PantherBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IPantherPoolV1.sol\";\n\nimport \"./pantherForest/busTree/BusTree.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\nimport { ERC20_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\nimport \"./errMsgs/PantherBusTreeErrMsgs.sol\";\n\ncontract PantherBusTree is BusTree, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address _pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId, _pantherPool) {\n        require(rewardToken != address(0), ERR_INIT);\n\n        START_TIME = block.timestamp;\n\n        REWARD_TOKEN = rewardToken;\n    }\n\n    // TODO: Remove _perMinuteUtxosLimit after Testnet (required for Stage #0..2 only)\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate, minEmptyQueueAge);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            ERR_ZERO_REWARD_PARAMS\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3([left, right]);\n    }\n\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue)\n    {\n        require(msg.sender == PANTHER_POOL, ERR_UNAUTHORIZED);\n\n        bytes32[] memory utxos = new bytes32[](1);\n        utxos[0] = utxo;\n\n        queueId = _nextQueueId == 0 ? 0 : _nextQueueId - 1;\n        BusQueue memory busQueue = _busQueues[queueId];\n        indexInQueue = busQueue.nUtxos;\n\n        addUtxosToBusQueue(utxos, uint96(basePerUtxoReward));\n    }\n\n    // TODO: Remove simulateAddUtxosToBusQueue after Testnet (required for Stage #0..2 only)\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxosToBusQueue(utxos, uint96(reward));\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint40 remainingBlocks;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) internal _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 internal _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Minimum number of blocks an empty queue must pend processing.\n    uint16 private _minEmptyQueueAge;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate,\n        uint256 minEmptyQueueAge\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums or queue age limit, the `updateParams` call needed.\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    // @return minEmptyQueueAge Min number of blocks an empty queue must pend\n    // processing. For a partially filled queue, it declines linearly with the\n    // number of queue's UTXOs. Full queues are immediately processable.\n    function getParams()\n        external\n        view\n        returns (\n            uint16 reservationRate,\n            uint16 premiumRate,\n            uint16 minEmptyQueueAge\n        )\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n        minEmptyQueueAge = _minEmptyQueueAge;\n    }\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _getQueueRemainingBlocks(q),\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // @param maxLength Maximum number of queues to return\n    // @return queues Queues pending processing, starting from the oldest one\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].remainingBlocks = _getQueueRemainingBlocks(queue);\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    // @dev Refer to return values of the `getParam` function\n    function updateParams(\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        _minEmptyQueueAge = minEmptyQueueAge;\n        emit BusQueueRewardParamsUpdated(\n            reservationRate,\n            premiumRate,\n            minEmptyQueueAge\n        );\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        internal\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        require(_getQueueRemainingBlocks(queue) == 0, \"BQT:IMMATURE_QUEUE\");\n\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    // Returns the number of blocks to wait until a queue may be processed.\n    // Always returns 0 for a fully populated queue (immediately processable).\n    // For an empty queue it returns a meaningless value.\n    function _getQueueRemainingBlocks(BusQueue memory queue)\n        private\n        view\n        returns (uint40)\n    {\n        if (queue.nUtxos >= QUEUE_MAX_SIZE) return 0;\n\n        // Minimum \"age\" declines linearly to the number of UTXOs in the queue\n        uint256 nEmptySeats = uint256(QUEUE_MAX_SIZE - queue.nUtxos);\n        uint256 minAge = (nEmptySeats * _minEmptyQueueAge) / QUEUE_MAX_SIZE;\n\n        uint256 maturityBlock = minAge + queue.firstUtxoBlock;\n        return\n            block.number >= maturityBlock\n                ? 0 // Overflow risk ignored\n                : uint40(maturityBlock - block.number);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\n// TODO: remove MAGICAL_CONSTRAINT as a constant and make it a pub input var\nimport { BUS_TREE_FOREST_LEAF_INDEX } from \"../Constants.sol\";\nimport { MAGICAL_CONSTRAINT } from \"../../crypto/SnarkConstants.sol\";\nimport \"../interfaces/ITreeRootUpdater.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n */\nabstract contract BusTree is BusQueues, ITreeRootGetter {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    bytes32 internal constant EMPTY_BUS_TREE_ROOT =\n        TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT;\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(\n        address _verifier,\n        uint160 _circuitId,\n        address _pantherPool\n    ) {\n        require(_pantherPool != address(0), \"init: zero address\");\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            \"BT:INVALID_VK\"\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function getRoot` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n\n        PANTHER_POOL = _pantherPool;\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return _busTreeRoot == bytes32(0) ? EMPTY_BUS_TREE_ROOT : _busTreeRoot;\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        bytes32 busTreeNewRoot,\n        bytes32 batchRoot,\n        bytes32 busBranchNewRoot,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        uint32 nBatches = _numBatchesInBusTree;\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n\n        // Circuit public input signals\n        uint256[] memory input = new uint256[](9);\n        // `oldRoot` signal\n        input[0] = uint256(getRoot());\n        // `newRoot` signal\n        input[1] = uint256(busTreeNewRoot);\n        // `replacedNodeIndex` signal\n        input[2] = nBatches;\n        // `newLeafsCommitment` signal\n        input[3] = uint256(commitment);\n        // `nNonEmptyNewLeafs` signal\n        input[4] = uint256(nUtxos);\n        // `batchRoot` signal\n        input[5] = uint256(batchRoot);\n        // `branchRoot` signal\n        input[6] = uint256(busBranchNewRoot);\n        // `extraInput` signal (front-run protection)\n        input[7] = uint256(uint160(miner));\n        // magicalConstraint\n        input[8] = MAGICAL_CONSTRAINT;\n\n        // Verify the proof\n        require(VERIFIER.verify(CIRCUIT_ID, input, proof), \"BT:FAILED_PROOF\");\n\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        ITreeRootUpdater(PANTHER_POOL).updateRoot(\n            busTreeNewRoot,\n            BUS_TREE_FOREST_LEAF_INDEX\n        );\n\n        // Store updated Bus Tree params\n        _busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/cachedRoots/CachedRoots.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../../errMsgs/CachedRootsErrMsgs.sol\";\n\n/// @dev It caches roots in a ring buffer and checks if a root is in the cache\nabstract contract CachedRoots {\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // Must be a power of 2\n    uint256 private constant CACHE_SIZE = 2**8;\n    uint256 private constant CACHE_INDEX_MASK = CACHE_SIZE - 1;\n\n    uint256 public constant UNDEFINED_CACHE_INDEX = 0xFFFF;\n    // solhint-enable var-name-mixedcase\n\n    // Initial value of all storage params is 0.\n    // So, no initialization in `constructor` required.\n\n    /// @dev Mapping from cache \"index\" to cached root value\n    mapping(uint256 => bytes32) private _cachedRoots;\n    // Total number of roots cached so far\n    uint64 private _cachedRootsCounter;\n    // Value of _cachedRootsCounter after the latest cache reset\n    uint64 private _cacheStartPos;\n\n    function getCacheStats()\n        external\n        view\n        returns (uint256 numRootsCached, uint256 latestCacheIndex)\n    {\n        uint256 nextInd = _getCacheNextIndex(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n        require(nextInd != 0, ERR_EMPTY_CACHE);\n\n        latestCacheIndex = --nextInd;\n        numRootsCached = _getCachedRootsNum(\n            _cachedRootsCounter,\n            _cacheStartPos\n        );\n    }\n\n    function isCachedRoot(bytes32 root, uint256 cacheIndex)\n        public\n        view\n        returns (bool isCached)\n    {\n        uint256 nextPos = _cachedRootsCounter;\n        // Definitely NOT in the cache, if no roots have been cached yet\n        if (nextPos == 0) return false;\n\n        isCached = false;\n        uint256 startPos = _cacheStartPos;\n        uint256 rootsNum = _getCachedRootsNum(nextPos, startPos);\n\n        if (cacheIndex == UNDEFINED_CACHE_INDEX) {\n            // Iterate through cached roots, starting from the newest one\n            uint256 endPos = nextPos - rootsNum;\n            while (!isCached && nextPos > endPos) {\n                unchecked {\n                    nextPos--;\n                }\n                if (\n                    _cachedRoots[_getCacheNextIndex(nextPos, startPos)] == root\n                ) {\n                    isCached = true;\n                }\n            }\n        } else {\n            // Check against the value cached at the given index\n            require(cacheIndex < rootsNum, ERR_INDEX_NOT_IN_RANGE);\n            isCached = _cachedRoots[cacheIndex] == root;\n        }\n    }\n\n    function cacheNewRoot(bytes32 root) internal returns (uint256 cacheIndex) {\n        cacheIndex = _addRootToCache(root);\n    }\n\n    function resetThenCacheNewRoot(bytes32 root)\n        internal\n        returns (uint256 cacheIndex)\n    {\n        _cacheStartPos = _cachedRootsCounter;\n        cacheIndex = _addRootToCache(root);\n    }\n\n    /// Private functions follow\n\n    function _addRootToCache(bytes32 root)\n        private\n        returns (uint256 cacheIndex)\n    {\n        uint64 counter = _cachedRootsCounter;\n        uint64 startPos = _cacheStartPos;\n\n        cacheIndex = _getCacheNextIndex(counter, startPos);\n        _cachedRoots[cacheIndex] = root;\n\n        _cachedRootsCounter = ++counter;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCachedRootsNum(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 nSinceStart = counter - startPos;\n        return (nSinceStart > CACHE_SIZE) ? CACHE_SIZE : nSinceStart;\n    }\n\n    // Calling code MUST ensure `counter >= startPos`\n    function _getCacheNextIndex(uint256 counter, uint256 startPos)\n        private\n        pure\n        returns (uint256)\n    {\n        return (counter - startPos) & CACHE_INDEX_MASK;\n    }\n\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[10] private _trailingGap;\n}\n"
    },
    "contracts/protocol/pantherForest/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// `PantherForest` tree leafs indices (leafs store specific merkle trees roots)\nuint256 constant TAXI_TREE_FOREST_LEAF_INDEX = 0;\nuint256 constant BUS_TREE_FOREST_LEAF_INDEX = 1;\nuint256 constant FERRY_TREE_FOREST_LEAF_INDEX = 2;\nuint256 constant STATIC_TREE_FOREST_LEAF_INDEX = 3;\n\n// `PantherStaticTree` leafs indices (leafs store specific merkle trees roots)\nuint256 constant ZASSET_STATIC_LEAF_INDEX = 0;\nuint256 constant ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX = 1;\nuint256 constant ZNETWORK_STATIC_LEAF_INDEX = 2;\nuint256 constant ZZONE_STATIC_LEAF_INDEX = 3;\nuint256 constant PROVIDERS_KEYS_STATIC_LEAF_INDEX = 4;\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootGetter {\n    function getRoot() external view returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootUpdater {\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/PantherForest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/ITreeRootGetter.sol\";\nimport \"./interfaces/ITreeRootUpdater.sol\";\n\nimport \"./cachedRoots/CachedRoots.sol\";\n\nimport \"../../common/ImmutableOwnable.sol\";\nimport \"../crypto/PoseidonHashers.sol\";\nimport \"./Constants.sol\";\n\n/**\n * @title PantherForest\n * @notice It stores and updates leafs and the root of the Panther Forest Tree.\n * @dev \"Panther Forest Tree\" is a merkle tree with a single level (leafs) under\n * the root. It has 4 leafs, which are roots of 4 other merkle trees -\n * the \"Taxi Tree\", the \"Bus Tree\", the \"Ferry Tree\" and the \"Static Tree\"\n * (essentially, these 4 trees are subtree of the Panther Forest tree):\n *\n *          Forest Root\n *               |\n *     +------+--+---+------+\n *     |      |      |      |\n *     0      1      2      3\n *   Taxi   Bus    Ferry  Static\n *   Tree   Tree   Tree   Tree\n *   root   root   root   root\n *\n * Every of 4 trees are controlled by \"tree\" smart contracts. A \"tree\" contract\n * must call this contract to update the value of the leaf and the root of the\n * Forest Tree every time the \"controlled\" tree is updated.\n * It supports a \"history\" of recent roots, so that users may refer not only to\n * the latest root, but on former roots cached in the history.\n */\nabstract contract PantherForest is\n    CachedRoots,\n    ImmutableOwnable,\n    ITreeRootGetter,\n    ITreeRootUpdater\n{\n    bytes32[10] private _startGap;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant NUM_LEAFS = 4;\n    uint256 private constant STATIC_TREE_LEAF = 3;\n\n    address public immutable TAXI_TREE_CONTROLLER;\n    address public immutable BUS_TREE_CONTROLLER;\n    address public immutable FERRY_TREE_CONTROLLER;\n    address public immutable STATIC_TREE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _forestRoot;\n\n    bytes32[NUM_LEAFS] public leafs;\n\n    event RootUpdated(\n        uint256 indexed leafIndex,\n        bytes32 updatedLeaf,\n        bytes32 updatedRoot,\n        uint256 cacheIndex\n    );\n\n    bytes32[10] private _endGap;\n\n    constructor(\n        address _owner,\n        address _taxiTreeController,\n        address _busTreeController,\n        address _ferryTreeController,\n        address _staticTreeController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _taxiTreeController != address(0) &&\n                _busTreeController != address(0) &&\n                _ferryTreeController != address(0) &&\n                _staticTreeController != address(0),\n            \"init: zero address\"\n        );\n\n        TAXI_TREE_CONTROLLER = _taxiTreeController;\n        BUS_TREE_CONTROLLER = _busTreeController;\n        FERRY_TREE_CONTROLLER = _ferryTreeController;\n        STATIC_TREE_CONTROLLER = _staticTreeController;\n    }\n\n    function initialize() external onlyOwner {\n        require(_forestRoot == bytes32(0), \"PF: Already initialized\");\n\n        for (uint8 i; i < NUM_LEAFS; ) {\n            leafs[i] = ITreeRootGetter(_getLeafController(i)).getRoot();\n            unchecked {\n                ++i;\n            }\n        }\n\n        _forestRoot = hash(leafs);\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _forestRoot;\n    }\n\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external {\n        require(msg.sender == _getLeafController(leafIndex), \"unauthorized\");\n\n        leafs[leafIndex] = updatedLeaf;\n        bytes32 forestRoot = hash(leafs);\n        uint256 cacheIndex;\n        if (leafIndex == STATIC_TREE_LEAF) {\n            cacheIndex = resetThenCacheNewRoot(forestRoot);\n        } else {\n            cacheIndex = cacheNewRoot(forestRoot);\n        }\n\n        _forestRoot = forestRoot;\n        emit RootUpdated(leafIndex, updatedLeaf, forestRoot, cacheIndex);\n    }\n\n    function _getLeafController(uint256 leafIndex)\n        internal\n        view\n        returns (address leafController)\n    {\n        require(leafIndex < NUM_LEAFS, \"PF: INVALID_LEAF_IND\");\n        if (leafIndex == TAXI_TREE_FOREST_LEAF_INDEX)\n            leafController = TAXI_TREE_CONTROLLER;\n\n        if (leafIndex == BUS_TREE_FOREST_LEAF_INDEX)\n            leafController = BUS_TREE_CONTROLLER;\n\n        if (leafIndex == FERRY_TREE_FOREST_LEAF_INDEX)\n            leafController = FERRY_TREE_CONTROLLER;\n\n        if (leafIndex == STATIC_TREE_FOREST_LEAF_INDEX)\n            leafController = STATIC_TREE_CONTROLLER;\n    }\n\n    function hash(bytes32[NUM_LEAFS] memory _leafs)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT5(_leafs);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// The roots of empty trees follow.\n// An \"empty\" tree is a binary merkle tree of a given number of levels bellow\n// the root (depth), fully populated with ZERO_VALUE leafs, with the `poseidon`\n// hash function applied.\n// (computed by `../../../../lib/binaryMerkleZerosContractGenerator.ts`)\n\nuint256 constant SIX_LEVELS = 6;\n/// @dev Root of the binary merkle SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 0: ZERO_VALUE\n// Level 1: 0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n// Level 2: 0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n// Level 3: 0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n// Level 4: 0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n// Level 5: 0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\nbytes32 constant SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69)\n);\n\nuint256 constant SIXTEEN_LEVELS = 16;\n/// @dev Root of the binary merkle SIXTEEN_LEVELS tree with ZERO_VALUE leafs\n// Level 6:  SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 7:  0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n// Level 8:  0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7\n// Level 9:  0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718\n// Level 10: 0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58\n// Level 11: 0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f\n// Level 12: 0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6\n// Level 13: 0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d\n// Level 14: 0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55\n// Level 15: 0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\nbytes32 constant SIXTEEN_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x0a5e5ec37bd8f9a21a1c2192e7c37d86bf975d947c2b38598b00babe567191c9)\n);\n\nuint256 constant TWENTY_LEVELS = 20;\n/// @dev Root of the merkle binary TWENTY_LEVELS tree with ZERO_VALUE leafs\n// Level 16: SIXTEEN_LEVEL_EMPTY_TREE_ROOT\n// Level 17: 0x21fb04b171b68944c640020a3a464602ec8d02495c44f1e403d9be4a97128e49\n// Level 18: 0x19151c748859974805eb30feac7a301266dec9f67e23e285fe750f86448a2af9\n// Level 19: 0x18fb0b755218eaa809681eb87e45925faa9197507d368210d73b5836ebf139e4\nbytes32 constant TWENTY_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1e294375b42dfd97795e07e1fe8bd6cefcb16c3bbb71b30bed950f8965861244)\n);\n\nuint256 constant TWENTY_SIX_LEVELS = 26;\n/// @dev Root of the binary merkle TWENTY_SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 21: 0x0d3e4235db275d9bab0808dd9ade8789d46d0e1f1c9a99ce73fefca51dc92f4a\n// Level 22: 0x075ab2ca945c4dc5ea40a9f1c66d5bf3c367cef1e04e73aa17c2bc747eb5fc87\n// Level 23: 0x26f0f533a8ea2210001aeb8f8306c7c70656ba6afe145c6540bd4ed2c967a230\n// Level 24: 0x24be7e64f680326e6e3621e5862d7b6b1f31e9e183a0bf5dd04e823be84e6af9\n// Level 25: 0x212b13c9cbf421942ae3e3c62a3c072903c2a745a220cfb3c43cd520f55f44bf\nbytes32 constant TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n\nuint256 constant THIRTY_TWO_LEVELS = 32;\n/// @dev Root of the binary merkle THIRTY_TWO_LEVELS tree with ZERO_VALUE leafs\n// Level 26: TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 27: 0x038acf368a174e10c45a64161131c0f93faf2f045ff663acbef804eb5644aad7\n// Level 28: 0x1b3ecbe4131d8d52d60b91ec8e13d5fc82235232bb43007d54cda6b50d932d6f\n// Level 29: 0x1b0b9059f431d38a66c82317d9ed1b744c439f10193ae44bcf519fe6e1766b65\n// Level 30: 0x240867e8bb31d6b8057f5ab067dc0bd1c4ba64a42258963ec45b7b4773ce5838\n// Level 31: 0x2310e5b3543ea766ecaec53003d0e1b73f19a149409190d00561da7090a2c5cb\nbytes32 constant THIRTY_TWO_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x24ab16594d418ca2e66ca284f56a4cb7039c6d8f8e0c3c8f362cf18b5afa19d0)\n);\n"
    },
    "contracts/protocol/pantherPool/TransactionNoteEmitter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/***\n * @dev Every MASP transaction is accompanied by the \"Transaction Note\" - data\n * needed to process the transaction (think of opening UTXOs), reconstruct user\n * operations history (think of \"wallet cold start\"), or send a private message\n * to a user in extraordinary cases (think of a \"subpoena\").\n * `PantherPool` smart contract publishes Transaction Notes as \"events\" (logs).\n * The Transaction Note contains one or a few \"messages\", which may be \"public\"\n * or \"private\".\n * Public messages contain publicly seen on-chain data. Smart contracts, rather\n * than users (the DApp), compose public messages.\n * As the name assumes, private messages contain private data, and user (DApp)\n * prepares and encrypts these messages to pass them to smart contracts.\n * Every private message is encrypted with the reading key of a receiver, who\n * may be a recipient of an UTXO, or the user that spends UTXOs (\"messages to\n * the future\"), or even a user not involved in spending/creating UTXOs.\n * Smart contracts don't parse private messages but rather copy private messages\n * \"as is\" into Transaction Notes.\n * Every message belongs to a certain \"message type\". The message type defines\n * the exact message length and the content.\n * For \"fixed-content\" messages, the message type defines all data fields - i.e.\n * data interpretation, formats/size, and the sequence the fields must follow in.\n * Data fields of the \"free-content\" are unspecified, unlike the content size.\n * Public messages always have fixed content. Private messages may have fixed or\n * free content.\n * For fixed-content private messages, the protocol also specifies the content\n * of the preimage and the cipher to apply.\n * Every MASP transaction belongs to one of a few \"transaction types\".\n * For every transaction type, the protocol specifies \"mandatory\" messages which\n * MUST be included in the Transaction Note.\n * Users (DApp) may append \"optional\" messages to mandatory messages.\n * There is also a special \"void\" message that has no content. It MAY replace a\n * mandatory message when data is missing/undefined/irrelevant, providing public\n * knowledge of this fact does not leak privacy.\n */\nabstract contract TransactionNoteEmitter {\n    // @notice Transaction Note, emitted with every MASP transaction\n    event TransactionNote(uint8 txType, bytes content);\n\n    // **** `bytes content`\n\n    /* START of pseudo-code\n    bytes content = abi.packed(messages[0], ..., messages[numMessages - 1]);\n    numMessages = for_txType_num_of_mandatory_mssgs + num_of_opt_mssgs;\n\n    // For \"void\" message type:\n    bytes messages[i] = abi.packed(byte msgType);\n\n    // For messages of types other than \"void\":\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes[for_msgType_length] msgContainer\n    );\n\n    // Public fixed-content messages:\n    // Smart contract MUST compose `msgContainer` as defined by `msgType`\n    // (no `ephemeralKey` needed as data is publicly seen)\n    bytes msgContainer = avi.packed(<abi.packed on-chain data>)\n\n    // Private fixed-content messages:\n    // DApp MUST compose the `ciphertext` as defined by the `msgType`\n    bytes msgContainer = avi.packed(\n        bytes32(ephemeralKey),\n        bytes[for_msgType_ciphertext_length] ciphertext\n    )\n\n    // Private free-data messages:\n    // nBlocks - number of 16-byte blocks the `msgContent` occupies\n    require(nBlocks >= 1 && nBlocks =< 16)\n    msgType = 0x2F + nBlocks;\n    // DApp is not limited in composing (structuring) `msgContainer`\n    bytes messages[i] = abi.packed(\n        byte msgType,\n        bytes32(ephemeralKey),\n        bytes[nBlocks*16] msgContainer\n    )\n    END of pseudo-code */\n\n    // **** Transaction Types\n\n    // The range for `uint8 txType` divided into sub-ranges:\n    //  - 0x00 .. 0x1F allowed\n    //  - 0x20 .. 0xFF reserved (unused)\n\n    // solhint-disable var-name-mixedcase\n\n    uint8 internal constant TT_ZACCOUNT_ACTIVATION = 0x01;\n    // TransactionNote for this tx type MUST include in the specified sequence:\n    // - MT_UTXO_CREATE_TIME\n    // - MT_UTXO_BUSTREE_IDS\n    // - MT_UTXO_ZACCOUNT\n\n    // **** Message Types\n\n    // The range for `uint8 msgType` divided into sub-ranges:\n    //  - 0x00 - the \"void\" (empty) message\n    //  - 0x01 .. 0x2F for fixed-content private messages\n    //  - 0x30 .. 0x3F for free-content private messages\n    //  - 0x40 .. 0x5F reserved (unused)\n    //  - 0x60 .. 0x7F for fixed-content public messages\n    //  - 0x80 .. 0xFF reserved (unused)\n\n    // \"Void\" type messages contain just this single byte:\n    uint8 internal constant MT_VOID = 0x00;\n    // Length in bytes\n    uint256 internal constant LMT_VOID = 1;\n\n    // zAccount UTXO opening values:\n    uint8 internal constant MT_UTXO_ZACCOUNT = 0x06;\n    // `msgContainer` MUST include the following data:\n    // - bytes[64] cypherText\n    // Length in bytes (msgType, ephemeralKey, msgContainer)\n    uint256 internal constant LMT_UTXO_ZACCOUNT = 1 + 32 + 64;\n    // Preimage of `cipherText` MUST contain (512 bit):\n    // - random (256 bit)\n    // - networkId (6 bit)\n    // - zoneId (16 bit)\n    // - nonce (24 bit)\n    // - expiryTime (32 bit)\n    // - amountZkp (64 bit)\n    // - amountPrp (50 bit)\n    // - totalAmountPerTimePeriod (64 bit)\n\n    // Creation time of UTXO:\n    uint8 internal constant MT_UTXO_CREATE_TIME = 0x60;\n    // `msgContainer` MUST include the following data:\n    // - uint32 creationTime\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_CREATE_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_SPEND_TIME = 0x61;\n    // `msgContainer` MUST include the following data:\n    // - uint32 spendType\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_SPEND_TIME = 1 + 4;\n\n    uint8 internal constant MT_UTXO_BUSTREE_IDS = 0x62;\n    // `msgContainer` MUST include the following data:\n    // - bytes32 commitment\n    // - uint32 queueId\n    // - uint8 indexInQueue\n    // Length in bytes (msgType, msgContainer)\n    uint256 internal constant LMT_UTXO_BUSTREE_IDS = 1 + 37;\n\n    // solhint-enable var-name-mixedcase\n}\n"
    },
    "contracts/protocol/PantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023s Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IVault.sol\";\nimport \"./interfaces/IPantherVerifier.sol\";\nimport \"./interfaces/IBusTree.sol\";\nimport \"./../common/ImmutableOwnable.sol\";\nimport { LockData } from \"./../common/Types.sol\";\nimport \"./errMsgs/PantherPoolV1ErrMsgs.sol\";\nimport \"./pantherForest/PantherForest.sol\";\nimport \"./pantherPool/TransactionNoteEmitter.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\n\ncontract PantherPoolV1 is\n    PantherForest,\n    TransactionNoteEmitter,\n    IPantherPoolV1\n{\n    // initialGap - PantherForest slots - CachedRoots slots => 500 - 22 - 25\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[453] private __gap;\n\n    // solhint-disable var-name-mixedcase\n    IVault public immutable VAULT;\n    IBusTree public immutable BUS_TREE;\n    IPantherVerifier public immutable VERIFIER;\n    address public immutable ZACCOUNT_REGISTRY;\n    // solhint-enable var-name-mixedcase\n\n    mapping(address => bool) public vaultAssetUnlockers;\n\n    uint160 public zAccountRegistrationCircuitId;\n\n    constructor(\n        address _owner,\n        address taxiTree,\n        address busTree,\n        address ferryTree,\n        address staticTree,\n        address vault,\n        address zAccountRegistry,\n        address verifier\n    ) PantherForest(_owner, taxiTree, busTree, ferryTree, staticTree) {\n        require(\n            vault != address(0) &&\n                verifier != address(0) &&\n                zAccountRegistry != address(0),\n            ERR_INIT\n        );\n\n        VAULT = IVault(vault);\n        BUS_TREE = IBusTree(busTree);\n        VERIFIER = IPantherVerifier(verifier);\n        ZACCOUNT_REGISTRY = zAccountRegistry;\n    }\n\n    function updateVaultAssetUnlocker(address _unlocker, bool _status)\n        external\n        onlyOwner\n    {\n        vaultAssetUnlockers[_unlocker] = _status;\n    }\n\n    function updateZAccountRegistrationCircuitId(uint160 _circuitId)\n        external\n        onlyOwner\n    {\n        zAccountRegistrationCircuitId = _circuitId;\n    }\n\n    function unlockAssetFromVault(LockData calldata data) external {\n        require(vaultAssetUnlockers[msg.sender], ERR_UNAUTHORIZED);\n\n        // Trusted contract - no reentrancy guard needed\n        VAULT.unlockAsset(data);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot\n    /// @param inputs[13] - saltHash\n    /// @param inputs[14] - magicalConstraint\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory privateMessages,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        require(msg.sender == ZACCOUNT_REGISTRY, ERR_UNAUTHORIZED);\n        require(zAccountRegistrationCircuitId != 0, ERR_UNDEFINED_CIRCUIT);\n        {\n            uint256 zAccountNullifier = inputs[9];\n            require(zAccountNullifier != 0, ERR_ZERO_ZACCOUNT_NULLIFIER);\n        }\n        uint256 zAccountCommitment;\n        {\n            zAccountCommitment = inputs[10];\n            require(zAccountCommitment != 0, ERR_ZERO_ZACCOUNT_COMMIT);\n        }\n        {\n            uint256 kycSignedMessageHash = inputs[11];\n            require(kycSignedMessageHash != 0, ERR_ZERO_KYC_MSG_HASH);\n        }\n        {\n            uint256 saltHash = inputs[13];\n            require(saltHash != 0, ERR_ZERO_SALT_HASH);\n        }\n        {\n            uint256 magicalConstraint = inputs[14];\n            require(magicalConstraint != 0, ERR_ZERO_MAGIC_CONSTR);\n        }\n        require(\n            uint8(privateMessages[0]) == MT_UTXO_ZACCOUNT &&\n                privateMessages.length >= LMT_UTXO_ZACCOUNT,\n            ERR_NOT_WELLFORMED_SECRETS\n        );\n        // Must be less than 32 bits and NOT in the past\n        uint32 createTime = uint32(inputs[5]);\n        require(\n            uint256(createTime) == inputs[5] && createTime >= block.timestamp,\n            ERR_INVALID_CREATE_TIME\n        );\n\n        require(\n            isCachedRoot(bytes32(inputs[12]), cachedForestRootIndex),\n            ERR_INVALID_FOREST_ROOT\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        require(\n            VERIFIER.verify(zAccountRegistrationCircuitId, inputs, proof),\n            ERR_FAILED_ZK_PROOF\n        );\n\n        // Trusted contract - no reentrancy guard needed\n        (uint32 queueId, uint8 indexInQueue) = BUS_TREE.addUtxoToBusQueue(\n            bytes32(zAccountCommitment)\n        );\n        utxoBusQueuePos = (uint256(queueId) << 8) | uint256(indexInQueue);\n\n        bytes memory transactionNoteContent = abi.encodePacked(\n            // First public message\n            MT_UTXO_CREATE_TIME,\n            createTime,\n            // Seconds public message\n            MT_UTXO_BUSTREE_IDS,\n            inputs[11], // zAccountCommitment\n            queueId,\n            indexInQueue,\n            // Private message(s)\n            privateMessages\n        );\n\n        emit TransactionNote(TT_ZACCOUNT_ACTIVATION, transactionNoteContent);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}