{
  "language": "Solidity",
  "sources": {
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/EIP712SignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nabstract contract EIP712SignatureVerifier {\n    bytes private constant EIP191_VERSION = \"\\x19\\x01\";\n\n    string public constant EIP712_NAME = \"Panther Protocol\";\n    string public constant EIP712_VERSION = \"1\";\n\n    // keccak256(bytes(\"PANTHER_EIP712_DOMAIN_SALT\"));\n    bytes32 public constant EIP712_SALT =\n        0x44b818e3e3a12ecf805989195d8f38e75517386006719e2dbb1443987a34db7b;\n\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\n        keccak256(\n            bytes(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract,bytes32 salt)\"\n            )\n        );\n\n    function getDomainSeperator() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    EIP712_DOMAIN_TYPEHASH,\n                    keccak256(bytes(EIP712_NAME)),\n                    keccak256(bytes(EIP712_VERSION)),\n                    block.chainid,\n                    address(this),\n                    EIP712_SALT\n                )\n            );\n    }\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address signer) {\n        signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA invalid signature\");\n    }\n\n    function toTypedDataHash(bytes32 structHash)\n        internal\n        view\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encodePacked(\n                    EIP191_VERSION,\n                    getDomainSeperator(),\n                    structHash\n                )\n            );\n    }\n}\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/common/UtilsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.16;\n\nlibrary UtilsLib {\n    function safe24(uint256 n) internal pure returns (uint24) {\n        require(n < 2**24, \"UNSAFE24\");\n        return uint24(n);\n    }\n\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        uint256 t = block.timestamp;\n        require(t < 2**32, \"UNSAFE32TIME\");\n        return uint32(t);\n    }\n\n    function safe32BlockNow() internal view returns (uint32) {\n        uint256 b = block.number;\n        require(b < 2**32, \"UNSAFE32BLOCK\");\n        return uint32(b);\n    }\n\n    function revertZeroAddress(address account) internal pure {\n        require(account != address(0), \"UNEXPECTED_ZERO_ADDRESS\");\n    }\n}\n"
    },
    "contracts/protocol/crypto/BabyJubJub.sol": {
      "content": "// SPDX-License-Identifier: GPL\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// Implementer name - yondonfu\n// Link to the implementation - https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\npragma solidity ^0.8.16;\nimport \"../../common/Types.sol\";\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\n\nlibrary BabyJubJub {\n    // Curve parameters\n    // E: 168700x^2 + y^2 = 1 + 168696x^2y^2\n    // A = 168700\n    uint256 public constant A = 0x292FC;\n    // D = 168696\n    uint256 public constant D = 0x292F8;\n    // Prime Q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n    // slither-disable-next-line too-many-digits\n    uint256 public constant Q =\n        0x30644E72E131A029B85045B68181585D2833E84879B9709143E1F593F0000001;\n\n    // @dev Base point generates the subgroup of points P of Baby Jubjub satisfying l * P = O.\n    // That is, it generates the set of points of order l and origin O.\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_X =\n        5299619240641551281634865583518297030282874472190772894086521144482721001553;\n    // slither-disable-next-line too-many-digits\n    uint256 public constant BASE8_Y =\n        16950150798460657717958625567821834550301663161624707787222815936182638968203;\n\n    // pm1d2 = (SNARK_FIELD - 1) >> 1 // same as `negative_one / 2\n    // slither-disable-next-line too-many-digits\n    uint256 public constant PM1D2 =\n        10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n    // TODO: remove dependency on BabyJubJub as a standalone contract\n    function pointPack(G1Point memory point)\n        internal\n        pure\n        returns (bytes32 _packed)\n    {\n        _packed = bytes32(point.y);\n\n        if (point.x > PM1D2) {\n            _packed = bytes32(\n                point.y |\n                    0x8000000000000000000000000000000000000000000000000000000000000000\n            );\n        }\n    }\n\n    /**\n     * @dev Add 2 points on baby jubjub curve\n     * Formulae for adding 2 points on a twisted Edwards curve:\n     * x3 = (x1y2 + y1x2) / (1 + dx1x2y1y2)\n     * y3 = (y1y2 - ax1x2) / (1 - dx1x2y1y2)\n     */\n    function pointAdd(G1Point memory g1, G1Point memory g2)\n        internal\n        view\n        returns (G1Point memory)\n    {\n        uint256 x3 = 0;\n        uint256 y3 = 0;\n        if (g1.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        if (g2.x == 0 && g1.y == 0) {\n            return G1Point(x3, y3);\n        }\n\n        uint256 x1x2 = mulmod(g1.x, g2.x, Q);\n        uint256 y1y2 = mulmod(g1.y, g2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(g1.x, g2.y, Q), mulmod(g1.y, g2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(A, x1x2, Q), Q);\n\n        x3 = mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q);\n        y3 = mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q);\n        return G1Point(x3, y3);\n    }\n\n    /**\n     * @dev Perform modular subtraction\n     */\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        uint256 aNN = _a;\n\n        if (_a <= _b) {\n            aNN += _mod;\n        }\n\n        return addmod(aNN - _b, 0, _mod);\n    }\n\n    /**\n     * @dev Compute modular inverse of a number\n     */\n    function inverse(uint256 _a) internal view returns (uint256) {\n        // We can use Euler's theorem instead of the extended Euclidean algorithm\n        // Since m = Q and Q is prime we have: a^-1 = a^(m - 2) (mod m)\n        return expmod(_a, Q - 2, Q);\n    }\n\n    /**\n     * @dev Helper function to call the bigModExp precompile\n     */\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        // solhint-disable no-inline-assembly\n        // slither-disable-next-line assembly\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20) // Length of base _b\n            mstore(add(memPtr, 0x20), 0x20) // Length of exponent _e\n            mstore(add(memPtr, 0x40), 0x20) // Length of modulus _m\n            mstore(add(memPtr, 0x60), _b) // Base _b\n            mstore(add(memPtr, 0x80), _e) // Exponent _e\n            mstore(add(memPtr, 0xa0), _m) // Modulus _m\n\n            // The bigModExp precompile is at 0x05\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n        // solhint-enable no-inline-assembly\n    }\n\n    function mulPointEscalar(G1Point memory point, uint256 scalar)\n        internal\n        view\n        returns (G1Point memory r)\n    {\n        r.x = 0;\n        r.y = 1;\n\n        uint256 rem = scalar;\n        G1Point memory exp = point;\n\n        while (rem != uint256(0)) {\n            if ((rem & 1) == 1) {\n                r = pointAdd(r, exp);\n            }\n            exp = pointAdd(exp, exp);\n            rem = rem >> 1;\n        }\n        r.x = r.x % Q;\n        r.y = r.y % Q;\n\n        return r;\n    }\n\n    function isG1PointLowerThanFieldSize(uint256[2] memory point)\n        internal\n        pure\n        returns (bool)\n    {\n        return point[0] <= FIELD_SIZE && point[1] <= FIELD_SIZE;\n    }\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/PoseidonHashers.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { FIELD_SIZE } from \"./SnarkConstants.sol\";\nimport \"./Poseidon.sol\";\n\nlibrary PoseidonHashers {\n    string private constant ERR_INPUT_NOT_IN_FIELD =\n        \"PoseidonHasher: input not in field\";\n\n    function poseidonT3(bytes32[2] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE && uint256(input[1]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT3.poseidon(input);\n    }\n\n    function poseidonT4(bytes32[3] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT4.poseidon(input);\n    }\n\n    function poseidonT5(bytes32[4] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT5.poseidon(input);\n    }\n\n    function poseidonT6(bytes32[5] memory input)\n        internal\n        pure\n        returns (bytes32)\n    {\n        require(\n            uint256(input[0]) < FIELD_SIZE &&\n                uint256(input[1]) < FIELD_SIZE &&\n                uint256(input[2]) < FIELD_SIZE &&\n                uint256(input[3]) < FIELD_SIZE &&\n                uint256(input[4]) < FIELD_SIZE,\n            ERR_INPUT_NOT_IN_FIELD\n        );\n        return PoseidonT6.poseidon(input);\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// FIXME: make MAGICAL_CONSTRAINT the public input (var, not const) - it MUST have random value on every invocation\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/errMsgs/ProvidersKeysErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT_CONTRACT = \"PK:init\";\n\nstring constant ERR_NOT_IN_FIELD = \"PK:E01\";\nstring constant ERR_INCORRECT_SIBLINGS_SIZE = \"PK:E02\";\n\nstring constant ERR_TREE_LOCK_ALREADY_UPDATED = \"ZAR:E05\";\nstring constant ERR_TREE_IS_LOCKED = \"PK:E06\";\n\nstring constant ERR_INSUFFICIENT_ALLOCATION = \"PK:E10\";\nstring constant ERR_TOO_HIGH_ALLOCATION = \"PK:E11\";\n\nstring constant ERR_KEYRING_ALREADY_ACTIVATED = \"PK:15\";\nstring constant ERR_KEYRING_NOT_EXISTS = \"PK:E16\";\nstring constant ERR_KEYRING_NOT_ACTIVATED = \"PK:E17\";\n\nstring constant ERR_UNAUTHORIZED_OPERATOR = \"PK:E20\";\nstring constant ERR_ZERO_OPERATOR_ADDRESS = \"PK:E21\";\nstring constant ERR_SAME_OPERATOR = \"PK:E22\";\n\nstring constant ERR_REVOKED_KEY = \"PK:E25\";\nstring constant ERR_INVALID_KEY_EXPIRY = \"PK:E26\";\nstring constant ERR_KEY_IS_NOT_IN_KEYRING = \"PK:E27\";\n"
    },
    "contracts/protocol/errMsgs/ZAccountsRegistryErrMsgs.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nstring constant ERR_INIT_CONTRACT = \"ZAR:init\";\n\nstring constant ERR_BLACKLIST_ZACCOUNT_ID = \"ZAR:E1\";\nstring constant ERR_BLACKLIST_MASTER_EOA = \"ZAR:E2\";\nstring constant ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY = \"ZAR:E3\";\n\nstring constant ERR_DUPLICATED_MASTER_EOA = \"ZAR:E4\";\nstring constant ERR_DUPLICATED_NULLIFIER = \"ZAR:E5\";\n\nstring constant ERR_UNKNOWN_ZACCOUNT = \"ZAR:E6\";\n\nstring constant ERR_MISMATCH_ARRAYS_LENGTH = \"ZAR:E7\";\nstring constant ERR_REPETITIVE_STATUS = \"ZAR:E8\";\n\nstring constant ERR_INVALID_ZACCOUNT_FLAG_POSITION = \"ZAR:E9\";\nstring constant ERR_TOO_LARGE_LEAF_INPUTS = \"ZAR:E10\";\n\nstring constant ERR_INVALID_EXTRA_INPUT_HASH = \"ZAR:E11\";\nstring constant ERR_UNEXPECTED_ZKP_AMOUNT = \"ZAR:E12\";\nstring constant ERR_UNEXPECTED_PRP_AMOUNT = \"ZAR:E13\";\nstring constant ERR_ZERO_ZACCOUNT_COMMIT = \"ZAR:E14\";\nstring constant ERR_ZERO_KYC_MSG_HASH = \"ZAR:E15\";\n"
    },
    "contracts/protocol/interfaces/IOnboardingController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\n\ninterface IOnboardingController {\n    function grantRewards(\n        address _user,\n        uint8 prevStatus,\n        uint8 newStatus,\n        bytes memory _data\n    ) external returns (uint256 _userZkpRewardAlloc);\n}\n"
    },
    "contracts/protocol/interfaces/IPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IPantherPoolV1 {\n    function createZAccountUtxo(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256);\n\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/mocks/LocalDevEnv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { DEAD_CODE_ADDRESS } from \"../../common/Constants.sol\";\n\ncontract LocalDevEnv {\n    modifier onlyLocalDevEnv() {\n        // DEAD_CODE_ADDRESS is supposed (and must) be and unusable address,\n        // which eliminate risks of using tx.origin here.\n        // solhint-disable-next-line avoid-tx-origin\n        require(tx.origin == DEAD_CODE_ADDRESS, \"Only allowed in forked env\");\n        _;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../ZAccountsRegistry.sol\";\n\ncontract MockZAccountsRegistry is ZAccountsRegistry {\n    uint256 public nextId;\n\n    constructor(\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingRewardController\n    )\n        ZAccountsRegistry(\n            msg.sender,\n            _zAccountVersion,\n            pantherPool,\n            pantherStaticTree,\n            onboardingRewardController\n        )\n    {} // solhint-disable-line no-empty-blocks\n\n    function mockZAccountIdTracker(uint256 _zAccountIdTracker) external {\n        zAccountIdTracker = _zAccountIdTracker;\n    }\n\n    function internalGetNextZAccountId() external {\n        nextId = _getNextZAccountId();\n    }\n}\n"
    },
    "contracts/protocol/PantherBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./interfaces/IPantherPoolV1.sol\";\n\nimport \"./pantherForest/busTree/BusTree.sol\";\nimport { PoseidonT3 } from \"./crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\nimport { DEAD_CODE_ADDRESS, ERC20_TOKEN_TYPE } from \"../common/Constants.sol\";\nimport { LockData } from \"../common/Types.sol\";\nimport \"../common/ImmutableOwnable.sol\";\nimport \"./mocks/LocalDevEnv.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\n\ncontract PantherBusTree is BusTree, LocalDevEnv, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // solhint-enable var-name-mixedcase\n\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address _pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId, _pantherPool) {\n        require(rewardToken != address(0), \"init: zero address\");\n\n        START_TIME = block.timestamp;\n\n        REWARD_TOKEN = rewardToken;\n    }\n\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate, minEmptyQueueAge);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            \"updateParams: zero value\"\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3([left, right]);\n    }\n\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    function addUtxoToBusQueue(bytes32 utxo)\n        external\n        returns (uint32 queueId, uint8 indexInQueue)\n    {\n        require(msg.sender == PANTHER_POOL, \"BT:UNAUTH_ZACCOUNT_UTXO_SENDER\");\n\n        bytes32[] memory utxos = new bytes32[](1);\n        utxos[0] = utxo;\n\n        queueId = _nextQueueId == 0 ? 0 : _nextQueueId - 1;\n        BusQueue memory busQueue = _busQueues[queueId];\n        indexInQueue = busQueue.nUtxos;\n\n        addUtxosToBusQueue(utxos, uint96(basePerUtxoReward));\n    }\n\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxosToBusQueue(utxos, uint96(reward));\n    }\n\n    function simulateAddGivenUtxosToBusQueue(\n        bytes32[] memory utxos,\n        uint96 reward\n    ) external onlyLocalDevEnv {\n        addUtxosToBusQueue(utxos, reward);\n    }\n\n    function simulateAddBusQueueReward(uint32 queueId, uint96 extraReward)\n        external\n        onlyLocalDevEnv\n    {\n        addBusQueueReward(queueId, extraReward);\n    }\n\n    function simulateSetBusQueueAsProcessed(uint32 queueId)\n        external\n        onlyLocalDevEnv\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        return setBusQueueAsProcessed(queueId);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint40 remainingBlocks;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) internal _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 internal _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Minimum number of blocks an empty queue must pend processing.\n    uint16 private _minEmptyQueueAge;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate,\n        uint256 minEmptyQueueAge\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums or queue age limit, the `updateParams` call needed.\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    // @return minEmptyQueueAge Min number of blocks an empty queue must pend\n    // processing. For a partially filled queue, it declines linearly with the\n    // number of queue's UTXOs. Full queues are immediately processable.\n    function getParams()\n        external\n        view\n        returns (\n            uint16 reservationRate,\n            uint16 premiumRate,\n            uint16 minEmptyQueueAge\n        )\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n        minEmptyQueueAge = _minEmptyQueueAge;\n    }\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _getQueueRemainingBlocks(q),\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // @param maxLength Maximum number of queues to return\n    // @return queues Queues pending processing, starting from the oldest one\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].remainingBlocks = _getQueueRemainingBlocks(queue);\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    // @dev Refer to return values of the `getParam` function\n    function updateParams(\n        uint16 reservationRate,\n        uint16 premiumRate,\n        uint16 minEmptyQueueAge\n    ) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        _minEmptyQueueAge = minEmptyQueueAge;\n        emit BusQueueRewardParamsUpdated(\n            reservationRate,\n            premiumRate,\n            minEmptyQueueAge\n        );\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        internal\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        require(_getQueueRemainingBlocks(queue) == 0, \"BQT:IMMATURE_QUEUE\");\n\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    // Returns the number of blocks to wait until a queue may be processed.\n    // Always returns 0 for a fully populated queue (immediately processable).\n    // For an empty queue it returns a meaningless value.\n    function _getQueueRemainingBlocks(BusQueue memory queue)\n        private\n        view\n        returns (uint40)\n    {\n        if (queue.nUtxos >= QUEUE_MAX_SIZE) return 0;\n\n        // Minimum \"age\" declines linearly to the number of UTXOs in the queue\n        uint256 nEmptySeats = uint256(QUEUE_MAX_SIZE - queue.nUtxos);\n        uint256 minAge = (nEmptySeats * _minEmptyQueueAge) / QUEUE_MAX_SIZE;\n\n        uint256 maturityBlock = minAge + queue.firstUtxoBlock;\n        return\n            block.number >= maturityBlock\n                ? 0 // Overflow risk ignored\n                : uint40(maturityBlock - block.number);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\n// TODO: remove MAGICAL_CONSTRAINT as a constant and make it a pub input var\nimport { BUS_TREE_FOREST_LEAF_INDEX } from \"../Constants.sol\";\nimport { MAGICAL_CONSTRAINT } from \"../../crypto/SnarkConstants.sol\";\nimport \"../interfaces/ITreeRootUpdater.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n */\nabstract contract BusTree is BusQueues, ITreeRootGetter {\n    // TODO: adding gap to the beginning and end of the storage\n\n    // solhint-disable var-name-mixedcase\n    bytes32 internal constant EMPTY_BUS_TREE_ROOT =\n        TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT;\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 private _busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(\n        address _verifier,\n        uint160 _circuitId,\n        address _pantherPool\n    ) {\n        require(_pantherPool != address(0), \"init: zero address\");\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            \"BT:INVALID_VK\"\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function getRoot` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n\n        PANTHER_POOL = _pantherPool;\n    }\n\n    function getRoot() public view returns (bytes32) {\n        return _busTreeRoot == bytes32(0) ? EMPTY_BUS_TREE_ROOT : _busTreeRoot;\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        bytes32 busTreeNewRoot,\n        bytes32 batchRoot,\n        bytes32 busBranchNewRoot,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        uint32 nBatches = _numBatchesInBusTree;\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n\n        // Circuit public input signals\n        uint256[] memory input = new uint256[](9);\n        // `oldRoot` signal\n        input[0] = uint256(getRoot());\n        // `newRoot` signal\n        input[1] = uint256(busTreeNewRoot);\n        // `replacedNodeIndex` signal\n        input[2] = nBatches;\n        // `newLeafsCommitment` signal\n        input[3] = uint256(commitment);\n        // `nNonEmptyNewLeafs` signal\n        input[4] = uint256(nUtxos);\n        // `batchRoot` signal\n        input[5] = uint256(batchRoot);\n        // `branchRoot` signal\n        input[6] = uint256(busBranchNewRoot);\n        // `extraInput` signal (front-run protection)\n        input[7] = uint256(uint160(miner));\n        // magicalConstraint\n        input[8] = MAGICAL_CONSTRAINT;\n\n        // Verify the proof\n        require(VERIFIER.verify(CIRCUIT_ID, input, proof), \"BT:FAILED_PROOF\");\n\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        ITreeRootUpdater(PANTHER_POOL).updateRoot(\n            busTreeNewRoot,\n            BUS_TREE_FOREST_LEAF_INDEX\n        );\n\n        // Store updated Bus Tree params\n        _busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// `PantherForest` tree leafs indices (leafs store specific merkle trees roots)\nuint256 constant TAXI_TREE_FOREST_LEAF_INDEX = 0;\nuint256 constant BUS_TREE_FOREST_LEAF_INDEX = 1;\nuint256 constant FERRY_TREE_FOREST_LEAF_INDEX = 2;\nuint256 constant STATIC_TREE_FOREST_LEAF_INDEX = 3;\n\n// `PantherStaticTree` leafs indices (leafs store specific merkle trees roots)\nuint256 constant ZASSET_STATIC_LEAF_INDEX = 0;\nuint256 constant ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX = 1;\nuint256 constant ZNETWORK_STATIC_LEAF_INDEX = 2;\nuint256 constant ZZONE_STATIC_LEAF_INDEX = 3;\nuint256 constant PROVIDERS_KEYS_STATIC_LEAF_INDEX = 4;\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootGetter {\n    function getRoot() external view returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/interfaces/ITreeRootUpdater.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\ninterface ITreeRootUpdater {\n    function updateRoot(bytes32 updatedLeaf, uint256 leafIndex) external;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/BinaryUpdatableTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n// @notice The \"binary binary tree\" populated with zero leaf values\n\n/**\n * @title BinaryIncrementalUpdatableMerkleTree\n * @notice\n * @dev\n */\nabstract contract BinaryUpdatableTree {\n    /**\n     * @dev Update an existing leaf\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param newLeaf New leaf.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return _newRoot The new root after updating the tree\n     */\n    function update(\n        bytes32 curRoot,\n        bytes32 leaf,\n        bytes32 newLeaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bytes32 _newRoot) {\n        require(newLeaf != leaf, \"BIUT: New leaf cannot be equal the old one\");\n        require(\n            verify(curRoot, leaf, leafIndex, proofSiblings),\n            \"BIUT: Leaf is not part of the tree\"\n        );\n\n        _newRoot = newLeaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _newRoot = hash([_newRoot, proofSiblings[i]]);\n            } else {\n                _newRoot = hash([proofSiblings[i], _newRoot]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @dev Verify if the path is correct and the leaf is part of the tree.\n     * @param curRoot current merkle root.\n     * @param leaf Leaf to be updated.\n     * @param leafIndex leafIndex\n     * @param proofSiblings Path of the proof of membership.\n     * @return True or false.\n     */\n    function verify(\n        bytes32 curRoot,\n        bytes32 leaf,\n        uint256 leafIndex,\n        bytes32[] memory proofSiblings\n    ) internal pure returns (bool) {\n        // equal to 2**proofSiblings.length\n        uint256 leavesNum = 1 << proofSiblings.length;\n        require(leafIndex < leavesNum, \"BIUT: invalid leaf index\");\n\n        bytes32 _hash = leaf;\n        uint256 proofPathIndice;\n\n        // using `proofSiblings[]` length as the tree dept\n        for (uint256 i = 0; i < proofSiblings.length; ) {\n            // getting the bit at position `i` and check if it's 0 or 1\n            proofPathIndice = (leafIndex >> i) & 1;\n\n            if (proofPathIndice == 0) {\n                _hash = hash([_hash, proofSiblings[i]]);\n            } else {\n                _hash = hash([proofSiblings[i], _hash]);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return curRoot == 0 ? _hash == zeroRoot() : _hash == curRoot;\n    }\n\n    function zeroRoot() internal pure virtual returns (bytes32);\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/mocks/MockTaxiTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../taxiTree/PantherTaxiTree.sol\";\nimport \"../../crypto/PoseidonHashers.sol\";\nimport { FIELD_SIZE } from \"../../crypto/SnarkConstants.sol\";\n\ncontract MockTaxiTree is PantherTaxiTree {\n    // function simulateUpdateLeaf(\n    //     BinaryUpdatableTree calldata tree,\n    //     bytes32 newLeaf,\n    //     bytes32 oldLeaf,\n    //     uint256 leafInd,\n    //     bytes32[] calldata siblings\n    // ) public returns (bytes32 newRoot) {\n    //     updateLeaf(tree, newLeaf, oldLeaf, leafInd, siblings);\n    // }\n\n    function hash(bytes32[2] memory input) internal pure returns (bytes32) {\n        return PoseidonHashers.poseidonT3(input);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/taxiTree/PantherTaxiTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../interfaces/ITreeRootGetter.sol\";\nimport { SIX_LEVEL_EMPTY_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\n\n// is PantherTreesZeros\nabstract contract PantherTaxiTree is ITreeRootGetter {\n    // Root of root with ZERO trees with depth 6\n    function getRoot() external pure returns (bytes32) {\n        return SIX_LEVEL_EMPTY_TREE_ROOT;\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// The roots of empty trees follow.\n// An \"empty\" tree is a binary merkle tree of a given number of levels bellow\n// the root (depth), fully populated with ZERO_VALUE leafs, with the `poseidon`\n// hash function applied.\n// (computed by `../../../../lib/binaryMerkleZerosContractGenerator.ts`)\n\nuint256 constant SIX_LEVELS = 6;\n/// @dev Root of the binary merkle SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 0: ZERO_VALUE\n// Level 1: 0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4\n// Level 2: 0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8\n// Level 3: 0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c\n// Level 4: 0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800\n// Level 5: 0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f\nbytes32 constant SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x2e99dc37b0a4f107b20278c26562b55df197e0b3eb237ec672f4cf729d159b69)\n);\n\nuint256 constant SIXTEEN_LEVELS = 16;\n/// @dev Root of the binary merkle SIXTEEN_LEVELS tree with ZERO_VALUE leafs\n// Level 6:  SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 7:  0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n// Level 8:  0x276c76358db8af465e2073e4b25d6b1d83f0b9b077f8bd694deefe917e2028d7\n// Level 9:  0x09df92f4ade78ea54b243914f93c2da33414c22328a73274b885f32aa9dea718\n// Level 10: 0x1c78b565f2bfc03e230e0cf12ecc9613ab8221f607d6f6bc2a583ccd690ecc58\n// Level 11: 0x2879d62c83d6a3af05c57a4aee11611a03edec5ff8860b07de77968f47ff1c5f\n// Level 12: 0x28ad970560de01e93b613aabc930fcaf087114743909783e3770a1ed07c2cde6\n// Level 13: 0x27ca60def9dd0603074444029cbcbeaa9dbe77668479ac1db738bb892d9f3b6d\n// Level 14: 0x28e4c1e90bbfa69de93abf6cbdc7cd1c0753a128e83b2b3afe34e0471a13ff55\n// Level 15: 0x1b89c44a9f153266ad5bf754d4b252c26acba7d21fc661b94dc0618c6a82f49c\nbytes32 constant SIXTEEN_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x0a5e5ec37bd8f9a21a1c2192e7c37d86bf975d947c2b38598b00babe567191c9)\n);\n\nuint256 constant TWENTY_LEVELS = 20;\n/// @dev Root of the merkle binary TWENTY_LEVELS tree with ZERO_VALUE leafs\n// Level 16: SIXTEEN_LEVEL_EMPTY_TREE_ROOT\n// Level 17: 0x21fb04b171b68944c640020a3a464602ec8d02495c44f1e403d9be4a97128e49\n// Level 18: 0x19151c748859974805eb30feac7a301266dec9f67e23e285fe750f86448a2af9\n// Level 19: 0x18fb0b755218eaa809681eb87e45925faa9197507d368210d73b5836ebf139e4\nbytes32 constant TWENTY_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1e294375b42dfd97795e07e1fe8bd6cefcb16c3bbb71b30bed950f8965861244)\n);\n\nuint256 constant TWENTY_SIX_LEVELS = 26;\n/// @dev Root of the binary merkle TWENTY_SIX_LEVELS tree with ZERO_VALUE leafs\n// Level 21: 0x0d3e4235db275d9bab0808dd9ade8789d46d0e1f1c9a99ce73fefca51dc92f4a\n// Level 22: 0x075ab2ca945c4dc5ea40a9f1c66d5bf3c367cef1e04e73aa17c2bc747eb5fc87\n// Level 23: 0x26f0f533a8ea2210001aeb8f8306c7c70656ba6afe145c6540bd4ed2c967a230\n// Level 24: 0x24be7e64f680326e6e3621e5862d7b6b1f31e9e183a0bf5dd04e823be84e6af9\n// Level 25: 0x212b13c9cbf421942ae3e3c62a3c072903c2a745a220cfb3c43cd520f55f44bf\nbytes32 constant TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n\nuint256 constant THIRTY_TWO_LEVELS = 32;\n/// @dev Root of the binary merkle THIRTY_TWO_LEVELS tree with ZERO_VALUE leafs\n// Level 26: TWENTY_SIX_LEVEL_EMPTY_TREE_ROOT\n// Level 27: 0x038acf368a174e10c45a64161131c0f93faf2f045ff663acbef804eb5644aad7\n// Level 28: 0x1b3ecbe4131d8d52d60b91ec8e13d5fc82235232bb43007d54cda6b50d932d6f\n// Level 29: 0x1b0b9059f431d38a66c82317d9ed1b744c439f10193ae44bcf519fe6e1766b65\n// Level 30: 0x240867e8bb31d6b8057f5ab067dc0bd1c4ba64a42258963ec45b7b4773ce5838\n// Level 31: 0x2310e5b3543ea766ecaec53003d0e1b73f19a149409190d00561da7090a2c5cb\nbytes32 constant THIRTY_TWO_LEVEL_EMPTY_TREE_ROOT = bytes32(\n    uint256(0x24ab16594d418ca2e66ca284f56a4cb7039c6d8f8e0c3c8f362cf18b5afa19d0)\n);\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/SixLevelZeroTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { ZERO_VALUE } from \"./Constants.sol\";\n\n// @notice The binary Merkle tree of six levels populated with zero leaf values\nabstract contract SixLevelZeroTree {\n    // @dev Number of levels in a tree excluding the root level\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 internal constant SIX_LEVELS = 6;\n\n    // @param level From 0 for the leaf up to SIX_LEVELS for the root\n    function getZeroNodeAtLevel(uint256 level) internal pure returns (bytes32) {\n        require(level < SIX_LEVELS + 1, \"SZT:E1\");\n\n        // Generated by `../../../../lib/binaryMerkleZerosContractGenerator.ts`\n        uint256 zeroNode = [\n            // Leaf with the zero value\n            uint256(ZERO_VALUE),\n            // Roots of branches containing zero leafs only, one root per level\n            0x232fc5fea3994c77e07e1bab1ec362727b0f71f291c17c34891dd4faf1457bd4,\n            0x077851cf613fd96280795a3cabc89663f524b1b545a3b1c7c79130b0f7d251c8,\n            0x1d79fd0bc46f7ca934dbcd3386a06f03c43f497851b3815ee726e7f9b26e504c,\n            0x05c0c15753806f506f64c18bf07116542451822479c4a89305cd4eb7ee94c800,\n            0x2b56fd5e780ebebdacdd27e6464cf01aac089461a998814974a7504aabb2023f,\n            // Root of the tree fully populated with zero leafs only\n            0x225624653ac89fe211c0c3d303142a4caf24eb09050be08c33af2e7a1e372a0f\n        ][level];\n\n        return bytes32(zeroNode);\n    }\n}\n"
    },
    "contracts/protocol/ProvidersKeys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./pantherForest/interfaces/ITreeRootGetter.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\n\nimport \"../common/UtilsLib.sol\";\nimport \"./errMsgs/ProvidersKeysErrMsgs.sol\";\nimport \"./crypto/BabyJubJub.sol\";\nimport \"./crypto/PoseidonHashers.sol\";\n\nimport \"./providersKeys/ProvidersKeysSignatureVerifier.sol\";\nimport \"./pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport { PROVIDERS_KEYS_STATIC_LEAF_INDEX } from \"./pantherForest/Constants.sol\";\nimport { SIXTEEN_LEVELS, SIXTEEN_LEVEL_EMPTY_TREE_ROOT, ZERO_VALUE } from \"./pantherForest/zeroTrees/Constants.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport { G1Point } from \"../common/Types.sol\";\n\n/**\n * @title ProvidersKeys\n * @author Pantherprotocol Contributors\n * @notice It registers public keys of providers, such as KYC/KYT attesters,\n * zone operators, data escrow (or \"data safe\") operators.\n * Each public key is stored as a leaf of a binary merkle tree. Every time the\n * tree is updated, this contract calls `PantherStaticTree` smart contract to\n * notify on update of the tree root.\n * The contract owner allocates leafs (\"keyring\") to a provider and authorizes\n * an address that may register provider's keys.\n * This way a provider gets the \"keyring\" where the provider may put that many\n * keys as the owner allocated.\n * @dev Public keys are points in the BabyJubjub elliptic curve. The contract\n * does not check, however, if the key is a valid curve point.\n * Since the off-chain computation of the tree updates proved by the SNARK will\n * replace the on-chain computation in the next version, the \"incremental tree\"\n * algorithm is not applied (\"incremental tree\" is easier for operators since\n * `proofSiblings` unneeded as input params on tree leafs insertions/updates).\n */\ncontract ProvidersKeys is\n    ProvidersKeysSignatureVerifier,\n    BinaryUpdatableTree,\n    ImmutableOwnable,\n    ITreeRootGetter\n{\n    // solhint-disable var-name-mixedcase\n\n    uint256 private KEYS_TREE_DEPTH = SIXTEEN_LEVELS;\n    uint16 private constant MAX_KEYS = uint16(2**SIXTEEN_LEVELS - 1);\n\n    uint32 private REVOKED_KEY_EXPIRY = 0;\n    uint256 private MAX_TREE_LOCK_PERIOD = 30 days;\n\n    ITreeRootUpdater public immutable PANTHER_STATIC_TREE;\n\n    // solhint-enable var-name-mixedcase\n\n    /// @notice keyring status\n    enum STATUS {\n        UNDEFINED,\n        ACTIVE,\n        SUSPENDED\n    }\n\n    /// @notice keyring parameters\n    struct Keyring {\n        address operator;\n        STATUS status;\n        uint16 numKeys;\n        uint16 numAllocKeys;\n        uint32 registrationBlock;\n        uint24 _unused;\n    }\n\n    /// @notice Mapping from keyring ID to Keyring data\n    mapping(uint16 => Keyring) public keyrings;\n\n    /// @notice Mapping from key index to keyring ID\n    mapping(uint16 => uint16) public keyringIds;\n\n    /// @dev Number of keyrings added (created) so far\n    uint16 private _numKeyrings;\n\n    /// @dev Number of public keys registered so far\n    uint16 private _totalNumRegisteredKeys;\n\n    /// @dev Number of leafs reserved for public keys so far\n    uint16 private _totalNumAllocatedKeys;\n\n    /// @dev (UNIX) time till when operators can't register/revoke/extend keys\n    /// @dev Owner may temporally disable the tree changes by operators to avoid\n    /// the \"race condition\" (if multiple parties try to update simultaneously)\n    uint32 private _treeLockedTillTime;\n\n    /// @dev Root of the merkle tree with registered keys\n    bytes32 private _treeRoot;\n\n    event KeyRegistered(\n        uint16 indexed keyringId,\n        uint16 indexed keyIndex,\n        bytes32 packedPubKey,\n        uint32 expiry\n    );\n    event KeyExtended(\n        uint16 indexed keyringId,\n        uint16 indexed keyIndex,\n        uint32 newExpiry\n    );\n    event KeyRevoked(uint16 indexed keyringId, uint16 indexed keyIndex);\n\n    event KeyringUpdated(\n        uint16 indexed keyringId,\n        address operator,\n        STATUS status,\n        uint16 numAllocKeys\n    );\n\n    event TreeLockUpdated(uint32 tillTime);\n\n    constructor(\n        address _owner,\n        uint8 keyringVersion,\n        address pantherStaticTree\n    ) ImmutableOwnable(_owner) ProvidersKeysSignatureVerifier(keyringVersion) {\n        require(pantherStaticTree != address(0), ERR_INIT_CONTRACT);\n\n        // trusted contract - no reentrancy guard needed\n        // slither-disable-next-line unchecked-transfer,reentrancy-events\n        PANTHER_STATIC_TREE = ITreeRootUpdater(pantherStaticTree);\n    }\n\n    modifier whenTreeUnlocked() {\n        _requireTreeIsUnlocked();\n        _;\n    }\n\n    modifier keyInKeyring(uint16 keyIndex, uint16 keyringId) {\n        require(keyringIds[keyIndex] == keyringId, ERR_KEY_IS_NOT_IN_KEYRING);\n        _;\n    }\n\n    function getStatistics()\n        external\n        view\n        returns (\n            uint16 numKeyrings,\n            uint16 totalNumRegisteredKeys,\n            uint16 totalNumAllocatedKeys,\n            uint32 treeLockedTillTime\n        )\n    {\n        numKeyrings = _numKeyrings;\n        totalNumRegisteredKeys = _totalNumRegisteredKeys;\n        totalNumAllocatedKeys = _totalNumAllocatedKeys;\n        treeLockedTillTime = _treeLockedTillTime;\n    }\n\n    function getRoot() external view returns (bytes32) {\n        return _treeRoot == bytes32(0) ? zeroRoot() : _treeRoot;\n    }\n\n    // @dev It does NOT check if the pubKey is a point on the BabyJubJub curve\n    function packPubKey(G1Point memory pubKey) public pure returns (bytes32) {\n        // Coordinates must be in the SNARK field\n        require(\n            BabyJubJub.isG1PointLowerThanFieldSize([pubKey.x, pubKey.y]),\n            ERR_NOT_IN_FIELD\n        );\n        return BabyJubJub.pointPack(pubKey);\n    }\n\n    function getKeyCommitment(G1Point memory pubKey, uint32 expiry)\n        public\n        pure\n        returns (bytes32 commitment)\n    {\n        // Next call reverts if the input is not in the SNARK field\n        commitment = PoseidonHashers.poseidonT4(\n            [bytes32(pubKey.x), bytes32(pubKey.y), bytes32(uint256(expiry))]\n        );\n    }\n\n    /// @notice Register a public key. Only the keyring operator may call.\n    function registerKey(\n        uint16 keyringId,\n        G1Point memory pubKey,\n        uint32 expiry,\n        bytes32[] memory proofSiblings,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenTreeUnlocked returns (uint16 keyIndex) {\n        require(expiry > _timeNow(), ERR_INVALID_KEY_EXPIRY);\n\n        bytes32 keyPacked = BabyJubJub.pointPack(pubKey);\n        address operator = recoverOperator(\n            keyringId,\n            keyPacked,\n            expiry,\n            v,\n            r,\n            s\n        );\n\n        Keyring memory keyring = _getOperatorActiveKeyringOrRevert(\n            keyringId,\n            operator\n        );\n\n        require(\n            keyring.numAllocKeys >= keyring.numKeys,\n            ERR_INSUFFICIENT_ALLOCATION\n        );\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n\n        keyIndex = _totalNumRegisteredKeys;\n        keyringIds[keyIndex] = keyringId;\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            ZERO_VALUE,\n            commitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        _totalNumRegisteredKeys = ++keyIndex;\n\n        keyring.numKeys++;\n        keyrings[keyringId] = keyring;\n\n        emit KeyRegistered(keyringId, keyIndex, keyPacked, expiry);\n    }\n\n    /// @notice Extend the key expiry time. Only the keyring operator may call.\n    function extendKeyExpiry(\n        G1Point memory pubKey,\n        uint32 expiry,\n        uint32 newExpiry,\n        uint16 keyIndex,\n        bytes32[] memory proofSiblings\n    ) external whenTreeUnlocked {\n        require(\n            newExpiry > _timeNow() && newExpiry > expiry,\n            ERR_INVALID_KEY_EXPIRY\n        );\n        uint16 keyringId = keyringIds[keyIndex];\n        _getOperatorActiveKeyringOrRevert(keyringId, msg.sender);\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n        bytes32 newCommitment = getKeyCommitment(pubKey, newExpiry);\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            commitment,\n            newCommitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        emit KeyExtended(keyringId, keyIndex, newExpiry);\n    }\n\n    /// @notice Update keyring operator. Only the (current) operator may call.\n    function updateKeyringOperator(uint16 keyringId, address newOperator)\n        external\n    {\n        require(newOperator != address(0), ERR_ZERO_OPERATOR_ADDRESS);\n\n        Keyring memory keyring = _getOperatorActiveKeyringOrRevert(\n            keyringId,\n            msg.sender\n        );\n        require(newOperator != msg.sender, ERR_SAME_OPERATOR);\n\n        keyring.operator = newOperator;\n        keyrings[keyringId] = keyring;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    /// @notice Revoke registered key. Either the operator or the owner may call.\n    /// @dev It sets the `expiry` to 0, which is an indicator of a revoked key.\n    function revokeKey(\n        uint16 keyringId,\n        uint16 keyIndex,\n        G1Point memory pubKey,\n        uint32 expiry,\n        bytes32[] calldata proofSiblings\n    ) external keyInKeyring(keyIndex, keyringId) {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n\n        if (keyring.operator == msg.sender) {\n            _requireTreeIsUnlocked();\n        } else {\n            require(OWNER == msg.sender, ERR_UNAUTHORIZED_OPERATOR);\n        }\n\n        bytes32 commitment = getKeyCommitment(pubKey, expiry);\n\n        bytes32 newCommitment = getKeyCommitment(pubKey, REVOKED_KEY_EXPIRY);\n\n        _updateProvidersKeysAndStaticTreeRoots(\n            commitment,\n            newCommitment,\n            keyIndex,\n            proofSiblings\n        );\n\n        emit KeyRevoked(keyringId, keyIndex);\n    }\n\n    /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    function addKeyring(address operator, uint16 numAllocKeys)\n        external\n        onlyOwner\n    {\n        require(operator != address(0), ERR_ZERO_OPERATOR_ADDRESS);\n\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        numAllocatedKeys += numAllocKeys;\n        require(MAX_KEYS >= numAllocatedKeys, ERR_TOO_HIGH_ALLOCATION);\n\n        uint16 keyringId = _getNextKeyringId();\n        keyrings[keyringId] = Keyring({\n            operator: operator,\n            status: STATUS.ACTIVE,\n            numKeys: 0,\n            numAllocKeys: numAllocKeys,\n            registrationBlock: UtilsLib.safe32BlockNow(),\n            _unused: 0\n        });\n\n        _numKeyrings = keyringId;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(keyringId, operator, STATUS.ACTIVE, numAllocKeys);\n    }\n\n    function suspendKeyring(uint16 keyringId) external onlyOwner {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n\n        _totalNumAllocatedKeys -= _getUnusedKeyringAllocation(keyring);\n\n        keyrings[keyringId] = _suspendKeyring(keyring);\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function reactivateKeyring(uint16 keyringId) external onlyOwner {\n        Keyring memory keyring = keyrings[keyringId];\n        require(\n            keyring.status == STATUS.SUSPENDED,\n            ERR_KEYRING_ALREADY_ACTIVATED\n        );\n\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        // Unused allocation before suspending. To be allocated again.\n        uint16 keyringUnusedKeys = _getUnusedKeyringAllocation(keyring);\n        numAllocatedKeys += keyringUnusedKeys;\n\n        // When there is not enough empty keys to give back to keyring\n        if (numAllocatedKeys > MAX_KEYS) {\n            keyringUnusedKeys =\n                MAX_KEYS -\n                (numAllocatedKeys - keyringUnusedKeys);\n\n            numAllocatedKeys = MAX_KEYS;\n        }\n\n        keyring.status = STATUS.ACTIVE;\n        keyrings[keyringId] = keyring;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function increaseKeyringKeyAllocation(uint16 keyringId, uint16 allocation)\n        external\n        onlyOwner\n    {\n        Keyring memory keyring = _getActiveKeyringOrRevert(keyringId);\n        uint16 numAllocatedKeys = _totalNumAllocatedKeys;\n        numAllocatedKeys += allocation;\n        require(MAX_KEYS >= numAllocatedKeys, ERR_TOO_HIGH_ALLOCATION);\n\n        uint16 newKeyringAllocation = keyring.numAllocKeys + allocation;\n\n        keyrings[keyringId].numAllocKeys = newKeyringAllocation;\n        _totalNumAllocatedKeys = numAllocatedKeys;\n\n        emit KeyringUpdated(\n            keyringId,\n            keyring.operator,\n            keyring.status,\n            keyring.numAllocKeys\n        );\n    }\n\n    function updateTreeLock(uint32 lockPeriod) external onlyOwner {\n        require(\n            lockPeriod <= MAX_TREE_LOCK_PERIOD,\n            ERR_TREE_LOCK_ALREADY_UPDATED\n        );\n        uint32 timestamp = UtilsLib.safe32(_timeNow() + lockPeriod);\n        _treeLockedTillTime = timestamp;\n\n        emit TreeLockUpdated(timestamp);\n    }\n\n    /* ========== INTERNAL & PRIVATE FUNCTIONS ========== */\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        // Next call reverts if the input is not in the SNARK field\n        return PoseidonHashers.poseidonT3(input);\n    }\n\n    function zeroRoot() internal pure override returns (bytes32) {\n        return SIXTEEN_LEVEL_EMPTY_TREE_ROOT;\n    }\n\n    function _getNextKeyringId() private view returns (uint16) {\n        return _numKeyrings + 1;\n    }\n\n    function _getActiveKeyringOrRevert(uint16 keyringId)\n        private\n        view\n        returns (Keyring memory keyring)\n    {\n        keyring = keyrings[keyringId];\n\n        require(keyring.operator != address(0), ERR_KEYRING_NOT_EXISTS);\n        require(keyring.status == STATUS.ACTIVE, ERR_KEYRING_NOT_ACTIVATED);\n    }\n\n    function _getOperatorActiveKeyringOrRevert(\n        uint16 keyringId,\n        address operator\n    ) private view returns (Keyring memory keyring) {\n        keyring = _getActiveKeyringOrRevert(keyringId);\n        require(keyring.operator == operator, ERR_UNAUTHORIZED_OPERATOR);\n    }\n\n    function _suspendKeyring(Keyring memory keyring)\n        private\n        pure\n        returns (Keyring memory)\n    {\n        keyring.status = STATUS.SUSPENDED;\n        return keyring;\n    }\n\n    function _getUnusedKeyringAllocation(Keyring memory keyring)\n        private\n        pure\n        returns (uint16)\n    {\n        return keyring.numAllocKeys - keyring.numKeys;\n    }\n\n    function _updateProvidersKeysAndStaticTreeRoots(\n        bytes32 leaf,\n        bytes32 newLeaf,\n        uint16 keyIndex,\n        bytes32[] memory proofSiblings\n    ) private {\n        require(\n            proofSiblings.length == KEYS_TREE_DEPTH,\n            ERR_INCORRECT_SIBLINGS_SIZE\n        );\n\n        bytes32 updatedRoot = update(\n            _treeRoot,\n            leaf,\n            newLeaf,\n            keyIndex,\n            proofSiblings\n        );\n\n        _treeRoot = updatedRoot;\n\n        // trusted contract - no reentrancy guard needed\n        // slither-disable-next-line unchecked-transfer,reentrancy-events\n        PANTHER_STATIC_TREE.updateRoot(\n            updatedRoot,\n            PROVIDERS_KEYS_STATIC_LEAF_INDEX\n        );\n    }\n\n    function _requireTreeIsUnlocked() private view {\n        require(_timeNow() >= _treeLockedTillTime, ERR_TREE_IS_LOCKED);\n    }\n\n    function _timeNow() private view returns (uint32) {\n        // Time comparison accuracy is acceptable\n        // slither-disable-next-line timestamp\n        return UtilsLib.safe32TimeNow();\n    }\n}\n"
    },
    "contracts/protocol/providersKeys/ProvidersKeysSignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../../common/EIP712SignatureVerifier.sol\";\n\nabstract contract ProvidersKeysSignatureVerifier is EIP712SignatureVerifier {\n    // solhint-disable var-name-mixedcase\n\n    bytes32 internal constant REGISTRATION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"Registration(uint32 keyringId,bytes32 pubRootSpendingKey,uint32 expiryDate,uint256 version)\"\n            )\n        );\n\n    uint8 public immutable KEYRING_VERSION;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(uint8 keyringVersion) {\n        KEYRING_VERSION = keyringVersion;\n    }\n\n    function getRegistrationDataHash(\n        uint32 _keyringId,\n        bytes32 _pubRootSpendingKey,\n        uint32 _expiryDate\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    REGISTRATION_TYPEHASH,\n                    _keyringId,\n                    _pubRootSpendingKey,\n                    _expiryDate,\n                    uint256(KEYRING_VERSION)\n                )\n            );\n    }\n\n    function recoverOperator(\n        uint32 _keyringId,\n        bytes32 _pubRootSpendingKey,\n        uint32 _expiryDate,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 registrationDataHash = getRegistrationDataHash(\n            _keyringId,\n            _pubRootSpendingKey,\n            _expiryDate\n        );\n\n        bytes32 typedDataHash = toTypedDataHash(registrationDataHash);\n\n        return recover(typedDataHash, v, r, s);\n    }\n}\n"
    },
    "contracts/protocol/ZAccountsRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"./interfaces/IOnboardingController.sol\";\nimport \"./interfaces/IPantherPoolV1.sol\";\nimport \"./pantherForest/interfaces/ITreeRootUpdater.sol\";\n\nimport \"./crypto/BabyJubJub.sol\";\nimport { FIELD_SIZE } from \"./crypto/SnarkConstants.sol\";\n\nimport \"./zAccountsRegistry/BlacklistedZAccountIdsTree.sol\";\nimport \"./zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol\";\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/Types.sol\";\nimport \"../common/UtilsLib.sol\";\nimport { ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX } from \"./pantherForest/Constants.sol\";\n\n/**\n * @title ZAccountsRegistry\n * @author Pantherprotocol Contributors\n * @notice Registry and whitelist of zAccounts allowed to interact with MASP.\n */\n\n// solhint-disable contract-name-camelcase\ncontract ZAccountsRegistry is\n    ImmutableOwnable,\n    BlacklistedZAccountIdsTree,\n    ZAccountsRegeistrationSignatureVerifier\n{\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    enum ZACCOUNT_STATUS {\n        UNDEFINED,\n        REGISTERED,\n        ACTIVATED\n    }\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant ZACCOUNT_ID_COUNTER_JUMP = 2;\n\n    IPantherPoolV1 public immutable PANTHER_POOL;\n    ITreeRootUpdater public immutable PANTHER_STATIC_TREE;\n    IOnboardingController public immutable ONBOARDING_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    struct ZAccount {\n        uint224 _unused; // reserved\n        uint24 id; // the ZAccount id, starts from 0\n        uint8 version; // ZAccount version\n        bytes32 pubRootSpendingKey;\n        bytes32 pubReadingKey;\n    }\n\n    uint256 public zAccountIdTracker;\n\n    mapping(bytes32 => uint256) public zoneZAccountNullifiers;\n    mapping(address => ZACCOUNT_STATUS) public zAccountStatus;\n    mapping(address => bool) public isMasterEoaBlacklisted;\n    mapping(bytes32 => bool) public isPubRootSpendingKeyBlacklisted;\n    mapping(uint24 => bool) public isZAccountIdBlacklisted;\n\n    // Mapping from `MasterEoa` to ZAccount (i.e. params of an ZAccount)\n    mapping(address => ZAccount) public zAccounts;\n\n    // Mapping from zAccount Id to Master Eoa\n    mapping(uint24 => address) public masterEOAs;\n\n    event ZAccountRegistered(address masterEoa, ZAccount zAccount);\n    event ZAccountActivated(uint24 id);\n    event BlacklistForZAccountIdUpdated(uint24 zAccountId, bool isBlackListed);\n    event BlacklistForMasterEoaUpdated(address masterEoa, bool isBlackListed);\n    event BlacklistForPubRootSpendingKeyUpdated(\n        bytes32 packedPubRootSpendingKey,\n        bool isBlackListed\n    );\n\n    constructor(\n        address _owner,\n        uint8 _zAccountVersion,\n        address pantherPool,\n        address pantherStaticTree,\n        address onboardingController\n    )\n        ImmutableOwnable(_owner)\n        ZAccountsRegeistrationSignatureVerifier(_zAccountVersion)\n    {\n        require(\n            pantherPool != address(0) &&\n                pantherStaticTree != address(0) &&\n                onboardingController != address(0),\n            ERR_INIT_CONTRACT\n        );\n\n        PANTHER_POOL = IPantherPoolV1(pantherPool);\n        PANTHER_STATIC_TREE = ITreeRootUpdater(pantherStaticTree);\n        ONBOARDING_CONTROLLER = IOnboardingController(onboardingController);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function isZAccountWhitelisted(address _masterEOA)\n        external\n        view\n        returns (bool isWhitelisted)\n    {\n        ZAccount memory _zAccount = zAccounts[_masterEOA];\n\n        bool isZAccountExists = masterEOAs[_zAccount.id] != address(0);\n\n        (bool isBlacklisted, ) = _isBlacklisted(\n            _zAccount.id,\n            _masterEOA,\n            _zAccount.pubRootSpendingKey\n        );\n\n        return isZAccountExists && !isBlacklisted;\n    }\n\n    /* ========== EXTERNAL FUNCTIONS ========== */\n\n    function registerZAccount(\n        G1Point memory _pubRootSpendingKey,\n        G1Point memory _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        bytes32 pubRootSpendingKeyPacked = BabyJubJub.pointPack(\n            _pubRootSpendingKey\n        );\n        bytes32 pubReadingKeyPacked = BabyJubJub.pointPack(_pubReadingKey);\n\n        require(\n            !isPubRootSpendingKeyBlacklisted[pubRootSpendingKeyPacked],\n            ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n        );\n\n        address masterEoa = recoverMasterEoa(\n            pubRootSpendingKeyPacked,\n            pubReadingKeyPacked,\n            v,\n            r,\n            s\n        );\n\n        require(!isMasterEoaBlacklisted[masterEoa], ERR_BLACKLIST_MASTER_EOA);\n        require(\n            zAccountStatus[masterEoa] == ZACCOUNT_STATUS.UNDEFINED,\n            ERR_DUPLICATED_MASTER_EOA\n        );\n\n        uint24 zAccountId = uint24(_getNextZAccountId());\n\n        ZAccount memory _zAccount = ZAccount({\n            _unused: uint224(0),\n            id: zAccountId,\n            version: uint8(ZACCOUNT_VERSION),\n            pubRootSpendingKey: pubRootSpendingKeyPacked,\n            pubReadingKey: pubReadingKeyPacked\n        });\n\n        masterEOAs[zAccountId] = masterEoa;\n        zAccounts[masterEoa] = _zAccount;\n        zAccountStatus[masterEoa] = ZACCOUNT_STATUS.REGISTERED;\n\n        emit ZAccountRegistered(masterEoa, _zAccount);\n    }\n\n    /// @param inputs[0]  - extraInputsHash\n    /// @param inputs[1]  - zkpAmount\n    /// @param inputs[2]  - zkpChange (passed w/o checks)\n    /// @param inputs[3]  - zAccountId\n    /// @param inputs[4]  - zAccountPrpAmount\n    /// @param inputs[5]  - zAccountCreateTime (passed w/o checks)\n    /// @param inputs[6]  - zAccountRootSpendPubKeyX\n    /// @param inputs[7]  - zAccountRootSpendPubKeyY\n    /// @param inputs[8]  - zAccountMasterEOA\n    /// @param inputs[9]  - zAccountNullifier\n    /// @param inputs[10] - zAccountCommitment\n    /// @param inputs[11] - kycSignedMessageHash\n    /// @param inputs[12] - forestMerkleRoot (passed w/o checks)\n    /// @param inputs[13] - saltHash (passed w/o checks)\n    /// @param inputs[14] - magicalConstraint (passed w/o checks)\n    function activateZAccount(\n        uint256[] calldata inputs,\n        bytes memory secretMessage,\n        SnarkProof calldata proof,\n        uint256 cachedForestRootIndex\n    ) external returns (uint256 utxoBusQueuePos) {\n        {\n            uint256 extraInputsHash = inputs[0];\n            bytes memory extraInp = abi.encodePacked(\n                secretMessage,\n                cachedForestRootIndex\n            );\n            require(\n                extraInputsHash == uint256(keccak256(extraInp)) % FIELD_SIZE,\n                ERR_INVALID_EXTRA_INPUT_HASH\n            );\n        }\n        {\n            uint256 zAccountPrpAmount = inputs[4];\n            // No PRP rewards provided on zAccount activation\n            require(zAccountPrpAmount == 0, ERR_UNEXPECTED_PRP_AMOUNT);\n        }\n        // TODO: review if some of pub signals checks should be moved to PantherPoolV1\n        {\n            uint256 zAccountCommitment = inputs[10];\n            require(zAccountCommitment != 0, ERR_ZERO_ZACCOUNT_COMMIT);\n        }\n        {\n            uint256 kycSignedMessageHash = inputs[11];\n            require(kycSignedMessageHash != 0, ERR_ZERO_KYC_MSG_HASH);\n        }\n\n        uint24 zAccountId = UtilsLib.safe24(inputs[3]);\n        address zAccountMasterEOA = address(uint160(inputs[8]));\n\n        require(\n            masterEOAs[zAccountId] == zAccountMasterEOA,\n            ERR_UNKNOWN_ZACCOUNT\n        );\n\n        {\n            bytes32 zAccountRootSpendPubKey = BabyJubJub.pointPack(\n                G1Point({ x: inputs[6], y: inputs[7] })\n            );\n            (bool isBlacklisted, string memory errMsg) = _isBlacklisted(\n                zAccountId,\n                zAccountMasterEOA,\n                zAccountRootSpendPubKey\n            );\n            require(!isBlacklisted, errMsg);\n        }\n        {\n            // Prevent double-activation for the same zone and network\n            bytes32 zAccountNullifier = bytes32(inputs[9]);\n            require(\n                zoneZAccountNullifiers[zAccountNullifier] == 0,\n                ERR_DUPLICATED_NULLIFIER\n            );\n\n            zoneZAccountNullifiers[zAccountNullifier] = block.number;\n        }\n\n        ZACCOUNT_STATUS userPrevStatus = zAccountStatus[zAccountMasterEOA];\n\n        // if the status is registered, then change it to activate.\n        // If status is already activated, it means  Zaccount is activated at least in 1 zone.\n        if (userPrevStatus == ZACCOUNT_STATUS.REGISTERED) {\n            zAccountStatus[zAccountMasterEOA] = ZACCOUNT_STATUS.ACTIVATED;\n        }\n\n        {\n            uint256 _zkpRewards = _notifyOnboardingController(\n                zAccountMasterEOA,\n                uint8(userPrevStatus),\n                uint8(ZACCOUNT_STATUS.ACTIVATED),\n                new bytes(0)\n            );\n            uint256 zkpAmount = inputs[1];\n            require(_zkpRewards == zkpAmount, ERR_UNEXPECTED_ZKP_AMOUNT);\n        }\n\n        utxoBusQueuePos = _createZAccountUTXO(\n            inputs,\n            proof,\n            secretMessage,\n            cachedForestRootIndex\n        );\n\n        emit ZAccountActivated(zAccountId);\n    }\n\n    // /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    function batchUpdateBlacklistForMasterEoa(\n        address[] calldata masterEoas,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            masterEoas.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < masterEoas.length; ) {\n            require(\n                isMasterEoaBlacklisted[masterEoas[i]] != isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isMasterEoaBlacklisted[masterEoas[i]] = isBlackListed[i];\n\n            emit BlacklistForMasterEoaUpdated(masterEoas[i], isBlackListed[i]);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function batchUpdateBlacklistForPubRootSpendingKey(\n        bytes32[] calldata packedPubRootSpendingKeys,\n        bool[] calldata isBlackListed\n    ) external onlyOwner {\n        require(\n            packedPubRootSpendingKeys.length == isBlackListed.length,\n            ERR_MISMATCH_ARRAYS_LENGTH\n        );\n\n        for (uint256 i = 0; i < packedPubRootSpendingKeys.length; ) {\n            require(\n                isPubRootSpendingKeyBlacklisted[packedPubRootSpendingKeys[i]] !=\n                    isBlackListed[i],\n                ERR_REPETITIVE_STATUS\n            );\n\n            isPubRootSpendingKeyBlacklisted[\n                packedPubRootSpendingKeys[i]\n            ] = isBlackListed[i];\n\n            emit BlacklistForPubRootSpendingKeyUpdated(\n                packedPubRootSpendingKeys[i],\n                isBlackListed[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function updateBlacklistForZAccountId(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] calldata proofSiblings,\n        bool isBlacklisted\n    ) public onlyOwner {\n        require(masterEOAs[zAccountId] != address(0), ERR_UNKNOWN_ZACCOUNT);\n        require(\n            isZAccountIdBlacklisted[zAccountId] != isBlacklisted,\n            ERR_REPETITIVE_STATUS\n        );\n\n        bytes32 blacklistedZAccountIdsTreeRoot;\n\n        if (isBlacklisted) {\n            blacklistedZAccountIdsTreeRoot = _addZAccountIdToBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        } else {\n            blacklistedZAccountIdsTreeRoot = _removeZAccountIdFromBlacklist(\n                zAccountId,\n                leaf,\n                proofSiblings\n            );\n        }\n\n        isZAccountIdBlacklisted[zAccountId] = isBlacklisted;\n\n        // Trusted contract - no reentrancy guard needed\n        PANTHER_STATIC_TREE.updateRoot(\n            blacklistedZAccountIdsTreeRoot,\n            ZACCOUNT_BLACKLIST_STATIC_LEAF_INDEX\n        );\n\n        emit BlacklistForZAccountIdUpdated(zAccountId, isBlacklisted);\n    }\n\n    // /* ========== PRIVATE FUNCTIONS ========== */\n\n    function _getNextZAccountId() internal returns (uint256 curId) {\n        curId = zAccountIdTracker;\n        zAccountIdTracker = curId & 0xFF < 254\n            ? curId + 1\n            : curId + ZACCOUNT_ID_COUNTER_JUMP;\n    }\n\n    function _createZAccountUTXO(\n        uint256[] calldata inputs,\n        SnarkProof calldata proof,\n        bytes memory secretMessage,\n        uint256 cachedForestRootIndex\n    ) private returns (uint256 utxoBusQueuePos) {\n        utxoBusQueuePos = 0;\n        // Pool is supposed to revert in case of any error\n        try\n            // Trusted contract - no reentrancy guard needed\n            PANTHER_POOL.createZAccountUtxo(\n                inputs,\n                proof,\n                secretMessage,\n                cachedForestRootIndex\n            )\n        returns (uint256 result) {\n            utxoBusQueuePos = result;\n        } catch Error(string memory reason) {\n            revert(reason);\n        }\n    }\n\n    function _notifyOnboardingController(\n        address _user,\n        uint8 _prevStatus,\n        uint8 _newStatus,\n        bytes memory _data\n    ) private returns (uint256 _zkpRewards) {\n        // Trusted contract - no reentrancy guard needed\n        _zkpRewards = ONBOARDING_CONTROLLER.grantRewards(\n            _user,\n            _prevStatus,\n            _newStatus,\n            _data\n        );\n    }\n\n    function _isBlacklisted(\n        uint24 id,\n        address _masterEOA,\n        bytes32 pubRootSpendingKey\n    ) private view returns (bool isBlaklisted, string memory err) {\n        if (isZAccountIdBlacklisted[id]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_ZACCOUNT_ID);\n        }\n        if (isMasterEoaBlacklisted[_masterEOA]) {\n            err = _formatBlackListError(err, ERR_BLACKLIST_MASTER_EOA);\n        }\n        if (isPubRootSpendingKeyBlacklisted[pubRootSpendingKey]) {\n            err = _formatBlackListError(\n                err,\n                ERR_BLACKLIST_PUB_ROOT_SPENDING_KEY\n            );\n        }\n\n        return (isBlaklisted = bytes(err).length > 0 ? true : false, err);\n    }\n\n    function _formatBlackListError(\n        string memory currentErrMsg,\n        string memory errToBeAdded\n    ) private pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(currentErrMsg).length > 0\n                        ? string(abi.encodePacked(currentErrMsg, \",\"))\n                        : \"\",\n                    errToBeAdded\n                )\n            );\n    }\n\n    /// @dev Concatenate the strings together and returns the result\n    function formatBlackListError(\n        string memory content,\n        string memory contentToBeAdded,\n        string memory separator\n    ) internal pure returns (string memory newErrMsg) {\n        return\n            string(\n                abi.encodePacked(\n                    bytes(content).length > 0\n                        ? string(abi.encodePacked(content, separator))\n                        : \"\",\n                    contentToBeAdded\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/BlacklistedZAccountIdsTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../pantherForest/interfaces/ITreeRootGetter.sol\";\n\nimport \"../pantherForest/merkleTrees/BinaryUpdatableTree.sol\";\nimport \"../errMsgs/ZAccountsRegistryErrMsgs.sol\";\n\nimport \"../crypto/PoseidonHashers.sol\";\nimport { FIELD_SIZE } from \"../crypto/SnarkConstants.sol\";\n\nabstract contract BlacklistedZAccountIdsTree is\n    BinaryUpdatableTree,\n    ITreeRootGetter\n{\n    // The current root of merkle tree.\n    // If it's undefined, the `zeroRoot()` shall be called.\n    bytes32 private _currentRoot;\n\n    function getRoot() external view returns (bytes32) {\n        return _currentRoot == bytes32(0) ? zeroRoot() : _currentRoot;\n    }\n\n    function _getZAccountFlagAndLeafIndexes(uint24 zAccountId)\n        internal\n        pure\n        returns (uint256 flagIndex, uint256 leafIndex)\n    {\n        // getting index which is between 0 and 253\n        flagIndex = zAccountId & 0xFF;\n\n        require(\n            flagIndex >= 0 && flagIndex < 254,\n            ERR_INVALID_ZACCOUNT_FLAG_POSITION\n        );\n\n        // getting the 16 MSB from uint24\n        leafIndex = zAccountId >> 8;\n    }\n\n    function _addZAccountIdToBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) | (1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function _removeZAccountIdFromBlacklist(\n        uint24 zAccountId,\n        bytes32 leaf,\n        bytes32[] memory proofSiblings\n    ) internal returns (bytes32 _updatedRoot) {\n        (uint256 flagIndex, uint256 leafIndex) = _getZAccountFlagAndLeafIndexes(\n            zAccountId\n        );\n\n        uint256 newLeaf = uint256(leaf) & ~(1 << flagIndex);\n\n        _updatedRoot = update(\n            _currentRoot,\n            leaf,\n            bytes32(newLeaf),\n            leafIndex,\n            proofSiblings\n        );\n\n        _currentRoot = _updatedRoot;\n    }\n\n    function hash(bytes32[2] memory input)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        return PoseidonHashers.poseidonT3(input);\n    }\n\n    //@dev returns the root of tree with depth 16 where each leaf is 0\n    function zeroRoot() internal pure override returns (bytes32) {\n        /**\n        '0x0000000000000000000000000000000000000000000000000000000000000000'   Level 0\n        '0x2098f5fb9e239eab3ceac3f27b81e481dc3124d55ffed523a839ee8446b64864'   Level 1\n        '0x1069673dcdb12263df301a6ff584a7ec261a44cb9dc68df067a4774460b1f1e1'   Level 2\n        '0x18f43331537ee2af2e3d758d50f72106467c6eea50371dd528d57eb2b856d238'   Level 3\n        '0x07f9d837cb17b0d36320ffe93ba52345f1b728571a568265caac97559dbc952a'   Level 4\n        '0x2b94cf5e8746b3f5c9631f4c5df32907a699c58c94b2ad4d7b5cec1639183f55'   Level 5\n        '0x2dee93c5a666459646ea7d22cca9e1bcfed71e6951b953611d11dda32ea09d78'   Level 6\n        '0x078295e5a22b84e982cf601eb639597b8b0515a88cb5ac7fa8a4aabe3c87349d'   Level 7\n        '0x2fa5e5f18f6027a6501bec864564472a616b2e274a41211a444cbe3a99f3cc61'   Level 8\n        '0x0e884376d0d8fd21ecb780389e941f66e45e7acce3e228ab3e2156a614fcd747'   Level 9\n        '0x1b7201da72494f1e28717ad1a52eb469f95892f957713533de6175e5da190af2'   Level 10\n        '0x1f8d8822725e36385200c0b201249819a6e6e1e4650808b5bebc6bface7d7636'   Level 11\n        '0x2c5d82f66c914bafb9701589ba8cfcfb6162b0a12acf88a8d0879a0471b5f85a'   Level 12\n        '0x14c54148a0940bb820957f5adf3fa1134ef5c4aaa113f4646458f270e0bfbfd0'   Level 13\n        '0x190d33b12f986f961e10c0ee44d8b9af11be25588cad89d416118e4bf4ebe80c'   Level 14\n        '0x22f98aa9ce704152ac17354914ad73ed1167ae6596af510aa5b3649325e06c92'   Level 15\n         */\n        return\n            bytes32(\n                uint256(\n                    0x2a7c7c9b6ce5880b9f6f228d72bf6a575a526f29c66ecceef8b753d38bba7323\n                )\n            );\n    }\n}\n"
    },
    "contracts/protocol/zAccountsRegistry/ZAccountsRegeistrationSignatureVerifier.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../../common/EIP712SignatureVerifier.sol\";\n\nabstract contract ZAccountsRegeistrationSignatureVerifier is\n    EIP712SignatureVerifier\n{\n    // solhint-disable var-name-mixedcase\n\n    bytes32 internal constant REGISTRATION_TYPEHASH =\n        keccak256(\n            bytes(\n                \"Registration(bytes32 pubRootSpendingKey,bytes32 pubReadingKey,uint256 version)\"\n            )\n        );\n\n    uint8 public immutable ZACCOUNT_VERSION;\n\n    // solhint-enable var-name-mixedcase\n\n    constructor(uint8 zAccountVersion) {\n        ZACCOUNT_VERSION = zAccountVersion;\n    }\n\n    function getRegistrationDataHash(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey\n    ) internal view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    REGISTRATION_TYPEHASH,\n                    _pubRootSpendingKey,\n                    _pubReadingKey,\n                    uint256(ZACCOUNT_VERSION)\n                )\n            );\n    }\n\n    function recoverMasterEoa(\n        bytes32 _pubRootSpendingKey,\n        bytes32 _pubReadingKey,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address) {\n        bytes32 registrationDataHash = getRegistrationDataHash(\n            _pubRootSpendingKey,\n            _pubReadingKey\n        );\n\n        bytes32 typedDataHash = toTypedDataHash(registrationDataHash);\n\n        return recover(typedDataHash, v, r, s);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}