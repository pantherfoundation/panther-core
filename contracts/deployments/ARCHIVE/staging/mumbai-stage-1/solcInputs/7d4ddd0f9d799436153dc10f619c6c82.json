{
  "language": "Solidity",
  "sources": {
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title TransferHelper library\n/// @dev Helper methods for interacting with ERC20, ERC721, ERC1155 tokens and sending ETH\n/// Based on the Uniswap/solidity-lib/contracts/libraries/TransferHelper.sol\nlibrary TransferHelper {\n    /// @dev Throws if the deployed code of the `token` is empty.\n    // Low-level CALL to a non-existing contract returns `success` of 1 and empty `data`.\n    // It may be misinterpreted as a successful call to a deployed token contract.\n    // So, the code calling a token contract must insure the contract code exists.\n    modifier onlyDeployedToken(address token) {\n        uint256 codeSize;\n        // slither-disable-next-line assembly\n        assembly {\n            codeSize := extcodesize(token)\n        }\n        require(codeSize > 0, \"TransferHelper: zero codesize\");\n        _;\n    }\n\n    /// @dev Approve the `operator` to spend all of ERC720 tokens on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeSetApprovalForAll(\n        address token,\n        address operator,\n        bool approved\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('setApprovalForAll(address,bool)'));\n            abi.encodeWithSelector(0xa22cb465, operator, approved)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Get the ERC20 balance of `account`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeBalanceOf(address token, address account)\n        internal\n        returns (uint256 balance)\n    {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(bytes('balanceOf(address)')));\n            abi.encodeWithSelector(0x70a08231, account)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: balanceOf call failed\"\n        );\n\n        balance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Get the ERC20 allowance of `spender`\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeAllowance(\n        address token,\n        address owner,\n        address spender\n    ) internal onlyDeployedToken(token) returns (uint256 allowance) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(\"allowance(address,address)\"));\n            abi.encodeWithSelector(0xdd62ed3e, owner, spender)\n        );\n        require(\n            // since `data` can't be empty, `onlyDeployedToken` unneeded\n            success && (data.length != 0),\n            \"TransferHelper: allowance call failed\"\n        );\n\n        allowance = abi.decode(data, (uint256));\n    }\n\n    /// @dev Approve the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('approve(address,uint256)'));\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Increase approval of the `spender` to spend the `amount` of ERC20 token on behalf of `owner`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeIncreaseAllowance(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256(\"increaseAllowance(address,uint256)\"));\n            abi.encodeWithSelector(0x39509351, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transfer(address,uint256)'));\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` ERC20 tokens on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('transferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer an ERC721 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc721SafeTransferFrom(\n        address token,\n        uint256 tokenId,\n        address from,\n        address to\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256)'));\n            abi.encodeWithSelector(0x42842e0e, from, to, tokenId)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `amount` ERC1155 token with id of `tokenId` on behalf of `from` to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function erc1155SafeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory _data\n    ) internal onlyDeployedToken(token) {\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)'));\n            abi.encodeWithSelector(0xf242432a, from, to, tokenId, amount, _data)\n        );\n        _requireSuccess(success, data);\n    }\n\n    /// @dev Transfer `value` Ether from caller to `to`.\n    // disabled since false positive\n    // slither-disable-next-line dead-code\n    function safeTransferETH(address to, uint256 value) internal {\n        // slither-disable-next-line low-level-calls\n        (bool success, ) = to.call{ value: value }(new bytes(0));\n        require(success, \"TransferHelper: ETH transfer failed\");\n    }\n\n    function _requireSuccess(bool success, bytes memory res) private pure {\n        require(\n            success && (res.length == 0 || abi.decode(res, (bool))),\n            \"TransferHelper: token contract call failed\"\n        );\n    }\n}\n"
    },
    "contracts/protocol/OnboardingController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity 0.8.16;\n\nimport \"../common/ImmutableOwnable.sol\";\nimport \"../common/TransferHelper.sol\";\nimport { HUNDRED_PERCENT } from \"../common/Constants.sol\";\n\ncontract OnboardingController is ImmutableOwnable {\n    using TransferHelper for address;\n\n    // solhint-disable var-name-mixedcase\n\n    uint256 private constant ZERO_REWARD = 0;\n\n    address public immutable ZACCOUNT_REGISTRY;\n    address public immutable ZKP_TOKEN;\n    address public immutable VAULT;\n    address public immutable RESERVE_CONTROLLER;\n\n    // solhint-enable var-name-mixedcase\n\n    struct RewardParams {\n        // reserved bytes\n        uint128 _unused;\n        // kyc provider ratio from zkpRewardsPerActivation\n        uint16 zkpRate;\n        // user ratio from zkpRewardsPerActivation\n        uint16 zZkpRate;\n        // zkp reward to be grant on each call.\n        uint96 rewardsPerGrant;\n    }\n\n    RewardParams public rewardParams;\n\n    uint128 public rewardsGranted;\n    uint128 public rewardsLimit;\n\n    mapping(address => bool) public isUserRewarded;\n\n    event RewardParamsUpdated(\n        uint96 rewardsPerGrant,\n        uint16 zkpRate,\n        uint16 zZkpRate\n    );\n    event RewardsLimtUpdated(uint256 rewardsLimit);\n    event ZzkpAllocated(address user, uint256 amount);\n    event ReserveControllerApproved(uint256 amount);\n\n    constructor(\n        address _owner,\n        address _zkpToken,\n        address _zAccountRegistry,\n        address _vault,\n        address _reserveController\n    ) ImmutableOwnable(_owner) {\n        require(\n            _zAccountRegistry != address(0) &&\n                _zkpToken != address(0) &&\n                _vault != address(0),\n            \"init: zero address\"\n        );\n\n        ZACCOUNT_REGISTRY = _zAccountRegistry;\n        ZKP_TOKEN = _zkpToken;\n        VAULT = _vault;\n        RESERVE_CONTROLLER = _reserveController;\n    }\n\n    function updateRewardParams(\n        uint96 _rewardsPerGrant,\n        uint16 _zkpRate,\n        uint16 _zZkpRate\n    ) external onlyOwner {\n        // if _rewardsPerGrant is defined, then sum of ratios should be 10000\n        // setting _rewardsPerGrant to 0 disables the program\n        require(\n            _rewardsPerGrant == 0 || (_zkpRate + _zZkpRate == HUNDRED_PERCENT),\n            \"invalid zkp ratio\"\n        );\n\n        rewardParams = RewardParams({\n            _unused: uint128(0),\n            zkpRate: _zkpRate,\n            zZkpRate: _zZkpRate,\n            rewardsPerGrant: _rewardsPerGrant\n        });\n\n        emit RewardParamsUpdated(_rewardsPerGrant, _zkpRate, _zZkpRate);\n    }\n\n    function updateRewardsLimitAndVaultAllowance() external {\n        // Getting the current allowance of ReserveController\n        uint256 reserveControllerAllowance = ZKP_TOKEN.safeAllowance(\n            address(this),\n            RESERVE_CONTROLLER\n        );\n        uint256 _rewardsLimit = rewardsLimit;\n\n        // Getting the unused rewards limit\n        uint256 unusedLimit = _rewardsLimit - rewardsGranted;\n\n        // The availabe balance (part of the balance is reserved and will be withdrawn from ReserveController)\n        uint256 available = ZKP_TOKEN.safeBalanceOf(address(this)) -\n            reserveControllerAllowance;\n\n        if (available == unusedLimit) return;\n\n        if (available > unusedLimit) {\n            uint256 newAllocation = available - unusedLimit;\n\n            _rewardsLimit += uint128(newAllocation);\n\n            // Approve the vault to transfer its zZkp portion\n            ZKP_TOKEN.safeIncreaseAllowance(VAULT, newAllocation);\n        } else {\n            // gracefully handle this unexpected situation\n            uint256 shortage = unusedLimit - available;\n\n            _rewardsLimit = _rewardsLimit > shortage\n                ? _rewardsLimit - shortage\n                : 0;\n        }\n\n        rewardsLimit = uint128(_rewardsLimit);\n\n        emit RewardsLimtUpdated(_rewardsLimit);\n    }\n\n    // TODO: review/update OnboardingController.grantRewards\n    // solhint-disable no-unused-vars\n    function grantRewards(\n        address _user,\n        uint8 _prevStatus,\n        uint8 _newStatus,\n        bytes memory _data\n    ) external returns (uint256 _zZkpRewardAlloc) {\n        _zZkpRewardAlloc = 100e18;\n\n        // require(msg.sender == ZACCOUNT_REGISTRY, \"unauthorized\");\n\n        // RewardParams memory _rewardParams = rewardParams;\n\n        // uint256 _rewardsGranted = rewardsGranted +\n        //     (_rewardParams.rewardsPerGrant);\n\n        // if (rewardsLimit >= _rewardsGranted) {\n        //     _zZkpRewardAlloc = _getZzkpRewardsAllocation(_rewardParams, _user);\n\n        //     _increaseReserveControllerAllowance(_rewardParams);\n\n        //     rewardsGranted = uint128(_rewardsGranted);\n        // }\n    }\n\n    // solhint-enable no-unused-vars\n\n    function _getZzkpRewardsAllocation(\n        RewardParams memory _rewardParams,\n        address _user\n    ) private returns (uint256 _zZkpRewardAlloc) {\n        // return 0 if has already got rewarded\n        if (isUserRewarded[_user]) return (_zZkpRewardAlloc);\n\n        // Calculate ZKP rewards allocation\n        _zZkpRewardAlloc =\n            ((_rewardParams.rewardsPerGrant) * _rewardParams.zZkpRate) /\n            HUNDRED_PERCENT;\n\n        if (_zZkpRewardAlloc > ZERO_REWARD) {\n            isUserRewarded[_user] = true;\n\n            emit ZzkpAllocated(_user, _zZkpRewardAlloc);\n        }\n    }\n\n    function _increaseReserveControllerAllowance(\n        RewardParams memory _rewardParams\n    ) private {\n        uint256 _zkpRewardAlloc = ((_rewardParams.rewardsPerGrant) *\n            _rewardParams.zkpRate) / HUNDRED_PERCENT;\n\n        if (_zkpRewardAlloc > ZERO_REWARD) {\n            ZKP_TOKEN.safeIncreaseAllowance(\n                RESERVE_CONTROLLER,\n                _zkpRewardAlloc\n            );\n\n            emit ReserveControllerApproved(_zkpRewardAlloc);\n        }\n    }\n\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}