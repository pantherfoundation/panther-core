{
  "language": "Solidity",
  "sources": {
    "contracts/common/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n// Constants\n\nuint256 constant IN_PRP_UTXOs = 1;\nuint256 constant IN_UTXOs = 2 + IN_PRP_UTXOs;\n\nuint256 constant OUT_PRP_UTXOs = 1;\nuint256 constant OUT_UTXOs = 2 + OUT_PRP_UTXOs;\nuint256 constant OUT_MAX_UTXOs = OUT_UTXOs;\n// Number of UTXOs given as a reward for an \"advanced\" stake\nuint256 constant OUT_RWRD_UTXOs = 2;\n\n// For overflow protection and circuits optimization\n// (must be less than the FIELD_SIZE)\nuint256 constant MAX_EXT_AMOUNT = 2**96;\nuint256 constant MAX_IN_CIRCUIT_AMOUNT = 2**64;\nuint256 constant MAX_TIMESTAMP = 2**32;\nuint256 constant MAX_ZASSET_ID = 2**160;\n\n// Token types\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant ERC20_TOKEN_TYPE = 0x00;\nuint8 constant ERC721_TOKEN_TYPE = 0x10;\nuint8 constant ERC1155_TOKEN_TYPE = 0x11;\n// defined for every tokenId rather than for all tokens on the contract\n// (unsupported in the V0 and V1 of the MASP)\nuint8 constant BY_TOKENID_TOKEN_TYPE = 0xFF;\n\n// ZAsset statuses\n// (not `enum` to let protocol extensions use bits, if needed)\nuint8 constant zASSET_ENABLED = 0x01;\nuint8 constant zASSET_DISABLED = 0x02;\nuint8 constant zASSET_UNKNOWN = 0x00;\n\n// UTXO data (opening values - encrypted and public) formats\nuint8 constant UTXO_DATA_TYPE5 = 0x00; // for zero UTXO (no data to provide)\nuint8 constant UTXO_DATA_TYPE1 = 0x01; // for UTXO w/ zero tokenId\nuint8 constant UTXO_DATA_TYPE3 = 0x02; // for UTXO w/ non-zero tokenId\n\n// Number of 32-bit words of the CiphertextMsg for UTXO_DATA_TYPE1\n// (ephemeral key (packed) - 32 bytes, encrypted `random` - 32 bytes)\nuint256 constant CIPHERTEXT1_WORDS = 2;\n\n// Number of 32-bit words in the (uncompressed) spending PubKey\nuint256 constant PUBKEY_WORDS = 2;\n// Number of elements in `pathElements`\nuint256 constant PATH_ELEMENTS_NUM = 16;\n\n// @dev Unusable on public network address, which is useful for simulations\n//  in forked test env, e.g. for bypassing SNARK proof verification like this:\n// `require(isValidProof || tx.origin == DEAD_CODE_ADDRESS)`\naddress constant DEAD_CODE_ADDRESS = address(uint160(0xDEADC0DE));\n\n// 100% expressed in 1/100th of 1% (\"pips\")\nuint256 constant HUNDRED_PERCENT = 100 * 100;\n"
    },
    "contracts/common/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/common/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// slither-disable-next-line solc-version\npragma solidity ^0.8.4;\n\nstruct G1Point {\n    uint256 x;\n    uint256 y;\n}\n\n// Encoding of field elements is: X[0] * z + X[1]\nstruct G2Point {\n    uint256[2] x;\n    uint256[2] y;\n}\n\n// Verification key for SNARK\nstruct VerifyingKey {\n    G1Point alfa1;\n    G2Point beta2;\n    G2Point gamma2;\n    G2Point delta2;\n    G1Point[] ic;\n}\n\nstruct SnarkProof {\n    G1Point a;\n    G2Point b;\n    G1Point c;\n}\n\nstruct PluginData {\n    address contractAddress;\n    bytes callData;\n}\n\nstruct ElGamalCiphertext {\n    G1Point c1;\n    G1Point c2;\n}\n\n// For MASP V0 and V1\nstruct ZAsset {\n    // reserved (for networkId, tokenIdPolicy. etc..)\n    uint64 _unused;\n    // 0x00 by default\n    uint8 version;\n    // Refer to Constants.sol\n    uint8 status;\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // 0x00 - no scaling\n    uint8 scale;\n    // token contract address\n    address token;\n}\n\nstruct LockData {\n    // Refer to Constants.sol\n    uint8 tokenType;\n    // Token contract address\n    address token;\n    // For ERC-721, ERC-1155 tokens\n    uint256 tokenId;\n    // The account to transfer the token from/to (on `lock`/`unlock`)\n    address extAccount;\n    // The token amount to transfer to/from the Vault (on `lock`/`unlock`)\n    uint96 extAmount;\n}\n"
    },
    "contracts/protocol/crypto/Poseidon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.16;\n\n// This is a stub to keep solc happy; the actual code is generated\n// using poseidon_gencontract.js from circomlibjs.\n\nlibrary PoseidonT3 {\n    function poseidon(bytes32[2] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT4 {\n    function poseidon(bytes32[3] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT5 {\n    function poseidon(bytes32[4] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n\nlibrary PoseidonT6 {\n    function poseidon(bytes32[5] memory input) external pure returns (bytes32) {\n        require(input.length == 99, \"FAKE\"); // always reverts\n        return 0;\n    }\n}\n"
    },
    "contracts/protocol/crypto/SnarkConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\npragma solidity ^0.8.16;\n\n// @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash\nuint256 constant FIELD_SIZE = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n\n// @dev Field prime of alt_bn128\nuint256 constant PRIME_Q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n// @dev Circuit extra public input as work-around for recently found groth16 vulnerability\nuint256 constant MAGICAL_CONSTRAINT = 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00;\n"
    },
    "contracts/protocol/interfaces/IPantherVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { VerifyingKey } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IPantherVerifier is IVerifier {\n    /**\n     * @notice Get the verifying key for the specified circuits\n     * @param circuitId ID of the circuit\n     * @dev circuitId is an address where the key is deployed as bytecode\n     * @return Verifying key\n     */\n    function getVerifyingKey(uint160 circuitId)\n        external\n        view\n        returns (VerifyingKey memory);\n}\n"
    },
    "contracts/protocol/interfaces/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IVault {\n    function lockAsset(LockData calldata data) external;\n\n    function unlockAsset(LockData memory data) external;\n\n    event Locked(LockData data);\n    event Unlocked(LockData data);\n}\n"
    },
    "contracts/protocol/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { SnarkProof } from \"../../common/Types.sol\";\nimport \"./IVerifier.sol\";\n\ninterface IVerifier {\n    /**\n     * @notice Verify the SNARK proof\n     * @param circuitId ID of the circuit (it tells which verifying key to use)\n     * @param input Public input signals\n     * @param proof SNARK proof\n     * @return isVerified bool true if proof is valid\n     */\n    function verify(\n        uint160 circuitId,\n        uint256[] memory input,\n        SnarkProof memory proof\n    ) external view returns (bool isVerified);\n}\n"
    },
    "contracts/protocol/mocks/LocalDevEnv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { DEAD_CODE_ADDRESS } from \"../../common/Constants.sol\";\n\ncontract LocalDevEnv {\n    modifier onlyLocalDevEnv() {\n        // DEAD_CODE_ADDRESS is supposed (and must) be and unusable address,\n        // which eliminate risks of using tx.origin here.\n        // solhint-disable-next-line avoid-tx-origin\n        require(tx.origin == DEAD_CODE_ADDRESS, \"Only allowed in forked env\");\n        _;\n    }\n}\n"
    },
    "contracts/protocol/mocks/MockPantherPoolV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023s Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../interfaces/IVault.sol\";\nimport \"../../common/ImmutableOwnable.sol\";\nimport { LockData } from \"../../common/Types.sol\";\n\ninterface IMockPantherPoolV1 {\n    function unlockAssetFromVault(LockData calldata data) external;\n}\n\n// solhint-disable var-name-mixedcase\n// slither-disable shadowing-state\n// slither-disable unused-state\ncontract MockPantherPoolV1 is IMockPantherPoolV1, ImmutableOwnable {\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[500] private __gap;\n\n    address public immutable VAULT;\n\n    mapping(address => bool) public vaultAssetUnlockers;\n\n    constructor(address vault, address _owner) ImmutableOwnable(_owner) {\n        require(vault != address(0), \"init: zero address\");\n        VAULT = vault;\n    }\n\n    function updateVaultAssetUnlocker(address _unlocker, bool _status)\n        external\n        onlyOwner\n    {\n        vaultAssetUnlockers[_unlocker] = _status;\n    }\n\n    function unlockAssetFromVault(LockData calldata data) external {\n        require(vaultAssetUnlockers[msg.sender], \"mockPoolV1: unauthorized\");\n\n        IVault(VAULT).unlockAsset(data);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusQueues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"../merkleTrees/DegenerateIncrementalBinaryTree.sol\";\nimport { HUNDRED_PERCENT } from \"../../../common/Constants.sol\";\n\n/**\n * @dev It handles \"queues\" of commitments to UTXOs (further - \"UTXOs\").\n * Queue is an ordered list of UTXOs. All UTXOs in a queue are supposed to be\n * processed at once.\n * To save gas, this contract\n * - stores the commitment to UTXOs in a queue (but not UTXOs) in the storage\n * - computes the commitment as the root of a degenerate tree (not binary one)\n * built from UTXOs the queue contains.\n * For every queue, it also records the amount of rewards associated with the\n * Queue (think of \"reward for processing the queue\").\n * If a queue gets fully populated with UTXOs, it is considered to be \"closed\".\n * No more UTXOs may be appended to that queue, and a new queue is created.\n * There may be many closed which pends processing. But one only partially\n * populated queue exists (it is always the most recently created queue).\n * Queues may be processed in any order (say, the 3rd queue may go before the\n * 1st one; and a fully populated queue may be processed after the partially\n * populated one).\n * The contract maintains the doubly-linked list of unprocessed queues.\n * The queue lifecycle is:\n * \"Opened -> (optionally) Closed -> Processed (and deleted).\"\n */\nabstract contract BusQueues is DegenerateIncrementalBinaryTree {\n    // solhint-disable var-name-mixedcase\n    uint256 internal constant QUEUE_MAX_LEVELS = 6;\n    uint256 private constant QUEUE_MAX_SIZE = 2**QUEUE_MAX_LEVELS;\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * @param nUtxos Number of UTXOs in the queue\n     * @param reward Rewards accumulated for the queue\n     * @param firstUtxoBlock Block when the 1st UTXO was added to the queue\n     * @param lastUtxoBlock Block when a UTXO was last added to the queue\n     * @param prevLink Link to the previous unprocessed queue\n     * @param nextLink Link to the next unprocessed queue\n     * @dev If `prevLink` (`nextLink`) is 0, the unprocessed queue is the one\n     * created right before (after) this queue, or no queues remain unprocessed,\n     * which were created before (after) this queue. If the value is not 0, the\n     * value is the unprocessed queue's ID adjusted by +1.\n     */\n    struct BusQueue {\n        uint8 nUtxos;\n        uint96 reward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        uint32 prevLink;\n        uint32 nextLink;\n    }\n\n    struct BusQueueRec {\n        uint32 queueId;\n        uint8 nUtxos;\n        uint96 reward;\n        uint96 potentialExtraReward;\n        uint40 firstUtxoBlock;\n        uint40 lastUtxoBlock;\n        bytes32 commitment;\n    }\n\n    // Mapping from queue ID to queue params\n    mapping(uint32 => BusQueue) private _busQueues;\n    // Mapping from queue ID to queue commitment\n    mapping(uint32 => bytes32) private _busQueueCommitments;\n\n    // ID of the next queue to create\n    uint32 private _nextQueueId;\n    // Number of unprocessed queues\n    uint32 private _numPendingQueues;\n    // Link to the oldest (created but yet) unprocessed queue\n    // (if 0 - no such queue exists, otherwise the queue's ID adjusted by +1)\n    uint32 private _oldestPendingQueueLink;\n\n    // Part (in 1/100th of 1%) of queue reward to be reserved for \"premiums\"\n    uint16 private _reservationRate;\n    // Part (in 1/100th of 1%) of a queue reward to be accrued as the premium\n    // (i.e. an extra reward) for every block the queue pends processing\n    uint16 private _premiumRate;\n    // Unused yet part of queue rewards which were reserved for premiums\n    uint96 private _rewardReserve;\n\n    // Emitted for every UTXO appended to a queue\n    event UtxoBusQueued(\n        bytes32 indexed utxo,\n        uint256 indexed queueId,\n        uint256 utxoIndexInBatch\n    );\n\n    // Emitted when a new queue is opened (it becomes the \"current\" one)\n    event BusQueueOpened(uint256 queueId);\n\n    // Emitted when a queue is registered as the processed one (and deleted)\n    event BusQueueProcessed(uint256 indexed queueId);\n\n    // Emitted when params of reward computation updated\n    event BusQueueRewardParamsUpdated(\n        uint256 reservationRate,\n        uint256 premiumRate\n    );\n    // Emitted when new reward \"reserves\" added\n    event BusQueueRewardReserved(uint256 extraReseve);\n    // Emitted when (part of) reward \"reserves\" used\n    event BusQueueRewardReserveUsed(uint256 usage);\n\n    // Emitted when queue reward increased w/o adding UTXOs\n    event BusQueueRewardAdded(uint256 indexed queueId, uint256 accumReward);\n\n    modifier nonEmptyBusQueue(uint32 queueId) {\n        require(_busQueues[queueId].nUtxos > 0, \"BQ:EMPTY_QUEUE\");\n        _;\n    }\n\n    // @return  reservationRate Part (in 1/100th of 1%) of every queue reward to\n    // reserve for \"premiums\" (the remaining reward is \"guaranteed\" one)\n    // @return premiumRate Part (in 1/100th of 1%) of a queue reward to accrue as\n    // the premium for every block the queue pends processing\n    function getParams()\n        external\n        view\n        returns (uint16 reservationRate, uint16 premiumRate)\n    {\n        reservationRate = _reservationRate;\n        premiumRate = _premiumRate;\n    }\n\n    // The contract is intentionally written so, that explicit initialization of\n    // storage variables is unneeded (zero values are implicitly initialized in\n    // new storage slots).\n    // To enable premiums, however, the `updateParams` call needed.\n\n    function getBusQueuesStats()\n        external\n        view\n        returns (\n            uint32 curQueueId,\n            uint32 numPendingQueues,\n            uint32 oldestPendingQueueId,\n            uint96 rewardReserve\n        )\n    {\n        uint32 nextQueueId = _nextQueueId;\n        require(nextQueueId != 0, \"BT:NO_QUEUES\");\n        curQueueId = nextQueueId - 1;\n        numPendingQueues = _numPendingQueues;\n        oldestPendingQueueId = numPendingQueues == 0\n            ? 0\n            : _oldestPendingQueueLink - 1;\n        rewardReserve = _rewardReserve;\n    }\n\n    function getBusQueue(uint32 queueId)\n        external\n        view\n        returns (BusQueueRec memory queue)\n    {\n        BusQueue memory q = _busQueues[queueId];\n        require(\n            queueId + 1 == _nextQueueId || q.nUtxos > 0,\n            \"BT:UNKNOWN_OR_PROCESSED_QUEUE\"\n        );\n        (uint256 reward, uint256 premium, ) = _estimateRewarding(q);\n        queue = BusQueueRec(\n            queueId,\n            q.nUtxos,\n            uint96(reward),\n            uint96(premium),\n            q.firstUtxoBlock,\n            q.lastUtxoBlock,\n            _busQueueCommitments[queueId]\n        );\n    }\n\n    // Returns upto maxLength unprocessed queues records\n    function getOldestPendingQueues(uint32 maxLength)\n        external\n        view\n        returns (BusQueueRec[] memory queues)\n    {\n        uint256 nQueues = _numPendingQueues;\n        if (nQueues > maxLength) nQueues = maxLength;\n        queues = new BusQueueRec[](nQueues);\n\n        uint32 nextLink = _oldestPendingQueueLink;\n        for (uint256 i = 0; i < nQueues; i++) {\n            uint32 queueId = nextLink - 1;\n            BusQueue memory queue = _busQueues[queueId];\n\n            queues[i].queueId = queueId;\n            queues[i].nUtxos = queue.nUtxos;\n            (uint256 reward, uint256 premium, ) = _estimateRewarding(queue);\n            queues[i].reward = uint96(reward);\n            queues[i].potentialExtraReward = uint96(premium);\n            queues[i].firstUtxoBlock = queue.firstUtxoBlock;\n            queues[i].lastUtxoBlock = queue.lastUtxoBlock;\n            queues[i].commitment = _busQueueCommitments[queueId];\n\n            nextLink = queue.nextLink == 0 ? nextLink + 1 : queue.nextLink;\n        }\n\n        return queues;\n    }\n\n    function updateParams(uint16 reservationRate, uint16 premiumRate) internal {\n        require(\n            reservationRate <= HUNDRED_PERCENT &&\n                premiumRate <= HUNDRED_PERCENT,\n            \"BQ:INVALID_PARAMS\"\n        );\n        _reservationRate = reservationRate;\n        _premiumRate = premiumRate;\n        emit BusQueueRewardParamsUpdated(reservationRate, premiumRate);\n    }\n\n    // @dev Code that calls it MUST ensure utxos[i] < FIELD_SIZE\n    function addUtxosToBusQueue(bytes32[] memory utxos, uint96 reward)\n        internal\n    {\n        require(utxos.length < QUEUE_MAX_SIZE, \"BQ:TOO_MANY_UTXOS\");\n\n        uint32 queueId;\n        BusQueue memory queue;\n        bytes32 commitment;\n        {\n            uint32 nextQueueId = _nextQueueId;\n            if (nextQueueId == 0) {\n                // Create the 1st queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n                _oldestPendingQueueLink = queueId + 1;\n            } else {\n                // Read an existing queue from the storage\n                queueId = nextQueueId - 1;\n                queue = _busQueues[queueId];\n                commitment = _busQueueCommitments[queueId];\n            }\n        }\n\n        // Block number overflow risk ignored\n        uint40 curBlock = uint40(block.number);\n\n        for (uint256 n = 0; n < utxos.length; n++) {\n            if (queue.nUtxos == 0) queue.firstUtxoBlock = curBlock;\n\n            bytes32 utxo = utxos[n];\n            commitment = insertLeaf(utxo, commitment, queue.nUtxos == 0);\n            emit UtxoBusQueued(utxo, queueId, queue.nUtxos);\n            queue.nUtxos += 1;\n\n            // If the current queue gets fully populated, switch to a new queue\n            if (queue.nUtxos == QUEUE_MAX_SIZE) {\n                // Part of the reward relates to the populated queue\n                uint96 rewardUsed = uint96(\n                    (uint256(reward) * (n + 1)) / utxos.length\n                );\n                queue.reward += rewardUsed;\n                // Remaining reward is for the new queue\n                reward -= rewardUsed;\n\n                queue.lastUtxoBlock = curBlock;\n                _busQueues[queueId] = queue;\n                _busQueueCommitments[queueId] = commitment;\n\n                // Create a new queue\n                (queueId, queue, commitment) = _createNewBusQueue();\n            }\n        }\n\n        if (queue.nUtxos > 0) {\n            queue.reward += reward;\n            queue.lastUtxoBlock = curBlock;\n            _busQueues[queueId] = queue;\n            _busQueueCommitments[queueId] = commitment;\n        }\n    }\n\n    // It delete the processed queue and returns the queue params\n    function setBusQueueAsProcessed(uint32 queueId)\n        internal\n        nonEmptyBusQueue(queueId)\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        BusQueue memory queue = _busQueues[queueId];\n        commitment = _busQueueCommitments[queueId];\n        nUtxos = queue.nUtxos;\n        reward = uint96(_computeReward(queue));\n\n        // Clear the storage for the processed queue\n        _busQueues[queueId] = BusQueue(0, 0, 0, 0, 0, 0);\n        _busQueueCommitments[queueId] = bytes32(0);\n\n        _numPendingQueues -= 1;\n\n        // If applicable, open a new queue (_nextQueueId can't be 0 here)\n        uint32 curQueueId = _nextQueueId - 1;\n        if (queueId == curQueueId) {\n            (curQueueId, , ) = _createNewBusQueue();\n        }\n\n        // Compute and save links to previous, next, oldest unprocessed queues\n        // (link, if unequal to 0, is the unprocessed queue's ID adjusted by +1)\n        uint32 nextLink = queue.nextLink == 0 ? queueId + 2 : queue.nextLink;\n        uint32 nextPendingQueueId = nextLink - 1;\n        {\n            uint32 prevLink;\n            bool isOldestQueue = _oldestPendingQueueLink == queueId + 1;\n            if (isOldestQueue) {\n                prevLink = 0;\n                _oldestPendingQueueLink = nextLink;\n            } else {\n                prevLink = queue.prevLink == 0 ? queueId : queue.prevLink;\n                _busQueues[prevLink - 1].nextLink = nextLink;\n            }\n            _busQueues[nextPendingQueueId].prevLink = prevLink;\n        }\n\n        emit BusQueueProcessed(queueId);\n    }\n\n    function addBusQueueReward(uint32 queueId, uint96 extraReward)\n        internal\n        nonEmptyBusQueue(queueId)\n    {\n        require(extraReward > 0, \"BQ:ZERO_REWARD\");\n        uint96 accumReward;\n        unchecked {\n            // Values are supposed to be too small to cause overflow\n            accumReward = _busQueues[queueId].reward + extraReward;\n            _busQueues[queueId].reward = accumReward;\n        }\n        emit BusQueueRewardAdded(queueId, accumReward);\n    }\n\n    function _createNewBusQueue()\n        private\n        returns (\n            uint32 newQueueId,\n            BusQueue memory queue,\n            bytes32 commitment\n        )\n    {\n        newQueueId = _nextQueueId;\n\n        // Store updated values in \"old\" storage slots\n        unchecked {\n            // Risks of overflow ignored\n            _nextQueueId = newQueueId + 1;\n            _numPendingQueues += 1;\n        }\n        // Explicit initialization of new storage slots to zeros is unneeded\n        queue = BusQueue(0, 0, 0, 0, 0, 0);\n        commitment = bytes32(0);\n\n        emit BusQueueOpened(newQueueId);\n    }\n\n    function _computeReward(BusQueue memory queue)\n        private\n        returns (uint256 actReward)\n    {\n        (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        ) = _estimateRewarding(queue);\n        uint256 reserve = _rewardReserve;\n        if (netReserveChange > 0) {\n            uint256 addition = uint256(netReserveChange);\n            _rewardReserve = uint96(reserve + addition);\n            emit BusQueueRewardReserved(addition);\n        }\n        if (netReserveChange < 0) {\n            uint256 usage = uint256(-netReserveChange);\n            if (usage > reserve) {\n                premium -= (usage - reserve);\n                usage = reserve;\n            }\n            _rewardReserve = uint96(reserve - usage);\n            emit BusQueueRewardReserveUsed(usage);\n        }\n        actReward = reward + premium;\n    }\n\n    function _estimateRewarding(BusQueue memory queue)\n        private\n        view\n        returns (\n            uint256 reward,\n            uint256 premium,\n            int256 netReserveChange\n        )\n    {\n        // _reservationRate MUST be less than HUNDRED_PERCENT ...\n        uint256 contrib = (uint256(queue.reward) * _reservationRate) /\n            HUNDRED_PERCENT;\n        // ... so this can't underflow\n        reward = uint256(queue.reward) - contrib;\n        uint256 pendBlocks = block.number - queue.firstUtxoBlock;\n        premium =\n            (uint256(queue.reward) * pendBlocks * _premiumRate) /\n            HUNDRED_PERCENT;\n        // positive/negative value means \"supply\"/\"demand\" to/from reserves\n        netReserveChange = int256(contrib) - int256(premium);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/busTree/BusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport \"./BusQueues.sol\";\nimport \"../../interfaces/IPantherVerifier.sol\";\nimport { EMPTY_BUS_TREE_ROOT } from \"../zeroTrees/Constants.sol\";\nimport { MAGICAL_CONSTRAINT } from \"../../crypto/SnarkConstants.sol\";\n\n/**\n * @dev The Bus Tree (\"Tree\") is an incremental binary Merkle tree that stores\n * commitments to UTXOs (further referred to as \"UTXOs\").\n * Unfilled part of the Tree contains leafs with a special \"zero\" value - such\n * leafs are deemed to be \"empty\".\n * UTXOs are inserted in the Tree in batches called \"Queues\".\n * The contract does not compute the Tree's root on-chain. Instead, it verifies\n * the SNARK-proof, which proves correctness of insertion into the Tree.\n * For efficient proving, leafs of a Queue get re-organized into a binary fully\n * balanced Merkle tree called the \"Batch\". If there are less UTXOs in a Queue\n * than needed to fill the Batch, empty leafs are appended. This way, insertion\n * constitutes replacement of an inner node of the Tree with the Batch root.\n * To ease off-chain re-construction, roots of Tree's branches (\"Branches\") are\n * published via on-chain logs.\n */\nabstract contract BusTree is BusQueues {\n    // solhint-disable var-name-mixedcase\n\n    // Number of levels in every Batch (that is a binary tree)\n    uint256 internal constant BATCH_LEVELS = QUEUE_MAX_LEVELS;\n\n    // Number of levels in every Branch, counting from roots of Batches\n    uint256 private constant BRANCH_LEVELS = 10;\n    // Number of Batches in a fully filled Branch\n    uint256 private constant BRANCH_SIZE = 2**BRANCH_LEVELS;\n    // Bitmask for cheaper modulo math\n    uint256 private constant BRANCH_BITMASK = BRANCH_SIZE - 1;\n\n    IPantherVerifier public immutable VERIFIER;\n    uint160 public immutable CIRCUIT_ID;\n    // solhint-enable var-name-mixedcase\n\n    bytes32 public busTreeRoot;\n\n    // Number of Batches in the Bus Tree\n    uint32 private _numBatchesInBusTree;\n    // Number of UTXOs (excluding empty leafs) in the tree\n    uint32 private _numUtxosInBusTree;\n    // Block when the 1st Batch inserted in the latest branch\n    uint40 private _latestBranchFirstBatchBlock;\n    // Block when the latest Batch inserted in the Bus Tree\n    uint40 private _latestBatchBlock;\n\n    event BusBatchOnboarded(\n        uint256 indexed queueId,\n        bytes32 indexed batchRoot,\n        uint256 numUtxosInBatch,\n        // The index of a UTXO's leaf in the Bus Tree is\n        // `leftLeafIndexInBusTree + UtxoBusQueued::utxoIndexInBatch`\n        uint256 leftLeafIndexInBusTree,\n        bytes32 busTreeNewRoot,\n        bytes32 busBranchNewRoot\n    );\n\n    event BusBranchFilled(\n        uint256 indexed branchIndex,\n        bytes32 busBranchFinalRoot\n    );\n\n    // @dev It is \"proxy-friendly\" as it does not change the storage\n    constructor(address _verifier, uint160 _circuitId) {\n        require(\n            IPantherVerifier(_verifier).getVerifyingKey(_circuitId).ic.length >=\n                1,\n            \"BT:INVALID_VK\"\n        );\n        VERIFIER = IPantherVerifier(_verifier);\n        CIRCUIT_ID = _circuitId;\n        // Code of `function onboardQueue` let avoid explicit initialization:\n        // `busTreeRoot = EMPTY_BUS_TREE_ROOT`.\n        // Initial value of storage variables is 0 (which is implicitly set in\n        // new storage slots). There is no need for explicit initialization.\n    }\n\n    function getBusTreeStats()\n        external\n        view\n        returns (\n            uint32 numBatchesInBusTree,\n            uint32 numUtxosInBusTree,\n            uint40 latestBranchFirstBatchBlock,\n            uint40 latestBatchBlock\n        )\n    {\n        numBatchesInBusTree = _numBatchesInBusTree;\n        numUtxosInBusTree = _numUtxosInBusTree;\n        latestBranchFirstBatchBlock = _latestBranchFirstBatchBlock;\n        latestBatchBlock = _latestBatchBlock;\n    }\n\n    function onboardQueue(\n        address miner,\n        uint32 queueId,\n        bytes32 busTreeNewRoot,\n        bytes32 batchRoot,\n        bytes32 busBranchNewRoot,\n        SnarkProof memory proof\n    ) external nonEmptyBusQueue(queueId) {\n        uint32 nBatches = _numBatchesInBusTree;\n        (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        ) = setBusQueueAsProcessed(queueId);\n\n        // Circuit public input signals\n        uint256[] memory input = new uint256[](9);\n        // `oldRoot` signal\n        input[0] = nBatches == 0\n            ? uint256(EMPTY_BUS_TREE_ROOT)\n            : uint256(busTreeRoot);\n        // `newRoot` signal\n        input[1] = uint256(busTreeNewRoot);\n        // `replacedNodeIndex` signal\n        input[2] = nBatches;\n        // `newLeafsCommitment` signal\n        input[3] = uint256(commitment);\n        // `nNonEmptyNewLeafs` signal\n        input[4] = uint256(nUtxos);\n        // `batchRoot` signal\n        input[5] = uint256(batchRoot);\n        // `branchRoot` signal\n        input[6] = uint256(busBranchNewRoot);\n        // `extraInput` signal (front-run protection)\n        input[7] = uint256(uint160(miner));\n        // magicalConstraint\n        input[8] = MAGICAL_CONSTRAINT;\n\n        // Verify the proof\n        require(VERIFIER.verify(CIRCUIT_ID, input, proof), \"BT:FAILED_PROOF\");\n\n        {\n            // Overflow risk ignored\n            uint40 curBlock = uint40(block.number);\n            _latestBatchBlock = curBlock;\n\n            // `& BRANCH_BITMASK` is equivalent to `% BRANCH_SIZE`\n            uint256 batchBranchIndex = uint256(nBatches) & BRANCH_BITMASK;\n            if (batchBranchIndex == 0) {\n                _latestBranchFirstBatchBlock = curBlock;\n            } else {\n                if (batchBranchIndex + 1 == BRANCH_SIZE) {\n                    // `>>BRANCH_LEVELS` is equivalent to `/BRANCH_SIZE`\n                    uint256 branchIndex = nBatches >> BRANCH_LEVELS;\n                    emit BusBranchFilled(branchIndex, busBranchNewRoot);\n                }\n            }\n        }\n\n        // Store updated Bus Tree params\n        busTreeRoot = busTreeNewRoot;\n        // Overflow impossible as nUtxos and _numBatchesInBusTree are limited\n        _numBatchesInBusTree = nBatches + 1;\n        _numUtxosInBusTree += nUtxos;\n\n        // `<< BATCH_LEVELS` is equivalent to `* 2**BATCH_LEVELS`\n        uint32 leftLeafIndex = nBatches << uint32(BATCH_LEVELS);\n\n        emit BusBatchOnboarded(\n            queueId,\n            batchRoot,\n            nUtxos,\n            leftLeafIndex,\n            busTreeNewRoot,\n            busBranchNewRoot\n        );\n\n        rewardMiner(miner, reward);\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal virtual;\n}\n"
    },
    "contracts/protocol/pantherForest/merkleTrees/DegenerateIncrementalBinaryTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n/**\n * @dev It computes the root of the degenerate binary merkle tree\n * - i.e. for the tree of this kind (_tree.nLeafs is 4 here):\n *     root\n *      /\\\n *     /\\ 3\n *    /\\ 2\n *   0  1\n * If the tree has just a single leaf, it's root equals to the leaf.\n */\nabstract contract DegenerateIncrementalBinaryTree {\n    function insertLeaf(\n        bytes32 leaf,\n        bytes32 root,\n        bool isFirstLeaf\n    ) internal pure returns (bytes32 newRoot) {\n        newRoot = isFirstLeaf ? leaf : hash(root, leaf);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        virtual\n        returns (bytes32);\n}\n"
    },
    "contracts/protocol/pantherForest/mocks/MockBusTree.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2023 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\nimport { IMockPantherPoolV1 } from \"../../mocks/MockPantherPoolV1.sol\";\n\nimport \"../busTree/BusTree.sol\";\nimport { PoseidonT3 } from \"../../crypto/Poseidon.sol\";\nimport { FIELD_SIZE } from \"../../crypto/SnarkConstants.sol\";\nimport { DEAD_CODE_ADDRESS, ERC20_TOKEN_TYPE } from \"../../../common/Constants.sol\";\nimport { LockData } from \"../../../common/Types.sol\";\nimport \"../../../common/ImmutableOwnable.sol\";\nimport \"../../mocks/LocalDevEnv.sol\";\n\ncontract MockBusTree is BusTree, LocalDevEnv, ImmutableOwnable {\n    // The contract is supposed to run behind a proxy DELEGATECALLing it.\n    // On upgrades, adjust `__gap` to match changes of the storage layout.\n    // slither-disable-next-line shadowing-state unused-state\n    uint256[50] private __gap;\n\n    // solhint-disable var-name-mixedcase\n\n    // timestamp of deployment\n    uint256 public immutable START_TIME;\n\n    // address of reward token\n    address public immutable REWARD_TOKEN;\n\n    // address of panther pool\n    address public immutable PANTHER_POOL;\n\n    // solhint-enable var-name-mixedcase\n\n    // avg number of utxos which can be added per minute\n    uint16 public perMinuteUtxosLimit;\n\n    // base reward per each utxo\n    uint96 public basePerUtxoReward;\n\n    // keeps track of number of the added utxos\n    uint32 public utxoCounter;\n\n    event MinerRewarded(address miner, uint256 reward);\n\n    constructor(\n        address owner,\n        address rewardToken,\n        address pantherPool,\n        address _verifier,\n        uint160 _circuitId\n    ) ImmutableOwnable(owner) BusTree(_verifier, _circuitId) {\n        require(\n            rewardToken != address(0) && pantherPool != address(0),\n            \"init: zero address\"\n        );\n\n        START_TIME = block.timestamp;\n\n        REWARD_TOKEN = rewardToken;\n        PANTHER_POOL = pantherPool;\n    }\n\n    function updateParams(\n        uint16 _perMinuteUtxosLimit,\n        uint96 _basePerUtxoReward,\n        uint16 reservationRate,\n        uint16 premiumRate\n    ) external onlyOwner {\n        BusQueues.updateParams(reservationRate, premiumRate);\n\n        require(\n            _perMinuteUtxosLimit > 0 && _basePerUtxoReward > 0,\n            \"updateParams: zero value\"\n        );\n        perMinuteUtxosLimit = _perMinuteUtxosLimit;\n        basePerUtxoReward = _basePerUtxoReward;\n    }\n\n    function rewardMiner(address miner, uint256 reward) internal override {\n        LockData memory data = LockData({\n            tokenType: ERC20_TOKEN_TYPE,\n            token: REWARD_TOKEN,\n            tokenId: 0,\n            extAccount: miner,\n            extAmount: uint96(reward)\n        });\n\n        IMockPantherPoolV1(PANTHER_POOL).unlockAssetFromVault(data);\n\n        emit MinerRewarded(miner, reward);\n    }\n\n    function hash(bytes32 left, bytes32 right)\n        internal\n        pure\n        override\n        returns (bytes32)\n    {\n        require(\n            uint256(left) < FIELD_SIZE && uint256(right) < FIELD_SIZE,\n            \"BT:TOO_LARGE_LEAF_INPUT\"\n        );\n        return PoseidonT3.poseidon([left, right]);\n    }\n\n    function getAllowedUtxosAt(uint256 _timestamp, uint256 _utxoCounter)\n        public\n        view\n        returns (uint256 allowedUtxos)\n    {\n        if (_timestamp < START_TIME) return 0;\n\n        uint256 secs = _timestamp - START_TIME;\n        allowedUtxos = (secs * perMinuteUtxosLimit) / 60 seconds - _utxoCounter;\n    }\n\n    function simulateAddUtxosToBusQueue() external {\n        uint256 _counter = uint256(utxoCounter);\n\n        // generating the first utxo\n        uint256 utxo = uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE;\n\n        // Generating the utxos length between 1 - 5\n        uint256 length = (utxo & 3) + 1;\n\n        if (_counter + length > getAllowedUtxosAt(block.timestamp, _counter))\n            return;\n\n        bytes32[] memory utxos = new bytes32[](length);\n\n        // adding the first commitment\n        utxos[0] = bytes32(utxo);\n        _counter++;\n\n        // adding the rest of commitment\n        for (uint256 i = 1; i < length; ) {\n            utxos[i] = bytes32(\n                uint256(keccak256(abi.encode(_counter))) % FIELD_SIZE\n            );\n\n            unchecked {\n                i++;\n                _counter++;\n            }\n        }\n\n        // overflow risk ignored\n        utxoCounter = uint32(_counter);\n        uint256 reward = uint256(basePerUtxoReward) * length;\n\n        addUtxosToBusQueue(utxos, uint96(reward));\n    }\n\n    function simulateAddGivenUtxosToBusQueue(\n        bytes32[] memory utxos,\n        uint96 reward\n    ) external onlyLocalDevEnv {\n        addUtxosToBusQueue(utxos, reward);\n    }\n\n    function simulateAddBusQueueReward(uint32 queueId, uint96 extraReward)\n        external\n        onlyLocalDevEnv\n    {\n        addBusQueueReward(queueId, extraReward);\n    }\n\n    function internalUpdateParams(uint16 reservationRate, uint16 premiumRate)\n        external\n        onlyLocalDevEnv\n    {\n        updateParams(reservationRate, premiumRate);\n    }\n\n    function simulateSetBusQueueAsProcessed(uint32 queueId)\n        external\n        onlyLocalDevEnv\n        returns (\n            bytes32 commitment,\n            uint8 nUtxos,\n            uint96 reward\n        )\n    {\n        return setBusQueueAsProcessed(queueId);\n    }\n}\n"
    },
    "contracts/protocol/pantherForest/zeroTrees/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-23 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.16;\n\n// @dev Leaf zero value (`keccak256(\"Pantherprotocol\")%FIELD_SIZE`)\n// TODO: remove duplications of ZERO_LEAF across ../../\nbytes32 constant ZERO_VALUE = bytes32(\n    uint256(0x0667764c376602b72ef22218e1673c2cc8546201f9a77807570b3e5de137680d)\n);\n\n// @dev Number of levels (bellow the root, but including leafs) in the BusTree\nuint256 constant BUS_TREE_LEVELS = 26;\n\n// @dev Root of the binary tree of BUS_TREE_LEVELS with leafs of ZERO_VALUE\n// Computed using `../../../../lib/binaryMerkleZerosContractGenerator.ts`\nbytes32 constant EMPTY_BUS_TREE_ROOT = bytes32(\n    uint256(0x1bdded415724018275c7fcc2f564f64db01b5bbeb06d65700564b05c3c59c9e6)\n);\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}