{
  "language": "Solidity",
  "sources": {
    "contracts/actions/RewardAdvisersList.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IRewardAdviser.sol\";\n\n/**\n * @title ActionControllers\n * @notice It maintains a list of \"ActionOracle\" and \"RewardAdviser\" instances.\n * For a tuple of ActionOracle address and action type, an RewardAdviser\n * instance of  may be mapped.\n */\nabstract contract RewardAdvisersList {\n    /// @dev Emitted when RewardAdviser added, updated, or removed\n    event AdviserUpdated(\n        address indexed oracle,\n        bytes4 indexed action,\n        address adviser\n    );\n\n    /// @dev mapping from ActionOracle and (type of) action to ActionController\n    mapping(address => mapping(bytes4 => address)) public rewardAdvisers;\n\n    function _addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) internal {\n        require(\n            oracle != address(0) &&\n                adviser != address(0) &&\n                action != bytes4(0),\n            \"ACM:E1\"\n        );\n        require(rewardAdvisers[oracle][action] == address(0), \"ACM:E2\");\n        rewardAdvisers[oracle][action] = adviser;\n        emit AdviserUpdated(oracle, action, adviser);\n    }\n\n    function _removeRewardAdviser(address oracle, bytes4 action) internal {\n        require(rewardAdvisers[oracle][action] != address(0), \"ACM:E3\");\n        rewardAdvisers[oracle][action] = address(0);\n        emit AdviserUpdated(oracle, action, address(0));\n    }\n\n    function _getRewardAdviserOrRevert(address oracle, bytes4 action)\n        internal\n        view\n        returns (IRewardAdviser)\n    {\n        address adviser = rewardAdvisers[oracle][action];\n        require(adviser != address(0), \"ACM:E4\");\n        return IRewardAdviser(adviser);\n    }\n}\n"
    },
    "contracts/interfaces/IRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IRewardAdviser {\n    struct Advice {\n        // advice on new \"shares\" (in the reward pool) to create\n        address createSharesFor;\n        uint96 sharesToCreate;\n        // advice on \"shares\" to redeem\n        address redeemSharesFrom;\n        uint96 sharesToRedeem;\n        // advice on address the reward against redeemed shares to send to\n        address sendRewardTo;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        returns (Advice memory);\n}\n"
    },
    "contracts/RewardMaster.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/RewardAdvisersList.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./interfaces/IRewardPool.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Claimable.sol\";\nimport \"./utils/NonReentrant.sol\";\nimport \"./utils/Utils.sol\";\n\n/***\n * @title RewardMaster\n * @notice It accounts rewards and distributes reward tokens to users.\n * @dev It withdraws the reward token from (or via) the \"REWARD_POOL\" contract,\n * and keeps tokens, aka \"Treasury\", on its balance until distribution.\n * It issues to users \"shares\" in the Treasury, or redeems shares, paying out\n * tokens from the Treasury to users, or on behalf of users, as follows.\n * It receives messages (calls) on \"actions\" to be rewarded from authorized\n * \"ActionOracle\" contracts.\n * On every \"action\" message received, it calls a \"RewardAdviser\" contract,\n * assigned for that ActionOracle and action type, which advices on how many\n * shares shall be created and to whom, or whose shares must be redeemed, and\n * where reward tokens shall be sent to.\n * The owner may add or remove addresses of ActionOracle`s and RewardAdviser`s.\n */\ncontract RewardMaster is\n    ImmutableOwnable,\n    Utils,\n    Claimable,\n    NonReentrant,\n    RewardAdvisersList,\n    IActionMsgReceiver\n{\n    // solhint-disable var-name-mixedcase\n\n    /// @notice Token rewards are given in\n    address public immutable REWARD_TOKEN;\n\n    /// @notice RewardPool instance that vests the reward token\n    address public immutable REWARD_POOL;\n\n    /// @dev Block the contract deployed in\n    uint256 public immutable START_BLOCK;\n\n    // solhint-enable var-name-mixedcase\n\n    /**\n     * At any time, the amount of the reward token a user is entitled to is:\n     *   tokenAmountEntitled = accumRewardPerShare * user.shares - user.offset\n     *\n     * This formula works since we update parameters as follows ...\n     *\n     * - when a new reward token amount added to the Treasury:\n     *   accumRewardPerShare += tokenAmountAdded / totalShares\n     *\n     * - when new shares granted to a user:\n     *   user.offset += sharesToCreate * accumRewardPerShare\n     *   user.shares += sharesToCreate\n     *   totalShares += sharesToCreate\n     *\n     * - when shares redeemed to a user:\n     *   redemptionRate = accumRewardPerShare - user.offset/user.shares\n     *   user.offset -= user.offset/user.shares * sharesToRedeem\n     *   user.shares -= sharesToRedeem\n     *   totalShares -= sharesToRedeem\n     *   tokenAmountPayable = redemptionRate * sharesToRedeem\n     *\n     * (Scaling omitted in formulas above for clarity.)\n     */\n\n    /// @dev Block when reward tokens were last time were vested in\n    uint32 public lastVestedBlock;\n    /// @dev Reward token balance (aka Treasury) after last vesting\n    /// (token total supply is supposed to not exceed 2**96)\n    uint96 public lastBalance;\n\n    /// @notice Total number of unredeemed shares\n    /// (it is supposed to not exceed 2**128)\n    uint128 public totalShares;\n    /// @dev Min number of unredeemed shares being rewarded\n    uint256 private constant MIN_SHARES_REWARDED = 1000;\n\n    // see comments above for explanation\n    uint256 public accumRewardPerShare;\n    // `accumRewardPerShare` is scaled (up) with this factor\n    uint256 private constant SCALE = 1e9;\n\n    // see comments above for explanation\n    struct UserRecord {\n        // (limited to 2**96)\n        uint96 shares;\n        uint160 offset;\n    }\n\n    // Mapping from user address to UserRecord data\n    mapping(address => UserRecord) public records;\n\n    /// @dev Emitted when new shares granted to a user\n    event SharesGranted(address indexed user, uint256 amount);\n    /// @dev Emitted when shares of a user redeemed\n    event SharesRedeemed(address indexed user, uint256 amount);\n    /// @dev Emitted when new reward token amount vested to this contract\n    event RewardAdded(uint256 reward);\n    /// @dev Emitted when reward token amount paid to/for a user\n    event RewardPaid(address indexed user, uint256 reward);\n    /// @dev Emitted when the Treasury counts for \"extra\" reward tokens.\n    /// \"Extra\" tokens are ones sent to this contract directly (rather than\n    /// vested via the REWARD_POOL).\n    event BalanceAdjusted(uint256 adjustment);\n\n    constructor(\n        address _rewardToken,\n        address _rewardPool,\n        address _owner\n    ) ImmutableOwnable(_owner) {\n        require(\n            _rewardToken != address(0) && _rewardPool != address(0),\n            \"RM:C1\"\n        );\n\n        REWARD_TOKEN = _rewardToken;\n        REWARD_POOL = _rewardPool;\n        START_BLOCK = blockNow();\n    }\n\n    /// @notice Returns reward token amount entitled to the given user/account\n    // This amount the account would get if shares would be redeemed now\n    function entitled(address account) public view returns (uint256 reward) {\n        UserRecord memory rec = records[account];\n        if (rec.shares == 0) return 0;\n\n        // no reentrancy guard needed for the known contract call\n        uint256 releasable = IRewardPool(REWARD_POOL).releasableAmount();\n        uint256 _accumRewardPerShare = accumRewardPerShare;\n        uint256 _totalShares = uint256(totalShares);\n        if (releasable != 0 && _totalShares >= MIN_SHARES_REWARDED) {\n            _accumRewardPerShare += (releasable * SCALE) / _totalShares;\n        }\n\n        (reward, , ) = _computeRedemption(\n            uint256(rec.shares),\n            rec,\n            _accumRewardPerShare\n        );\n    }\n\n    function onAction(bytes4 action, bytes memory message) external override {\n        IRewardAdviser adviser = _getRewardAdviserOrRevert(msg.sender, action);\n        // no reentrancy guard needed for the known contract call\n        IRewardAdviser.Advice memory advice = adviser.getRewardAdvice(\n            action,\n            message\n        );\n        if (advice.sharesToCreate > 0) {\n            _grantShares(advice.createSharesFor, advice.sharesToCreate);\n        }\n        if (advice.sharesToRedeem > 0) {\n            _redeemShares(\n                advice.redeemSharesFrom,\n                advice.sharesToRedeem,\n                advice.sendRewardTo\n            );\n        }\n    }\n\n    /* ========== ONLY FOR OWNER FUNCTIONS ========== */\n\n    /**\n     * @notice Adds the \"RewardAdviser\" for given ActionOracle and action type\n     * @dev May be only called by the {OWNER}\n     * !!!!! Before adding a new \"adviser\", ensure \"shares\" it \"advices\" can not\n     * overflow `UserRecord.shares`, `UserRecord.offset` and `totalShares`.\n     */\n    function addRewardAdviser(\n        address oracle,\n        bytes4 action,\n        address adviser\n    ) external onlyOwner {\n        _addRewardAdviser(oracle, action, adviser);\n    }\n\n    /// @notice Remove \"RewardAdviser\" for given ActionOracle and action type\n    /// @dev May be only called by the {OWNER}\n    function removeRewardAdviser(address oracle, bytes4 action)\n        external\n        onlyOwner\n    {\n        _removeRewardAdviser(oracle, action);\n    }\n\n    /// @notice Withdraws accidentally sent token from this contract\n    /// @dev May be only called by the {OWNER}\n    function claimErc20(\n        address claimedToken,\n        address to,\n        uint256 amount\n    ) external onlyOwner nonReentrant {\n        if (claimedToken == address(REWARD_TOKEN)) {\n            // Not allowed if unclaimed shares remain\n            require(totalShares == 0, \"RM: Failed to claim\");\n        }\n        _claimErc20(claimedToken, to, amount);\n    }\n\n    /* ========== INTERNAL & PRIVATE FUNCTIONS ========== */\n\n    function _computeRedemption(\n        uint256 sharesToRedeem,\n        UserRecord memory rec,\n        uint256 _accumRewardPerShare\n    )\n        internal\n        pure\n        returns (\n            uint256 reward,\n            uint256 newShares,\n            uint256 newOffset\n        )\n    {\n        // `rec.shares` and `sharesToRedeem` are assumed to be non-zero here,\n        // and `sharesToRedeem` does not exceed `rec.shares`\n        newShares = uint256(rec.shares) - sharesToRedeem;\n\n        uint256 offsetRedeemed = newShares == 0\n            ? uint256(rec.offset)\n            : (uint256(rec.offset) * sharesToRedeem) / uint256(rec.shares);\n        newOffset = uint256(rec.offset) - offsetRedeemed;\n\n        reward = 0;\n        if (_accumRewardPerShare != 0) {\n            reward = (sharesToRedeem * _accumRewardPerShare) / SCALE;\n            // avoid eventual overflow resulted from rounding\n            reward -= reward >= offsetRedeemed ? offsetRedeemed : reward;\n        }\n    }\n\n    function _grantShares(address to, uint256 shares)\n        internal\n        nonZeroAmount(shares)\n        nonZeroAddress(to)\n    {\n        (\n            uint256 _accumRewardPerShare,\n            uint256 newBalance,\n            uint256 oldBalance\n        ) = _triggerVesting();\n\n        if (oldBalance != newBalance) lastBalance = safe96(newBalance);\n\n        UserRecord memory rec = records[to];\n        uint256 newOffset = uint256(rec.offset) +\n            (shares * _accumRewardPerShare) /\n            SCALE;\n        uint256 newShares = uint256(rec.shares) + shares;\n\n        records[to] = UserRecord(safe96(newShares), safe160(newOffset));\n        totalShares = safe128(uint256(totalShares) + shares);\n\n        emit SharesGranted(to, shares);\n    }\n\n    function _redeemShares(\n        address from,\n        // `shares` assumed to be non-zero\n        uint256 shares,\n        address to\n    ) internal nonZeroAmount(shares) nonZeroAddress(from) nonZeroAddress(to) {\n        UserRecord memory rec = records[from];\n        require(rec.shares >= shares, \"RM: Not enough shares to redeem\");\n\n        (\n            uint256 _accumRewardPerShare,\n            uint256 newBalance,\n            uint256 oldBalance\n        ) = _triggerVesting();\n\n        (\n            uint256 reward,\n            uint256 newShares,\n            uint256 newOffset\n        ) = _computeRedemption(shares, rec, _accumRewardPerShare);\n\n        records[from] = UserRecord(safe96(newShares), safe160(newOffset));\n        totalShares = safe128(uint256(totalShares) - shares);\n\n        uint256 _lastBalance = newBalance - reward;\n        if (oldBalance != _lastBalance) {\n            lastBalance = safe96(_lastBalance);\n        }\n\n        if (reward != 0) {\n            // known contract - nether reentrancy guard nor safeTransfer required\n            require(\n                IErc20Min(REWARD_TOKEN).transfer(to, reward),\n                \"RM: Internal transfer failed\"\n            );\n            emit RewardPaid(to, reward);\n        }\n\n        emit SharesRedeemed(from, shares);\n    }\n\n    function _triggerVesting()\n        internal\n        returns (\n            uint256 newAccumRewardPerShare,\n            uint256 newBalance,\n            uint256 oldBalance\n        )\n    {\n        uint32 _blockNow = safe32BlockNow();\n        newAccumRewardPerShare = accumRewardPerShare;\n        oldBalance = uint256(lastBalance);\n        uint256 _totalShares = totalShares;\n\n        if (\n            lastVestedBlock >= _blockNow || _totalShares < MIN_SHARES_REWARDED\n        ) {\n            return (newAccumRewardPerShare, oldBalance, oldBalance);\n        }\n\n        // known contracts, no reentrancy guard needed\n        uint256 newlyVested = IRewardPool(REWARD_POOL).vestRewards();\n        newBalance = IErc20Min(REWARD_TOKEN).balanceOf(address(this));\n\n        uint256 expectedBalance = oldBalance + newlyVested;\n        if (newBalance > expectedBalance) {\n            // somebody transferred tokens to this contract directly\n            uint256 adjustment = newBalance - expectedBalance;\n            newlyVested += adjustment;\n            emit BalanceAdjusted(adjustment);\n        }\n        if (newlyVested != 0) {\n            newAccumRewardPerShare += (newlyVested * SCALE) / _totalShares;\n            accumRewardPerShare = newAccumRewardPerShare;\n            emit RewardAdded(newlyVested);\n        }\n        lastVestedBlock = _blockNow;\n        lastBalance = safe96(newBalance);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier nonZeroAmount(uint256 amount) {\n        require(amount > 0, \"RM: Zero amount provided\");\n        _;\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"RM: Zero address provided\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IActionMsgReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IActionMsgReceiver {\n    function onAction(bytes4 action, bytes memory message) external;\n}\n"
    },
    "contracts/interfaces/IErc20Min.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IErc20Min {\n    /// @dev ERC-20 `balanceOf`\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @dev ERC-20 `transfer`\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /// @dev ERC-20 `transferFrom`\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @dev EIP-2612 `permit`\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\npragma solidity ^0.8.0;\n\ninterface IRewardPool {\n    /// @notice Returns token amount that may be released (vested) now\n    function releasableAmount() external view returns (uint256);\n\n    /// @notice Vests releasable token amount to the {recipient}\n    /// @dev {recipient} only may call\n    function vestRewards() external returns (uint256 amount);\n\n    /// @notice Emitted on vesting to the {recipient}\n    event Vested(uint256 amount);\n\n    /// @notice Emitted on parameters initialized.\n    event Initialized(uint256 _poolId, address _recipient, uint256 _endTime);\n}\n"
    },
    "contracts/utils/ImmutableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/// @title Staking\nabstract contract ImmutableOwnable {\n    /// @notice The owner who has privileged rights\n    // solhint-disable-next-line var-name-mixedcase\n    address public immutable OWNER;\n\n    /// @dev Throws if called by any account other than the {OWNER}.\n    modifier onlyOwner() {\n        require(OWNER == msg.sender, \"ImmOwn: unauthorized\");\n        _;\n    }\n\n    constructor(address _owner) {\n        require(_owner != address(0), \"ImmOwn: zero owner address\");\n        OWNER = _owner;\n    }\n}\n"
    },
    "contracts/utils/Claimable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/**\n * @title Claimable\n * @notice It withdraws accidentally sent tokens from this contract.\n */\ncontract Claimable {\n    bytes4 private constant SELECTOR_TRANSFER =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    /// @dev Withdraws ERC20 tokens from this contract\n    /// (take care of reentrancy attack risk mitigation)\n    function _claimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"claimErc20: TRANSFER_FAILED\"\n        );\n    }\n}\n"
    },
    "contracts/utils/NonReentrant.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\n/**\n * @title NonReentrant\n * @notice It provides reentrancy guard.\n * The code borrowed from openzeppelin-contracts.\n * Unlike original, this version requires neither `constructor` no `init` call.\n */\nabstract contract NonReentrant {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _reentrancyStatus;\n\n    modifier nonReentrant() {\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\n        // it does not revert (which is expected behaviour)\n        require(_reentrancyStatus != _ENTERED, \"claimErc20: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyStatus = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/utils/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nabstract contract Utils {\n    function safe32(uint256 n) internal pure returns (uint32) {\n        require(n < 2**32, \"UNSAFE32\");\n        return uint32(n);\n    }\n\n    function safe96(uint256 n) internal pure returns (uint96) {\n        require(n < 2**96, \"UNSAFE96\");\n        return uint96(n);\n    }\n\n    function safe128(uint256 n) internal pure returns (uint128) {\n        require(n < 2**128, \"UNSAFE128\");\n        return uint128(n);\n    }\n\n    function safe160(uint256 n) internal pure returns (uint160) {\n        require(n < 2**160, \"UNSAFE160\");\n        return uint160(n);\n    }\n\n    function safe32TimeNow() internal view returns (uint32) {\n        return safe32(timeNow());\n    }\n\n    function safe32BlockNow() internal view returns (uint32) {\n        return safe32(blockNow());\n    }\n\n    /// @dev Returns the current block timestamp (added to ease testing)\n    function timeNow() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @dev Returns the current block number (added to ease testing)\n    function blockNow() internal view virtual returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/Staking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IActionMsgReceiver.sol\";\nimport \"./interfaces/IErc20Min.sol\";\nimport \"./interfaces/IStakingTypes.sol\";\nimport \"./interfaces/IVotingPower.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title Staking\n * @notice It lets users stake $ZKP token for governance voting and rewards.\n * @dev At request of smart contracts and off-chain requesters, it computes\n * user \"voting power\" on the basis of tokens users stake.\n * It acts as the \"ActionOracle\" for the \"RewardMaster\": if stake terms presume\n * rewarding, it sends \"messages\" on stakes made and stakes claimed to the\n * \"RewardMaster\" contract which rewards stakers.\n * It supports multiple types of stakes (terms), which the owner may add or\n * remove without contract code upgrades.\n */\ncontract Staking is\n    ImmutableOwnable,\n    Utils,\n    StakingMsgProcessor,\n    IStakingTypes,\n    IVotingPower\n{\n    // solhint-disable var-name-mixedcase\n    /// @notice Staking token\n    IErc20Min public immutable TOKEN;\n\n    /// @dev Block the contract deployed in\n    uint256 public immutable START_BLOCK;\n\n    /// @notice RewardMaster contract instance\n    IActionMsgReceiver public immutable REWARD_MASTER;\n\n    // solhint-enable var-name-mixedcase\n\n    // Scale for min/max limits\n    uint256 private constant SCALE = 1e18;\n\n    /// @notice Total token amount staked\n    /// @dev Staking token is deemed to have max total supply of 1e27\n    uint96 public totalStaked = 0;\n\n    /// @dev Mapping from stake type to terms\n    mapping(bytes4 => Terms) public terms;\n\n    /// @dev Mapping from the staker address to stakes of the staker\n    mapping(address => Stake[]) public stakes;\n\n    // Special address to store global state\n    address private constant GLOBAL_ACCOUNT = address(0);\n\n    /// @dev Voting power integrants for each account\n    // special case: GLOBAL_ACCOUNT for total voting power\n    mapping(address => Power) public power;\n\n    /// @dev Snapshots of each account\n    // special case: GLOBAL_ACCOUNT for global snapshots\n    mapping(address => Snapshot[]) private snapshots;\n\n    /// @dev Emitted on a new stake made\n    event StakeCreated(\n        address indexed account,\n        uint256 indexed stakeID,\n        uint256 amount,\n        bytes4 stakeType,\n        uint256 lockedTill\n    );\n\n    /// @dev Emitted on a stake claimed (i.e. \"unstaked\")\n    event StakeClaimed(address indexed account, uint256 indexed stakeID);\n\n    /// @dev Voting power delegated\n    event Delegation(\n        address indexed owner,\n        address indexed from,\n        address indexed to,\n        uint256 stakeID,\n        uint256 amount\n    );\n\n    /// @dev New terms (for the given stake type) added\n    event TermsAdded(bytes4 stakeType);\n\n    /// @dev Terms (for the given stake type) are disabled\n    event TermsDisabled(bytes4 stakeType);\n\n    /// @dev Call to REWARD_MASTER reverted\n    event RewardMasterRevert(address staker, uint256 stakeID);\n\n    /**\n     * @notice Sets staking token, owner and\n     * @param stakingToken - Address of the {ZKPToken} contract\n     * @param rewardMaster - Address of the {RewardMaster} contract\n     * @param owner - Address of the owner account\n     */\n    constructor(\n        address stakingToken,\n        address rewardMaster,\n        address owner\n    ) ImmutableOwnable(owner) {\n        require(\n            stakingToken != address(0) && rewardMaster != address(0),\n            \"Staking:C1\"\n        );\n        TOKEN = IErc20Min(stakingToken);\n        REWARD_MASTER = IActionMsgReceiver(rewardMaster);\n        START_BLOCK = blockNow();\n    }\n\n    /**\n     * @notice Stakes tokens\n     * @dev This contract should be approve()'d for amount\n     * @param amount - Amount to stake\n     * @param stakeType - Type of the stake\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @return stake ID\n     */\n    function stake(\n        uint256 amount,\n        bytes4 stakeType,\n        bytes calldata data\n    ) public returns (uint256) {\n        return _createStake(msg.sender, amount, stakeType, data);\n    }\n\n    /**\n     * @notice Approves this contract to transfer `amount` tokens from the `msg.sender`\n     * and stakes these tokens. Only the owner of tokens (i.e. the staker) may call.\n     * @dev This contract does not need to be approve()'d in advance - see EIP-2612\n     * @param owner - The owner of tokens being staked (i.e. the `msg.sender`)\n     * @param amount - Amount to stake\n     * @param v - \"v\" param of the signature from `owner` for \"permit\"\n     * @param r - \"r\" param of the signature from `owner` for \"permit\"\n     * @param s - \"s\" param of the signature from `owner` for \"permit\"\n     * @param stakeType - Type of the stake\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @return stake ID\n     */\n    function permitAndStake(\n        address owner,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes4 stakeType,\n        bytes calldata data\n    ) external returns (uint256) {\n        require(owner == msg.sender, \"Staking: owner must be msg.sender\");\n        TOKEN.permit(owner, address(this), amount, deadline, v, r, s);\n        return _createStake(owner, amount, stakeType, data);\n    }\n\n    /**\n     * @notice Claims staked token\n     * @param stakeID - ID of the stake to claim\n     * @param data - Arbitrary data for \"RewardMaster\" (zero, if inapplicable)\n     * @param _isForced - Do not revert if \"RewardMaster\" fails\n     */\n    function unstake(\n        uint256 stakeID,\n        bytes calldata data,\n        bool _isForced\n    ) external stakeExist(msg.sender, stakeID) {\n        Stake memory _stake = stakes[msg.sender][stakeID];\n\n        require(_stake.claimedAt == 0, \"Staking: Stake claimed\");\n        require(_stake.lockedTill < safe32TimeNow(), \"Staking: Stake locked\");\n\n        if (_stake.delegatee != address(0)) {\n            _undelegatePower(_stake.delegatee, msg.sender, _stake.amount);\n        }\n        _removePower(msg.sender, _stake.amount);\n\n        stakes[msg.sender][stakeID].claimedAt = safe32TimeNow();\n\n        totalStaked = safe96(uint256(totalStaked) - uint256(_stake.amount));\n\n        emit StakeClaimed(msg.sender, stakeID);\n\n        // known contract - reentrancy guard and `safeTransfer` unneeded\n        require(\n            TOKEN.transfer(msg.sender, _stake.amount),\n            \"Staking: transfer failed\"\n        );\n\n        Terms memory _terms = terms[_stake.stakeType];\n        if (_terms.isRewarded) {\n            _sendUnstakedMsg(msg.sender, _stake, data, _isForced);\n        }\n    }\n\n    /**\n     * @notice Updates vote delegation\n     * @param stakeID - ID of the stake to delegate votes uber\n     * @param to - address to delegate to\n     */\n    function delegate(uint256 stakeID, address to)\n        public\n        stakeExist(msg.sender, stakeID)\n    {\n        require(\n            to != GLOBAL_ACCOUNT,\n            \"Staking: Can't delegate to GLOBAL_ACCOUNT\"\n        );\n\n        Stake memory s = stakes[msg.sender][stakeID];\n        require(s.claimedAt == 0, \"Staking: Stake claimed\");\n        require(s.delegatee != to, \"Staking: Already delegated\");\n\n        if (s.delegatee == address(0)) {\n            _delegatePower(msg.sender, to, s.amount);\n        } else {\n            if (to == msg.sender) {\n                _undelegatePower(s.delegatee, msg.sender, s.amount);\n            } else {\n                _reDelegatePower(s.delegatee, to, s.amount);\n            }\n        }\n\n        emit Delegation(msg.sender, s.delegatee, to, stakeID, s.amount);\n\n        stakes[msg.sender][stakeID].delegatee = to;\n    }\n\n    /**\n     * @notice Delegates voting power of stake back to self\n     * @param stakeID - ID of the stake to delegate votes back to self\n     */\n    function undelegate(uint256 stakeID) external {\n        delegate(stakeID, msg.sender);\n    }\n\n    /// @notice Returns number of stakes of given _account\n    function stakesNum(address _account) external view returns (uint256) {\n        return stakes[_account].length;\n    }\n\n    /// @notice Returns stakes of given account\n    function accountStakes(address _account)\n        external\n        view\n        returns (Stake[] memory)\n    {\n        Stake[] memory _stakes = stakes[_account];\n        return _stakes;\n    }\n\n    /// @inheritdoc IVotingPower\n    function totalVotingPower() external view override returns (uint256) {\n        Power memory _power = power[GLOBAL_ACCOUNT];\n        return _power.own + _power.delegated;\n    }\n\n    /// @inheritdoc IVotingPower\n    function totalPower() external view override returns (Power memory) {\n        return power[GLOBAL_ACCOUNT];\n    }\n\n    /// @inheritdoc IVotingPower\n    function latestGlobalsSnapshotBlock()\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return latestSnapshotBlock(GLOBAL_ACCOUNT);\n    }\n\n    /// @inheritdoc IVotingPower\n    function latestSnapshotBlock(address _account)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (snapshots[_account].length == 0) return 0;\n\n        return snapshots[_account][snapshots[_account].length - 1].beforeBlock;\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalsSnapshotLength() external view override returns (uint256) {\n        return snapshots[GLOBAL_ACCOUNT].length;\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshotLength(address _account)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return snapshots[_account].length;\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return snapshots[GLOBAL_ACCOUNT][_index];\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return snapshots[_account][_index];\n    }\n\n    /// @inheritdoc IVotingPower\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        override\n        returns (Snapshot memory)\n    {\n        return _snapshotAt(GLOBAL_ACCOUNT, blockNum, hint);\n    }\n\n    /// @inheritdoc IVotingPower\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view override returns (Snapshot memory) {\n        return _snapshotAt(_account, blockNum, hint);\n    }\n\n    /// Only for the owner functions\n\n    /// @notice Adds a new stake type with given terms\n    /// @dev May be only called by the {OWNER}\n    function addTerms(bytes4 stakeType, Terms memory _terms)\n        external\n        onlyOwner\n        nonZeroStakeType(stakeType)\n    {\n        Terms memory existingTerms = terms[stakeType];\n        require(!_isDefinedTerms(existingTerms), \"Staking:E1\");\n        require(_terms.isEnabled, \"Staking:E2\");\n\n        uint256 _now = timeNow();\n\n        if (_terms.allowedTill != 0) {\n            require(_terms.allowedTill > _now, \"Staking:E3\");\n            require(_terms.allowedTill > _terms.allowedSince, \"Staking:E4\");\n        }\n\n        if (_terms.maxAmountScaled != 0) {\n            require(\n                _terms.maxAmountScaled > _terms.minAmountScaled,\n                \"Staking:E5\"\n            );\n        }\n\n        // only one of three \"lock time\" parameters must be non-zero\n        if (_terms.lockedTill != 0) {\n            require(\n                _terms.exactLockPeriod == 0 && _terms.minLockPeriod == 0,\n                \"Staking:E6\"\n            );\n            require(\n                _terms.lockedTill > _now &&\n                    _terms.lockedTill >= _terms.allowedTill,\n                \"Staking:E7\"\n            );\n        } else {\n            require(\n                // one of two params must be non-zero\n                (_terms.exactLockPeriod == 0) != (_terms.minLockPeriod == 0),\n                \"Staking:E8\"\n            );\n        }\n\n        terms[stakeType] = _terms;\n        emit TermsAdded(stakeType);\n    }\n\n    function disableTerms(bytes4 stakeType)\n        external\n        onlyOwner\n        nonZeroStakeType(stakeType)\n    {\n        Terms memory _terms = terms[stakeType];\n        require(_isDefinedTerms(terms[stakeType]), \"Staking:E9\");\n        require(_terms.isEnabled, \"Staking:EA\");\n\n        terms[stakeType].isEnabled = false;\n        emit TermsDisabled(stakeType);\n    }\n\n    /// Internal and private functions follow\n\n    function _createStake(\n        address staker,\n        uint256 amount,\n        bytes4 stakeType,\n        bytes calldata data\n    ) internal nonZeroStakeType(stakeType) returns (uint256) {\n        Terms memory _terms = terms[stakeType];\n        require(_terms.isEnabled, \"Staking: Terms unknown or disabled\");\n\n        require(amount > 0, \"Staking: Amount not set\");\n        uint256 _totalStake = amount + uint256(totalStaked);\n        require(_totalStake < 2**96, \"Staking: Too big amount\");\n\n        require(\n            _terms.minAmountScaled == 0 ||\n                amount >= SCALE * _terms.minAmountScaled,\n            \"Staking: Too small amount\"\n        );\n        require(\n            _terms.maxAmountScaled == 0 ||\n                amount <= SCALE * _terms.maxAmountScaled,\n            \"Staking: Too large amount\"\n        );\n\n        uint32 _now = safe32TimeNow();\n        require(\n            _terms.allowedSince == 0 || _now >= _terms.allowedSince,\n            \"Staking: Not yet allowed\"\n        );\n        require(\n            _terms.allowedTill == 0 || _terms.allowedTill > _now,\n            \"Staking: Not allowed anymore\"\n        );\n\n        // known contract - reentrancy guard and `safeTransferFrom` unneeded\n        require(\n            TOKEN.transferFrom(staker, address(this), amount),\n            \"Staking: transferFrom failed\"\n        );\n\n        uint256 stakeID = stakes[staker].length;\n\n        uint32 lockedTill = _terms.lockedTill;\n        if (lockedTill == 0) {\n            uint256 period = _terms.exactLockPeriod == 0\n                ? _terms.minLockPeriod\n                : _terms.exactLockPeriod;\n            lockedTill = safe32(period + _now);\n        }\n\n        Stake memory _stake = Stake(\n            uint32(stakeID), // overflow risk ignored\n            stakeType,\n            _now, // stakedAt\n            lockedTill,\n            0, // claimedAt\n            uint96(amount),\n            address(0) // no delegatee\n        );\n        stakes[staker].push(_stake);\n\n        totalStaked = uint96(_totalStake);\n        _addPower(staker, amount);\n\n        emit StakeCreated(staker, stakeID, amount, stakeType, lockedTill);\n\n        if (_terms.isRewarded) {\n            _sendStakedMsg(staker, _stake, data);\n        }\n        return stakeID;\n    }\n\n    function _addPower(address to, uint256 amount) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(to);\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\n        power[to].own += uint96(amount);\n    }\n\n    function _removePower(address from, uint256 amount) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(from);\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\n        power[from].own -= uint96(amount);\n    }\n\n    function _delegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        _takeSnapshot(GLOBAL_ACCOUNT);\n        _takeSnapshot(to);\n        _takeSnapshot(from);\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\n        power[from].own -= uint96(amount);\n        power[GLOBAL_ACCOUNT].delegated += uint96(amount);\n        power[to].delegated += uint96(amount);\n    }\n\n    function _reDelegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        _takeSnapshot(to);\n        _takeSnapshot(from);\n        power[from].delegated -= uint96(amount);\n        power[to].delegated += uint96(amount);\n    }\n\n    function _undelegatePower(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        power[GLOBAL_ACCOUNT].delegated -= uint96(amount);\n        power[from].delegated -= uint96(amount);\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\n        power[to].own += uint96(amount);\n    }\n\n    function _takeSnapshot(address _account) internal {\n        uint32 curBlockNum = safe32BlockNow();\n        if (latestSnapshotBlock(_account) < curBlockNum) {\n            // make new snapshot as the latest one taken before current block\n            snapshots[_account].push(\n                Snapshot(\n                    curBlockNum,\n                    power[_account].own,\n                    power[_account].delegated\n                )\n            );\n        }\n    }\n\n    function _snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) internal view returns (Snapshot memory) {\n        _sanitizeBlockNum(blockNum);\n\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\n\n        if (\n            // hint is correct?\n            hint <= snapshotsInfo.length &&\n            (hint == 0 || snapshotsInfo[hint - 1].beforeBlock < blockNum) &&\n            (hint == snapshotsInfo.length ||\n                snapshotsInfo[hint].beforeBlock >= blockNum)\n        ) {\n            // yes, return the hinted snapshot\n            if (hint < snapshotsInfo.length) {\n                return snapshotsInfo[hint];\n            } else {\n                return\n                    Snapshot(\n                        uint32(blockNum),\n                        power[_account].own,\n                        power[_account].delegated\n                    );\n            }\n        }\n        // no, fall back to binary search\n        else return _snapshotAt(_account, blockNum);\n    }\n\n    function _snapshotAt(address _account, uint256 blockNum)\n        internal\n        view\n        returns (Snapshot memory)\n    {\n        _sanitizeBlockNum(blockNum);\n\n        // https://en.wikipedia.org/wiki/Binary_search_algorithm\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\n        uint256 index;\n        uint256 low = 0;\n        uint256 high = snapshotsInfo.length;\n\n        while (low < high) {\n            uint256 mid = (low + high) / 2;\n\n            if (snapshotsInfo[mid].beforeBlock > blockNum) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // `low` is the exclusive upper bound. Find the inclusive upper bounds and set to index\n        if (low > 0 && snapshotsInfo[low - 1].beforeBlock == blockNum) {\n            return snapshotsInfo[low - 1];\n        } else {\n            index = low;\n        }\n\n        // If index is equal to snapshot array length, then no update made after the requested blockNum.\n        // This means the latest value is the right one.\n        if (index == snapshotsInfo.length) {\n            return\n                Snapshot(\n                    uint32(blockNum),\n                    uint96(power[_account].own),\n                    uint96(power[_account].delegated)\n                );\n        } else {\n            return snapshotsInfo[index];\n        }\n    }\n\n    function _sanitizeBlockNum(uint256 blockNum) private view {\n        require(blockNum <= safe32BlockNow(), \"Staking: Too big block number\");\n    }\n\n    function _isDefinedTerms(Terms memory _terms) internal pure returns (bool) {\n        return\n            (_terms.minLockPeriod != 0) ||\n            (_terms.exactLockPeriod != 0) ||\n            (_terms.lockedTill != 0);\n    }\n\n    function _sendStakedMsg(\n        address staker,\n        Stake memory _stake,\n        bytes calldata data\n    ) internal {\n        bytes4 action = _encodeStakeActionType(_stake.stakeType);\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\n        // known contract - reentrancy guard unneeded\n        // solhint-disable-next-line no-empty-blocks\n        try REWARD_MASTER.onAction(action, message) {} catch {\n            revert(\"Staking: onStake msg failed\");\n        }\n    }\n\n    function _sendUnstakedMsg(\n        address staker,\n        Stake memory _stake,\n        bytes calldata data,\n        bool _isForced\n    ) internal {\n        bytes4 action = _encodeUnstakeActionType(_stake.stakeType);\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\n        // known contract - reentrancy guard unneeded\n        // solhint-disable-next-line no-empty-blocks\n        try REWARD_MASTER.onAction(action, message) {} catch {\n            emit RewardMasterRevert(staker, _stake.id);\n            // REWARD_MASTER must be unable to revert forced calls\n            require(_isForced, \"Staking: REWARD_MASTER reverts\");\n        }\n    }\n\n    modifier stakeExist(address staker, uint256 stakeID) {\n        require(\n            stakes[staker].length > stakeID,\n            \"Staking: Stake doesn't exist\"\n        );\n        _;\n    }\n\n    modifier nonZeroStakeType(bytes4 stakeType) {\n        require(stakeType != bytes4(0), \"Staking: Invalid stake type 0\");\n        _;\n    }\n}\n"
    },
    "contracts/actions/StakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IStakingTypes.sol\";\n\nabstract contract StakingMsgProcessor {\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\"stake\"));\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\"unstake\"));\n\n    function _encodeStakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\n    }\n\n    function _encodeUnstakeActionType(bytes4 stakeType)\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\n    }\n\n    function _packStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                staker, // address\n                stake.amount, // uint96\n                stake.id, // uint32\n                stake.stakedAt, // uint32\n                stake.lockedTill, // uint32\n                stake.claimedAt, // uint32\n                data // bytes\n            );\n    }\n\n    // For efficiency we use \"packed\" (rather than \"ABI\") encoding.\n    // It results in shorter data, but requires custom unpack function.\n    function _unpackStakingActionMsg(bytes memory message)\n        internal\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\n        // (`data` may be of zero length)\n        require(message.length >= 48, \"SMP: unexpected msg length\");\n\n        uint256 stakerAndAmount;\n        uint256 idAndStamps;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // the 1st word (32 bytes) contains the `message.length`\n            // we need the (entire) 2nd word ..\n            stakerAndAmount := mload(add(message, 0x20))\n            // .. and (16 bytes of) the 3rd word\n            idAndStamps := mload(add(message, 0x40))\n        }\n\n        staker = address(uint160(stakerAndAmount >> 96));\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\n\n        uint256 dataLength = message.length - 48;\n        data = new bytes(dataLength);\n        for (uint256 i = 0; i < dataLength; i++) {\n            data[i] = message[i + 48];\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IStakingTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\ninterface IStakingTypes {\n    // Stake type terms\n    struct Terms {\n        // if stakes of this kind allowed\n        bool isEnabled;\n        // if messages on stakes to be sent to the {RewardMaster}\n        bool isRewarded;\n        // limit on the minimum amount staked, no limit if zero\n        uint32 minAmountScaled;\n        // limit on the maximum amount staked, no limit if zero\n        uint32 maxAmountScaled;\n        // Stakes not accepted before this time, has no effect if zero\n        uint32 allowedSince;\n        // Stakes not accepted after this time, has no effect if zero\n        uint32 allowedTill;\n        // One (at least) of the following three params must be non-zero\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\n        uint32 lockedTill;\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\n        uint32 exactLockPeriod;\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\n        uint32 minLockPeriod;\n    }\n\n    struct Stake {\n        // index in the `Stake[]` array of `stakes`\n        uint32 id;\n        // defines Terms\n        bytes4 stakeType;\n        // time this stake was created at\n        uint32 stakedAt;\n        // time this stake can be claimed at\n        uint32 lockedTill;\n        // time this stake was claimed at (unclaimed if 0)\n        uint32 claimedAt;\n        // amount of tokens on this stake (assumed to be less 1e27)\n        uint96 amount;\n        // address stake voting power is delegated to\n        address delegatee;\n    }\n}\n"
    },
    "contracts/interfaces/IVotingPower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IStaking\ninterface IVotingPower {\n    struct Snapshot {\n        uint32 beforeBlock;\n        uint96 ownPower;\n        uint96 delegatedPower;\n    }\n\n    /// @dev Voting power integrants\n    struct Power {\n        uint96 own; // voting power that remains after delegating to others\n        uint96 delegated; // voting power delegated by others\n    }\n\n    /// @notice Returns total voting power staked\n    /// @dev \"own\" and \"delegated\" voting power summed up\n    function totalVotingPower() external view returns (uint256);\n\n    /// @notice Returns total \"own\" and total \"delegated\" voting power separately\n    /// @dev Useful, if \"own\" and \"delegated\" voting power treated differently\n    function totalPower() external view returns (Power memory);\n\n    /// @notice Returns global snapshot for given block\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @notice Returns snapshot on given block for given account\n    /// @param _account - account to get snapshot for\n    /// @param blockNum - block number to get state at\n    /// @param hint - off-chain computed index of the required snapshot\n    function snapshotAt(\n        address _account,\n        uint256 blockNum,\n        uint256 hint\n    ) external view returns (Snapshot memory);\n\n    /// @dev Returns block number of the latest global snapshot\n    function latestGlobalsSnapshotBlock() external view returns (uint256);\n\n    /// @dev Returns block number of the given account latest snapshot\n    function latestSnapshotBlock(address _account)\n        external\n        view\n        returns (uint256);\n\n    /// @dev Returns number of global snapshots\n    function globalsSnapshotLength() external view returns (uint256);\n\n    /// @dev Returns number of snapshots for given account\n    function snapshotLength(address _account) external view returns (uint256);\n\n    /// @dev Returns global snapshot at given index\n    function globalsSnapshot(uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n\n    /// @dev Returns snapshot at given index for given account\n    function snapshot(address _account, uint256 _index)\n        external\n        view\n        returns (Snapshot memory);\n}\n"
    },
    "contracts/RewardPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\n// solhint-disable var-name-mixedcase\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IVestingPools.sol\";\nimport \"./interfaces/IRewardPool.sol\";\nimport \"./utils/ImmutableOwnable.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title RewardPool\n * @notice It vests $ZKP token from the Panther Protocol \"Reward Pool\".\n * @dev One of the vesting pools (maybe, the major one) which the VestingPools\n * contract vests $ZKP tokens to is the \"Reward Pool\" (aka \"Protocol Pool\").\n * This contract assumed to have a \"pool wallet\" role with the VestingPools,\n * and therefore has a privilege to request vesting $ZKPs from the Reward Pool\n * to the \"recipient\".\n * The \"RewardMaster\" contract, that distributes tokens to users as rewards,\n * is assumed to be the \"recipient\".\n *\n * This contract is expected to be replaced. Therefore it allows the owner\n * to transfer the \"pool wallet\" role to another account.\n */\ncontract RewardPool is ImmutableOwnable, Utils, IRewardPool {\n    /// @notice Address of the VestingPools instance\n    address public immutable VESTING_POOLS;\n\n    /// @notice ID of the pool (in the VestingPools) to vest from\n    uint8 public poolId;\n\n    /// @dev (UNIX) Time when vesting gets disabled\n    uint32 public endTime;\n\n    /// @notice Address to vest tokens to\n    address public recipient;\n\n    constructor(address _vestingPools, address _owner)\n        ImmutableOwnable(_owner)\n        nonZeroAddress(_vestingPools)\n    {\n        VESTING_POOLS = _vestingPools;\n    }\n\n    /// @inheritdoc IRewardPool\n    function releasableAmount() external view override returns (uint256) {\n        if (recipient == address(0)) return 0;\n        if (timeNow() >= endTime) return 0;\n\n        return _releasableAmount();\n    }\n\n    /// @inheritdoc IRewardPool\n    function vestRewards() external override returns (uint256 amount) {\n        // revert if unauthorized or recipient not yet set\n        require(msg.sender == recipient, \"RP: unauthorized\");\n        require(timeNow() < endTime, \"RP: expired\");\n\n        amount = _releasableAmount();\n\n        if (amount != 0) {\n            // here and after, no reentrancy guard needed for calls to VESTING_POOLS\n            IVestingPools(VESTING_POOLS).releaseTo(poolId, recipient, amount);\n            emit Vested(amount);\n        }\n    }\n\n    /// @notice Sets the {poolId} and the {recipient} to given values\n    /// @dev Owner only may call, once only\n    /// This contract address must be set in the VestingPools as the wallet for the pool\n    function initialize(\n        uint8 _poolId,\n        address _recipient,\n        uint32 _endTime\n    ) external onlyOwner nonZeroAddress(_recipient) {\n        // once only\n        require(recipient == address(0), \"RP: initialized\");\n        // _endTime can't be in the past\n        require(_endTime > timeNow(), \"RP: expired\");\n        // this contract must be registered with the VestingPools\n        require(\n            IVestingPools(VESTING_POOLS).getWallet(_poolId) == address(this),\n            \"RP:E7\"\n        );\n\n        poolId = _poolId;\n        recipient = _recipient;\n        endTime = _endTime;\n\n        emit Initialized(_poolId, _recipient, _endTime);\n    }\n\n    /// @notice Calls VestingPools to transfer 'pool wallet' role to given address\n    /// @dev Owner only may call, once only\n    function transferPoolWalletRole(address newWallet)\n        external\n        onlyOwner\n        nonZeroAddress(newWallet)\n    {\n        IVestingPools(VESTING_POOLS).updatePoolWallet(poolId, newWallet);\n    }\n\n    function _releasableAmount() internal view returns (uint256) {\n        return IVestingPools(VESTING_POOLS).releasableAmount(poolId);\n    }\n\n    modifier nonZeroAddress(address account) {\n        require(account != address(0), \"RP: zero address\");\n        _;\n    }\n}\n"
    },
    "contracts/interfaces/IVestingPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IVestingPools {\n    /**\n     * @notice Returns Token address.\n     */\n    function token() external view returns (address);\n\n    /**\n     * @notice Returns the wallet address of the specified pool.\n     */\n    function getWallet(uint256 poolId) external view returns (address);\n\n    /**\n     * @notice Returns the amount that may be vested now from the given pool.\n     */\n    function releasableAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount that has been vested from the given pool\n     */\n    function vestedAmount(uint256 poolId) external view returns (uint256);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the pool wallet.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function release(uint256 poolId, uint256 amount)\n        external\n        returns (uint256 released);\n\n    /**\n     * @notice Vests the specified amount from the given pool to the given address.\n     * If the amount is zero, it vests the entire \"releasable\" amount.\n     * @dev Pool wallet may call only.\n     * @return released - Amount released.\n     */\n    function releaseTo(\n        uint256 poolId,\n        address account,\n        uint256 amount\n    ) external returns (uint256 released);\n\n    /**\n     * @notice Updates the wallet for the given pool.\n     * @dev Only address with the 'wallet' role may call.\n     */\n    function updatePoolWallet(uint256 poolId, address newWallet) external;\n\n    /// @notice Emitted on an amount vesting.\n    event Released(uint256 indexed poolId, address to, uint256 amount);\n}\n"
    },
    "contracts/mocks/MockStakingMsgProcessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../actions/StakingMsgProcessor.sol\";\nimport \"../interfaces/IStakingTypes.sol\";\n\ncontract MockStakingMsgProcessor is StakingMsgProcessor {\n    function internalEncodeStakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeStakeActionType(stakeType);\n    }\n\n    function internalEncodeUnstakeActionType(bytes4 stakeType)\n        external\n        pure\n        returns (bytes4)\n    {\n        return _encodeUnstakeActionType(stakeType);\n    }\n\n    function internalPackStakingActionMsg(\n        address staker,\n        IStakingTypes.Stake memory stake,\n        bytes calldata data\n    ) external pure returns (bytes memory) {\n        return _packStakingActionMsg(staker, stake, data);\n    }\n\n    function internalUnpackStakingActionMsg(bytes memory message)\n        external\n        pure\n        returns (\n            address staker,\n            uint96 amount,\n            uint32 id,\n            uint32 stakedAt,\n            uint32 lockedTill,\n            uint32 claimedAt,\n            bytes memory data\n        )\n    {\n        return _unpackStakingActionMsg(message);\n    }\n}\n"
    },
    "contracts/StakeRewardAdviser.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"./actions/StakingMsgProcessor.sol\";\nimport \"./interfaces/IRewardAdviser.sol\";\nimport \"./utils/Utils.sol\";\n\n/**\n * @title StakeRewardAdviser\n * @notice It \"advises\" the \"RewardMaster\" on staking rewards (\"shares\").\n * @dev It acts as the \"RewardAdviser\" for the \"RewardMaster\": the latter calls\n * this contract to process messages from the \"Staking\" contract.\n */\ncontract StakeRewardAdviser is StakingMsgProcessor, Utils, IRewardAdviser {\n    // solhint-disable var-name-mixedcase\n    bytes4 private immutable STAKED;\n    bytes4 private immutable UNSTAKED;\n    uint256 public immutable FACTOR;\n    // solhint-enable var-name-mixedcase\n\n    uint256 private constant SCALE = 1e9;\n\n    constructor(bytes4 stakeType, uint256 stakeAmountToSharesScaledFactor) {\n        require(\n            stakeType != bytes4(0) && stakeAmountToSharesScaledFactor != 0,\n            \"PSA:E1\"\n        );\n        STAKED = _encodeStakeActionType(stakeType);\n        UNSTAKED = _encodeUnstakeActionType(stakeType);\n        FACTOR = stakeAmountToSharesScaledFactor;\n    }\n\n    function getRewardAdvice(bytes4 action, bytes memory message)\n        external\n        view\n        override\n        returns (Advice memory)\n    {\n        (address staker, uint96 amount, , , , , ) = _unpackStakingActionMsg(\n            message\n        );\n        require(staker != address(0), \"PSA: unexpected zero staker\");\n        require(amount != 0, \"PSA: unexpected zero amount\");\n\n        uint256 shares = (uint256(amount) * FACTOR) / SCALE;\n\n        if (action == STAKED) {\n            return\n                Advice(\n                    staker, // createSharesFor\n                    safe96(shares), // sharesToCreate\n                    address(0), // redeemSharesFrom\n                    0, // sharesToRedeem\n                    address(0) // sendRewardTo\n                );\n        }\n        if (action == UNSTAKED) {\n            return\n                Advice(\n                    address(0), // createSharesFor\n                    0, // sharesToCreate\n                    staker, // redeemSharesFrom\n                    safe96(shares), // sharesToRedeem\n                    staker // sendRewardTo\n                );\n        }\n\n        revert(\"PSA: unsupported action\");\n    }\n}\n"
    },
    "contracts/mocks/MockClaimable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\npragma solidity ^0.8.0;\n\nimport \"../utils/Claimable.sol\";\n\ncontract MockClaimable is Claimable {\n    function internalClaimErc20(\n        address token,\n        address to,\n        uint256 amount\n    ) external {\n        _claimErc20(token, to, amount);\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}