// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

// Content is autogenerated by `lib/generateTriadMerkleZerosContract.ts`

/**
 * @notice The "triad" tree populated with zeros.
 * @dev The "triad" tree is a modified Merkle (full) binary tree:
 * - every node, from the root upto the level preceding leaves, excluding
 * that level, has 2 child nodes (i.e. this subtree is a full binary tree);
 * - every node of the layer preceding leaves has 3 child nodes (3 leaves).
 * Example:
 * [4]                              0
 *                                  |
 * [3]               0-------------------------------1
 *                   |                               |
 * [2]       0---------------1                2--------------3
 *           |               |                |              |
 * [1]   0-------1       2-------3       4-------5       6-------7
 *      /|\     /|\     /|\     /|\     /|\     /|\     /|\     /|\
 * [0]  0..2    3..5    6..8    9..11  12..14  15..17  18..20  21..24
 *
 * Number in a root/node/leaf position is the "node index" that starts from 0
 * for the leftmost node/leaf of every level.
 * Number in [] is the "level index" that starts from 0 for the leaves level.
 */
abstract contract TriadMerkleZeros {
    // @dev Order of alt_bn128 and the field prime of Baby Jubjub and Poseidon hash
    uint256 public constant FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;

    // Number of levels in a tree including both leaf and root levels
    uint256 internal constant TREE_LEVELS = 16;
    // @dev Number of levels in a tree excluding the root level
    uint256 public constant TREE_DEPTH = 15;

    // Max number of leaves in a tree
    uint256 internal constant MAX_LEAVES_NUM = (2 ** (TREE_DEPTH - 1)) * 3;
    // @dev Leaf zero value (`keccak256("Pantherprotocol")%SNARK_SCALAR_FIELD`)
    bytes32 public constant ZERO_VALUE = bytes32(
        uint256(2896678800030780677881716886212119387589061708732637213728415628433288554509)
    );
    // Merkle root of a tree that contains zeros only
    bytes32 internal constant ZERO_ROOT = bytes32(
        uint256(14919285665033013530198536872355210906877983143766398922640818583428789709397)
    );

    function populateZeros(bytes32[TREE_DEPTH] memory zeros) internal pure {
        zeros[0] = bytes32(uint256(2896678800030780677881716886212119387589061708732637213728415628433288554509));
        zeros[1] = bytes32(uint256(12610959546703067021829481548786041058957588484398889881477381005496514537462));
        zeros[2] = bytes32(uint256(3349047423219193406330965173426204517756040645871630854057691440868894250982));
        zeros[3] = bytes32(uint256(18389954371877325743937615564349876315640427734567075272665046346265626136419));
        zeros[4] = bytes32(uint256(3821922445747924499025173562938580174383118354164359337630642212084359151964));
        zeros[5] = bytes32(uint256(15935733969631511252102568819760944197418770481327957873988205677660925018528));
        zeros[6] = bytes32(uint256(11782991327328543086851214586786607762143799684091548387988272710726371549961));
        zeros[7] = bytes32(uint256(20296808824597379678225500535446241165197388668932210796624301020410505806483));
        zeros[8] = bytes32(uint256(4173461319953077503036196915980451538453535748888760632593364006273103304132));
        zeros[9] = bytes32(uint256(5766550159403151835612862031619173244724183903452415224168581364310081162759));
        zeros[10] = bytes32(uint256(10719667445803564685804016390777214089338112164281015443530526835727343022767));
        zeros[11] = bytes32(uint256(21349090590431709965480677812339735277896174812144673690644796244835835356674));
        zeros[12] = bytes32(uint256(19531707066138634990416163973328796061422245663290449768207249753220005371133));
        zeros[13] = bytes32(uint256(13000046769163827723557373669699328816629124803440350859991091474655812341048));
        zeros[14] = bytes32(uint256(8951578653298612361448433248556484464983144095284075554880538299310385645682));
    }
}

