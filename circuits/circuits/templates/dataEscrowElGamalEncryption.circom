// SPDX-License-Identifier: GPL-3.0-only
// SPDX-FileCopyrightText: Copyright 2021-25 Panther Protocol Foundation
pragma circom 2.1.9;

include "./utils.circom";

include "../../node_modules/circomlib/circuits/babyjub.circom";
include "../../node_modules/circomlib/circuits/bitify.circom";
include "../../node_modules/circomlib/circuits/escalarmulany.circom";
include "../../node_modules/circomlib/circuits/poseidon.circom";
include "../../node_modules/circomlib/circuits/gates.circom";

// NOTE-1:
// ************** 0. Three parties are involved in the data escrow encryption **************
// 1. DataEscrow - PubKeyEscrow = privKeyEscrow * Base8
// 2. Dao - PubKeyDao = privKeyDao * Base8
// 3. Zone - PubKeyZone = privKeyZone * Base8
//
// ************** 1. Tx sender computes **************
// Two ephemeral keys to be published (in clear)
// EphemeralKeyDao = randomDao * Base8
// EphemeralKeyZone = randomZone * Base8
// This key `EphemeralKeyEscrow` won't be published,
// instead, it will be encrypted for the Dao operator and the Zone operator,
// and the (two) ciphertext(s) will be published
// EphemeralKeyEscrow = randomEscrow * Base8
// SharedSecretDao = randomDao * PubKeyDao
// SharedSecretZone = randomZone * PubKeyZone
// MsgDao = MsgZone = EphemeralKeyEscrow (X)
// SharedKeyEscrow = randomEscrow * PubKeyEscrow
//
// k-seed = Poseidon( SharedKeyEscrow )
// for (i = 0; i < n; i++) {
//   CiphertextEsc[i] = Msg[i] + Poseidon( k-seed, i );
// }
//
// ************** 2. Tx sender publishes (as tx data) **************
//    1. EphemeralKeyDao (X)
//    2. CiphertextDao
//    3. CiphertextDaoHMAC
//    3. EphemeralKeyZone (X)
//    4. CiphertextZone
//    5. CiphertextZoneHMAC
//    5. CiphertextEscrow[0..n]
//    6. CiphertextEscrowHMAC
//
// ************** 3. If needed, either the DaoController or the ZoneController **************
//       computes and shares EphemeralKeyEscrow with the EscrowOperator
//
// If the DaoController does it
// SharedSecretDao = privKeyDao * EphemeralKeyDao
// k-seed = Poseidon( SharedSecretDao )
// EphemeralKeyEscrow = CiphertextDao - Invert ( Poseidon ( k-seed, 0 ) )
//
// If the ZoneController does it
// SharedSecretZone = privKeyZone * EphemeralKeyZone
// k-seed = Poseidon( SharedSecretZone )
// EphemeralKeyEscrow = CiphertextZone - Invert ( Poseidon ( k-seed, 0 ) )
//
// ************** 4. If needed, the EscrowOperator decrypts Msg[0..n] **************
// SharedKeyEscrow = privKeyEscrow * EphemeralKeyEscrow
// k-seed = Poseidon( SharedKeyEscrow )
// for (i = 0; i < n; i++) {
//   Msg[i] = CiphertextEscrow[i] - Invert( Poseidon( k-seed, i ) )
// }
//
// NOTE-2:
// The scalar multiplication functions from circomlib accept scalar factors
// of up to 252 bits maximum.
//
// Since `n` (Baby JubJub order) has 254 bits, not all valid scalar factors,
// which are less than n but has 253 bits and more, may be scalar factors for
// circomlib scalar multiplication functions.
// Moreover, since `n > SNARK_FIELD`, scalar factors greater than SNARK_FIELD
// but still less than n "fall outside" the field the circom operates in.
//
// Therefore, some of curve points can't be generated by a single scalar
// multiplication in circom. (If needed, scalar multiplication by a factor
// having more than 252 bits may be computed by 2 scalar multiplication and
// one point addition: for `m=l+i`, where l is the suborder, `m*G=l*G+i*G`).
//
// This is not a problem, however, for the BabyJubJub subgroup, which has
// the order being the number of 251 bits. In other words, any point in the
// subgroup may be generated (from Base8) by a single scalar multiplication.

// NOTE-3:
//    Encryption Process
//    The data escrow encryption process is as follows:
//    ** Step 1 **
//    First, generate a shared Diffie Hellman key KDH on the BabyJubJub curve, where one of the
//    Diffie-Hellman public keys is an ephemeral key. (Note that in other documentation, KDH may
//    be represented by SharedKeyEsc, and is computed as: SharedKeyEsc = randomEsc *
//    PubKeyEsc, but the nomenclature is simplified here for the reason of brevity.)
//    ** Step 2 **
//    Then, from KDH, ‘extract’ a key K-seed as follows:
//    K-seed=H(KDH),
//    where H is a hash function (Poseidon).
//    ** Step 3 **
//    For a message represented as s+1 blocks (field elements), each message block mi is
//    encrypted as:
//    ci = mi + H(K-seed, i)
//    where i=0, …,s, H is the Poseidon hash function, the plaintext ‘block’ mi is a field element in
//    the base field of BabyJubJub, and the multiplication is performed in the same field.
//    The ciphertext C consists of the blocks c0, …,cs.
//    ** Step 4 **
//    For some fixed t>s, let K-MAC=H(K-seed, t).
//    Compute envelop MAC = Hash ( K-MAC, Hash( K-MAC, C ) )
//    MAC is included as a public parameter in the proof.
//    Note: MAC is called `hmac` in the code but this is only the naming issue that maybe corrected in the future.
//    ** Verification **
//    It is necessary that the HMAC value is verified before attempting decryption.

template DataEscrowElGamalEncryption(ScalarsSize, PointsSize) {
    signal input {sub_order_bj_sf} ephemeralRandom;                               // randomness
    signal input {snark_ff}        scalarMessage[ScalarsSize];                    // scalars up to 64 bit data to encrypt
    signal input                   pointMessage[PointsSize][2];                   // ec points data to encrypt
    signal input {sub_order_bj_p}  pubKey[2];                                     // public key (assumed to be priv-key * B8)
    signal output {sub_order_bj_p} ephemeralPubKey[2];                            // ephemeral public-key

    var EncryptedDataSize = ScalarsSize + PointsSize;
    signal output                  encryptedMessage[EncryptedDataSize];           // encrypted data
    signal output                  encryptedMessageHash;                          // poseidon hash of encrypted data
    signal output                  hmac;                                          // hmac

    assert(ScalarsSize > 0);
    assert(PointsSize > 0);

    // [0] - Create ephemeral public key
    component ephemeralPubKeyBuilder = EphemeralPubKeysBuilder();
    ephemeralPubKeyBuilder.pubKey <== pubKey;
    ephemeralPubKeyBuilder.ephemeralRandom <== ephemeralRandom;
    // ephemeralPubKey output
    ephemeralPubKey <== ephemeralPubKeyBuilder.ephemeralPubKey;

    // [1] - create k-seed
    component kSeed = Poseidon(2);
    kSeed.inputs[0] <== ephemeralPubKeyBuilder.sharedPubKey[0];
    kSeed.inputs[1] <== ephemeralPubKeyBuilder.sharedPubKey[1];

    // [2] - encrypted data
    component helperHash[EncryptedDataSize];

    // scalars
    for(var i = 0; i < ScalarsSize; i++) {
        helperHash[i] = Poseidon(2);
        helperHash[i].inputs[0] <== kSeed.out;
        helperHash[i].inputs[1] <== i;

        encryptedMessage[i] <== scalarMessage[i] + helperHash[i].out;
    }

    // points
    for(var i = ScalarsSize; i < ScalarsSize+PointsSize; i++) {
        helperHash[i] = Poseidon(2);
        helperHash[i].inputs[0] <== kSeed.out;
        helperHash[i].inputs[1] <== i;

        encryptedMessage[i] <== pointMessage[i-ScalarsSize][0] + helperHash[i].out;
    }

    // [3] - cipher message hash
    assert(EncryptedDataSize < 15);
    component cipherMessageHash = Poseidon(EncryptedDataSize);
    cipherMessageHash.inputs <== encryptedMessage;
    encryptedMessageHash <== cipherMessageHash.out;

    // [4] - hmac (envelop mac)
    // k-mac = Hash ( k-seed, CipherMessageSize )
    // HMAC = Hash ( k-mac, Hash ( k-mac, CipherMessage ) )
    component kMac = Poseidon(2);
    kMac.inputs[0] <== kSeed.out;
    kMac.inputs[1] <== EncryptedDataSize;

    var innerHMacSize = 1 + EncryptedDataSize;
    assert(innerHMacSize < 15);
    component innerHMacHash = Poseidon(innerHMacSize);
    innerHMacHash.inputs[0] <== kMac.out;
    for(var i = 0; i < EncryptedDataSize; i++) {
        innerHMacHash.inputs[1+i] <== encryptedMessage[i];
    }

    var hmacSize = 1 + 1;
    component hmacHash = Poseidon(hmacSize);
    hmacHash.inputs[0] <== kMac.out;
    hmacHash.inputs[1] <== innerHMacHash.out;

    hmac <== hmacHash.out;
}
template EphemeralPubKeysBuilder() {
    signal input pubKey[2];                   // pub-key of trust-providers
    signal input ephemeralRandom;             // random per transaction
    signal output ephemeralPubKey[2];         // derived ephemeral pub-key: ePubKey = eRand * B8
    signal output sharedPubKey[2];            // derived shared pub-key: SharedPubKey = eRand * pubKey (eRand * privKey * B8)

    // shared-key = ephemeralRandom * pubKey

    component sharedKey_eRandMultPubKey = EscalarMulAny(253);
    sharedKey_eRandMultPubKey.p[0] <== pubKey[0];
    sharedKey_eRandMultPubKey.p[1] <== pubKey[1];

    // take the random to bits
    component n2b_eRand = Num2Bits(253);
    n2b_eRand.in <== ephemeralRandom;

    for (var j = 0; j < 253; j++) {
        sharedKey_eRandMultPubKey.e[j] <== n2b_eRand.out[j];
    }

    sharedPubKey <== sharedKey_eRandMultPubKey.out;

    // ephemeral pub-key = ephemeralRandom * Base8
    component ephemeralPubKey_eRandMultG = BabyPbk();

    ephemeralPubKey_eRandMultG.in <== ephemeralRandom;

    ephemeralPubKey[0] <== ephemeralPubKey_eRandMultG.Ax;
    ephemeralPubKey[1] <== ephemeralPubKey_eRandMultG.Ay;
}

// ------------- scalars-size --------------------------------
// Pack all scalars into in 254 bits Field elements
template DataEscrowSerializer(nUtxoIn,nUtxoOut,UtxoMerkleTreeDepth) {
    signal input {uint64} zAsset;                                            // 64 bit
    signal input {uint24} zAccountId;                                        // 24 bit
    signal input {uint16} zAccountZoneId;                                    // 16 bit
    signal input {uint32} zAccountNonce;                                     // 32 bit
    signal input {binary} utxoInMerkleTreeSelector[nUtxoIn][2];              // 2 bits: `00` - Taxi, `01` - Bus, `10` - Ferry
    signal input {binary} utxoInPathIndices[nUtxoIn][UtxoMerkleTreeDepth];   // 32 bit
    signal input {uint16} utxoInOriginZoneId[nUtxoIn];                       // 16 bit
    signal input {uint16} utxoOutTargetZoneId[nUtxoOut];                     // 16 bit

    signal input {uint64} utxoInAmount[nUtxoIn];                             // 64 bit
    signal input {uint64} utxoOutAmount[nUtxoOut];                           // 64 bit

    signal output {snark_ff} out[DataEscrowScalarSize_Fn(nUtxoIn, nUtxoOut,UtxoMerkleTreeDepth)];


    component num2bits_zAssetId = Num2Bits(64);
    num2bits_zAssetId.in <== zAsset;

    component num2bits_zAccountId = Num2Bits(24);
    num2bits_zAccountId.in <== zAccountId;

    component num2bits_zAccountZoneId = Num2Bits(16);
    num2bits_zAccountZoneId.in <== zAccountZoneId;

    component num2bits_zAccountNonce = Num2Bits(32);
    num2bits_zAccountNonce.in <== zAccountNonce;

    component num2bits_utxoInOriginZoneId[nUtxoIn];
    for (var i = 0; i < nUtxoIn; i++) {
        num2bits_utxoInOriginZoneId[i] = Num2Bits(16);
        num2bits_utxoInOriginZoneId[i].in <== utxoInOriginZoneId[i];
    }

    component num2bits_utxoOutTargetZoneId[nUtxoOut];
    for (var i = 0; i < nUtxoOut; i++) {
        num2bits_utxoOutTargetZoneId[i] = Num2Bits(16);
        num2bits_utxoOutTargetZoneId[i].in <== utxoOutTargetZoneId[i];
    }

    component num2bits_utxoInAmount[nUtxoIn];
    for (var i = 0; i < nUtxoIn; i++) {
        num2bits_utxoInAmount[i] = Num2Bits(64);
        num2bits_utxoInAmount[i].in <== utxoInAmount[i];
    }

    component num2bits_utxoOutAmount[nUtxoOut];
    for (var i = 0; i < nUtxoOut; i++) {
        num2bits_utxoOutAmount[i] = Num2Bits(64);
        num2bits_utxoOutAmount[i].in <== utxoOutAmount[i];
    }

    // serialize phase - bits2num components
    var scalarSize = DataEscrowScalarSize_Fn(nUtxoIn, nUtxoOut,UtxoMerkleTreeDepth);
    component bit2num[scalarSize];
    for (var i = 0; i < scalarSize; i++) {
        bit2num[i] = Bits2Num(254);
    }
    var scalarIndex = 0;
    var offset = 0;
    var expectedOffset = offset+64;

    for (var i = 0; i < 64; i++) {
        bit2num[scalarIndex].in[offset+i] <== num2bits_zAssetId.out[i];
    }
    offset = 64; // 64
    expectedOffset = offset+24; // 88

    for (var i = 0; i < 24; i++) {
        bit2num[scalarIndex].in[offset+i] <== num2bits_zAccountId.out[i];
    }
    offset = 64+24; // 88
    expectedOffset = offset+16; // 104

    for (var i = 0; i < 16; i++) {
        bit2num[scalarIndex].in[offset+i] <== num2bits_zAccountZoneId.out[i];
    }
    offset = 64+24+16; // 104
    expectedOffset = offset+32; // 136

    for (var i = 0; i < 32; i++) {
        bit2num[scalarIndex].in[offset+i] <== num2bits_zAccountNonce.out[i];
    }
    offset = 64+24+16+32; // 136
    assert(nUtxoIn < 3);
    expectedOffset = offset+nUtxoIn*2; // 136 + 2*nUtxoIn = 140

    for (var i = 0; i < nUtxoIn; i++) {
        for (var j = 0; j < 2; j++) {
            bit2num[scalarIndex].in[offset+i*2+j] <== utxoInMerkleTreeSelector[i][j];
        }
    }
    offset = 64+24+16+32+nUtxoIn*2; // 136 + 2*nUtxoIn = 136 + 2*2 = 140
    assert(UtxoMerkleTreeDepth < 33);
    expectedOffset = offset+nUtxoIn*UtxoMerkleTreeDepth; // 140 + nUtxoIn*UtxoMerkleTreeDepth = 140 + 2*32 = 204

    for (var i = 0; i < nUtxoIn; i++) {
        for (var j = 0; j < UtxoMerkleTreeDepth; j++) {
            bit2num[scalarIndex].in[offset+i*UtxoMerkleTreeDepth+j] <== utxoInPathIndices[i][j];
        }
    }

    offset = 64+24+16+32+nUtxoIn*2+nUtxoIn*UtxoMerkleTreeDepth; // 140 + nUtxoIn*UtxoMerkleTreeDepth = 140 + 2*32 = 204
    expectedOffset = offset+nUtxoIn*16; // 204 + nUtxoIn*UtxoMerkleTreeDepth = 200 + 2*16 = 235

    for (var i = 0; i < nUtxoIn; i++) {
        for (var j = 0; j < 16; j++) {
            bit2num[scalarIndex].in[offset+i*16+j] <== num2bits_utxoInOriginZoneId[i].out[j];
        }
    }

    offset = 64+24+16+32+nUtxoIn*2+nUtxoIn*UtxoMerkleTreeDepth+nUtxoIn*16; // 235
    expectedOffset = offset+nUtxoOut*16; // 235 + nUtxoOut*16 = 235 + 2*16 = 267

    if ( expectedOffset > 253 ) {
        for( var i = offset; i < 254; i++ ) {
            bit2num[scalarIndex].in[i] <== 0;
        }
        scalarIndex++;
        offset = 0;
        expectedOffset = 0;
    }

    // -------------------------------------------------------------------------------------------------------------- //
    for (var i = 0; i < nUtxoOut; i++) {
        for (var j = 0; j < 16; j++) {
            bit2num[scalarIndex].in[offset+i*16+j] <== num2bits_utxoOutTargetZoneId[i].out[j];
        }
    }
    offset = nUtxoOut*16; // 2*16 = 32
    expectedOffset = offset+nUtxoIn*64; // 32 + 2*64 = 160

    for (var i = 0; i < nUtxoIn; i++) {
        for (var j = 0; j < 64; j++) {
            bit2num[scalarIndex].in[offset+i*64+j] <== num2bits_utxoInAmount[i].out[j];
        }
    }
    offset = nUtxoOut*16 + nUtxoIn*64; // 32 + 2*64 = 160
    expectedOffset = offset+nUtxoOut*64; // 160 + 2*64 = 288

    if ( expectedOffset > 253 ) {
        for( var i = offset; i < 254; i++ ) {
            bit2num[scalarIndex].in[i] <== 0;
        }
        scalarIndex++;
        offset = 0;
        expectedOffset = 0;
    }
    // -------------------------------------------------------------------------------------------------------------- //
    assert(nUtxoOut < 3);
    for (var i = 0; i < nUtxoOut; i++) {
        for (var j = 0; j < 64; j++) {
            bit2num[scalarIndex].in[offset+i*64+j] <== num2bits_utxoOutAmount[i].out[j];
        }
    }
    offset = nUtxoOut*64; // 2*64 = 128
    expectedOffset = offset+0; // END
    for( var i = offset; i < 254; i++ ) {
        bit2num[scalarIndex].in[i] <== 0;
    }

    assert(scalarIndex + 1 == scalarSize);

    // -------------------------------------------------------------------------------------------------------------- //
    for (var i = 0; i <= scalarIndex; i++ ) {
        out[i] <== bit2num[i].out;
    }
}

template DataEscrowElGamalEncryptionPoint(PointsSize) {
    signal input {sub_order_bj_sf} ephemeralRandom;                               // randomness
    signal input                   pointMessage[PointsSize][2];                   // ec points data to encrypt
    signal input                   pubKey[2];                                     // public key
    signal output                  ephemeralPubKey[2];                            // ephemeral public-key
    signal output                  encryptedMessage[PointsSize];                  // encrypted data
    signal output                  encryptedMessageHash;                          // poseidon hash of encrypted data
    signal output                  hmac;                                          // hmac

    assert(PointsSize > 0);
    var EncryptedDataSize = PointsSize;

    // [0] - Create ephemeral public key
    component ephemeralPubKeyBuilder = EphemeralPubKeysBuilder();
    ephemeralPubKeyBuilder.pubKey <== pubKey;
    ephemeralPubKeyBuilder.ephemeralRandom <== ephemeralRandom;
    // ephemeralPubKey output
    ephemeralPubKey <== ephemeralPubKeyBuilder.ephemeralPubKey;

    // [1] - create k-seed
    component kSeed = Poseidon(2);
    kSeed.inputs[0] <== ephemeralPubKeyBuilder.sharedPubKey[0];
    kSeed.inputs[1] <== ephemeralPubKeyBuilder.sharedPubKey[1];

    // [2] - encrypted data
    component helperHash[EncryptedDataSize];

    // points
    for(var i = 0; i < EncryptedDataSize; i++) {
        helperHash[i] = Poseidon(2);
        helperHash[i].inputs[0] <== kSeed.out;
        helperHash[i].inputs[1] <== i;

        // Only the X-coordinate of pointMessage (utxoOutRootSpendPubKey) is used during encryption.
        // This is intentional by design, as the Y-coordinate can be derived from the elliptic curve equation and is therefore omitted.
        encryptedMessage[i] <== pointMessage[i][0] + helperHash[i].out;
    }
    // [3] - cipher message hash
    assert(EncryptedDataSize < 15);
    component cipherMessageHash = Poseidon(EncryptedDataSize);
    cipherMessageHash.inputs <== encryptedMessage;
    encryptedMessageHash <== cipherMessageHash.out;

    // [4] - hmac ( envelop mac )
    // k-mac = Hash ( k-seed, CipherMessageSize )
    // HMAC = Hash ( k-mac, Hash ( k-mac, CipherMessage ) )
    component kMac = Poseidon(2);
    kMac.inputs[0] <== kSeed.out;
    kMac.inputs[1] <== EncryptedDataSize;

    var innerHMacSize = 1 + EncryptedDataSize;
    assert(innerHMacSize < 15);
    component innerHMacHash = Poseidon(innerHMacSize);
    innerHMacHash.inputs[0] <== kMac.out;
    for(var i = 0; i < EncryptedDataSize; i++) {
        innerHMacHash.inputs[1+i] <== encryptedMessage[i];
    }

    var hmacSize = 1 + 1;
    component hmacHash = Poseidon(hmacSize);
    hmacHash.inputs[0] <== kMac.out;
    hmacHash.inputs[1] <== innerHMacHash.out;

    hmac <== hmacHash.out;
}

template DataEscrow(nUtxoIn, nUtxoOut, UtxoMerkleTreeDepth) {
    signal input {uint64}          zAssetId;
    signal input {uint24}          zAccountId;
    signal input {uint16}          zAccountZoneId;
    signal input {uint32}          zAccountNonce;
    signal input {binary}          utxoInMerkleTreeSelector[nUtxoIn][2];
    signal input {binary}          utxoInPathIndices[nUtxoIn][UtxoMerkleTreeDepth];
    signal input {uint64}          utxoInAmount[nUtxoIn];
    signal input {uint64}          utxoOutAmount[nUtxoOut];
    signal input {uint16}          utxoInOriginZoneId[nUtxoIn];
    signal input {uint16}          utxoOutTargetZoneId[nUtxoOut];
    signal input {sub_order_bj_p}  utxoOutRootSpendPubKey[nUtxoOut][2];

    // main data-escrow
    var dataEscrowScalarSize = DataEscrowScalarSize_Fn( nUtxoIn, nUtxoOut, UtxoMerkleTreeDepth );
    var dataEscrowPointSize = DataEscrowPointSize_Fn( nUtxoOut );
    var dataEscrowEncryptedPoints = DataEscrowEncryptedPoints_Fn( nUtxoIn, nUtxoOut, UtxoMerkleTreeDepth );

    signal input {sub_order_bj_sf} dataEscrowEphemeralRandom;
    signal input {sub_order_bj_p}  dataEscrowPubKey[2];
    signal input                   dataEscrowEphemeralPubKeyAx;
    signal input                   dataEscrowEphemeralPubKeyAy;
    signal input                   dataEscrowEncryptedMessage[dataEscrowEncryptedPoints];
    signal input                   dataEscrowEncryptedMessageHmac;
    signal output                  dataEscrowEncryptedMessageHash;

    // dao data-escrow
    var daoDataEscrowEncryptedPoints = DaoDataEscrowEncryptedPoints_Fn();

    signal input {sub_order_bj_sf} daoDataEscrowEphemeralRandom;
    signal input {sub_order_bj_p}  daoDataEscrowPubKey[2];
    signal input                   daoDataEscrowEphemeralPubKeyAx;
    signal input                   daoDataEscrowEphemeralPubKeyAy;
    signal input                   daoDataEscrowEncryptedMessage[daoDataEscrowEncryptedPoints];
    signal input                   daoDataEscrowEncryptedMessageHmac;


    // zZone data-escrow
    var zZoneDataEscrowEncryptedPoints = ZZoneDataEscrowEncryptedPoints_Fn();

    signal input {sub_order_bj_sf} zZoneDataEscrowEphemeralRandom;
    signal input {sub_order_bj_p}  zZoneDataEscrowPubKey[2];
    signal input                   zZoneDataEscrowEphemeralPubKeyAx;
    signal input                   zZoneDataEscrowEphemeralPubKeyAy;
    signal input                   zZoneDataEscrowEncryptedMessage[zZoneDataEscrowEncryptedPoints];
    signal input                   zZoneDataEscrowEncryptedMessageHmac;

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // START OF CODE /////////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // [0] - Data Escrow encryption //////////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // ------------- scalars-size --------------
    // -----------------------------------------
    // 1) zAssetId - 64 bit
    // 2) zAccountId - 24 bit
    // 3) zAccountZoneId - 16 bit
    // 4) zAccountNonce - 32 bit
    // 5) nUtxoIn x UtxoMerkleTreeSelector - 2 bits
    // 6) nUtxoIn x UtxoMerkleTreePathIndices - 32 bits
    // 7) nUtxoIn x UtxoInAmount - 64 bits
    // 8) nUtxoIn x UtxoInOriginZoneId - 16 bits
    // 9) nUtxoOut x UtxoOutAmount - 64 bits
    // 10) nUtxoOut x UtxoOutTargetZoneId - 16 bits
    // ------------- ec-points-size -------------
    // -----------------------------------------
    // 1) nUtxoOut x SpendPubKeys (x,y) - (already a points on EC)
    component dataEscrow = DataEscrowElGamalEncryption(dataEscrowScalarSize,dataEscrowPointSize);

    dataEscrow.ephemeralRandom <== dataEscrowEphemeralRandom;
    dataEscrow.pubKey[0] <== dataEscrowPubKey[0];
    dataEscrow.pubKey[1] <== dataEscrowPubKey[1];

    // [0.1] --------------- Scalars ----------------- //
    component dataEscrowScalarsSerializer = DataEscrowSerializer(nUtxoIn,nUtxoOut,UtxoMerkleTreeDepth);
    dataEscrowScalarsSerializer.zAsset <== zAssetId;
    dataEscrowScalarsSerializer.zAccountId <== zAccountId;
    dataEscrowScalarsSerializer.zAccountZoneId <== zAccountZoneId;
    dataEscrowScalarsSerializer.zAccountNonce <== zAccountNonce;

    for (var j = 0; j < nUtxoIn; j++) {
        for(var i = 0; i < 2; i++) {
            dataEscrowScalarsSerializer.utxoInMerkleTreeSelector[j][i] <== utxoInMerkleTreeSelector[j][i];
        }
        for(var i = 0; i < UtxoMerkleTreeDepth; i++) {
            dataEscrowScalarsSerializer.utxoInPathIndices[j][i] <== utxoInPathIndices[j][i];
        }
        dataEscrowScalarsSerializer.utxoInAmount[j] <== utxoInAmount[j];
        dataEscrowScalarsSerializer.utxoInOriginZoneId[j] <== utxoInOriginZoneId[j];
    }

    for (var j = 0; j < nUtxoOut; j++) {
        dataEscrowScalarsSerializer.utxoOutAmount[j] <== utxoOutAmount[j];
        dataEscrowScalarsSerializer.utxoOutTargetZoneId[j] <== utxoOutTargetZoneId[j];
    }

    for (var j = 0; j < dataEscrowScalarSize; j++) {
        dataEscrow.scalarMessage[j] <== dataEscrowScalarsSerializer.out[j];
    }

    // [0.2] ------------------ EC-Points ------------------ //
    // 1) nUtxoOut x SpendPubKeys (x,y) - (already a points on EC)
    for (var j = 0; j < nUtxoOut; j++) {
        dataEscrow.pointMessage[j][0] <== utxoOutRootSpendPubKey[j][0];
        dataEscrow.pointMessage[j][1] <== utxoOutRootSpendPubKey[j][1];
    }

    // verify EphemeralPubKey
    dataEscrowEphemeralPubKeyAx === dataEscrow.ephemeralPubKey[0];
    dataEscrowEphemeralPubKeyAy === dataEscrow.ephemeralPubKey[1];

    // verify Encryption
    for (var i = 0; i < dataEscrowEncryptedPoints; i++) {
        dataEscrowEncryptedMessage[i] === dataEscrow.encryptedMessage[i];
    }
    // verify Hash
    dataEscrowEncryptedMessageHash <== dataEscrow.encryptedMessageHash;
    // verify Hmac
    dataEscrowEncryptedMessageHmac === dataEscrow.hmac;

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // [1] - Dao Data Escrow encryption //////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    component daoDataEscrow = DataEscrowElGamalEncryptionPoint(daoDataEscrowEncryptedPoints);

    daoDataEscrow.ephemeralRandom <== daoDataEscrowEphemeralRandom;
    daoDataEscrow.pubKey[0] <== daoDataEscrowPubKey[0];
    daoDataEscrow.pubKey[1] <== daoDataEscrowPubKey[1];

    // push the only 1 point - the ephemeralPubKey
    daoDataEscrow.pointMessage[0][0] <== dataEscrow.ephemeralPubKey[0];
    daoDataEscrow.pointMessage[0][1] <== dataEscrow.ephemeralPubKey[1];

    // verify EphemeralPubKey
    daoDataEscrowEphemeralPubKeyAx === daoDataEscrow.ephemeralPubKey[0];
    daoDataEscrowEphemeralPubKeyAy === daoDataEscrow.ephemeralPubKey[1];

    // verify Encryption
    for (var i = 0; i < daoDataEscrowEncryptedPoints; i++) {
       daoDataEscrowEncryptedMessage[i] === daoDataEscrow.encryptedMessage[i];
    }
    // verify Hmac
    daoDataEscrowEncryptedMessageHmac === daoDataEscrow.hmac;

    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    // [2] - Zone Data Escrow encryption /////////////////////////////////////////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////////////////////////////////
    component zZoneDataEscrow = DataEscrowElGamalEncryptionPoint(zZoneDataEscrowEncryptedPoints);

    zZoneDataEscrow.ephemeralRandom <== zZoneDataEscrowEphemeralRandom;
    zZoneDataEscrow.pubKey[0] <== zZoneDataEscrowPubKey[0];
    zZoneDataEscrow.pubKey[1] <== zZoneDataEscrowPubKey[1];

    // push the only 1 point - the ephemeralPubKey
    zZoneDataEscrow.pointMessage[0][0] <== dataEscrow.ephemeralPubKey[0];
    zZoneDataEscrow.pointMessage[0][1] <== dataEscrow.ephemeralPubKey[1];

    // verify EphemeralPubKey
    zZoneDataEscrowEphemeralPubKeyAx === zZoneDataEscrow.ephemeralPubKey[0];
    zZoneDataEscrowEphemeralPubKeyAy === zZoneDataEscrow.ephemeralPubKey[1];

    // verify Encryption
    for (var i = 0; i < zZoneDataEscrowEncryptedPoints; i++) {
        zZoneDataEscrowEncryptedMessage[i] === zZoneDataEscrow.encryptedMessage[i];
    }
    // verify Hmac
    zZoneDataEscrowEncryptedMessageHmac === zZoneDataEscrow.hmac;
}
